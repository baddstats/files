
R Under development (unstable) (2020-10-21 r79360) -- "Unsuffered Consequences"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "spatstat"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('spatstat')
Loading required package: spatstat.data
Loading required package: nlme
Loading required package: rpart

spatstat 1.64-1       (nickname: 'Help you I can, yes!') 
For an introduction to spatstat, type 'beginner' 


Note: spatstat version 1.64-1 is out of date by more than 5 months; we recommend upgrading to the latest version.
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AreaInter")
> ### * AreaInter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AreaInter
> ### Title: The Area Interaction Point Process Model
> ### Aliases: AreaInter
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    ## Don't show: 
> op <- spatstat.options(ngrid.disc=8)
> ## End(Don't show)
> 
>    # prints a sensible description of itself
>    AreaInter(r=0.1)
Family of infinite-order interactions
Interaction:Area-interaction process
Disc radius:	0.1
> 
>    # Note the reach is twice the radius
>    reach(AreaInter(r=1))
[1] 2
> 
>    # Fit the stationary area interaction process to Swedish Pines data
>    data(swedishpines)
>    ppm(swedishpines, ~1, AreaInter(r=7))
Stationary Area-interaction process

First order term:  beta = 0.4783756

Disc radius:	7
Fitted interaction parameter eta:	 0.00342492

Relevant coefficients:
Interaction 
  -5.676677 

For standard errors, type coef(summary(x))
> 
>    # Fit the stationary area interaction process to `cells'
>    data(cells) 
>    ppm(cells, ~1, AreaInter(r=0.06))
Stationary Area-interaction process

First order term:  beta = 2226.012

Disc radius:	0.06
Fitted interaction parameter eta:	 3.05691e-09

Relevant coefficients:
Interaction 
  -19.60586 

For standard errors, type coef(summary(x))
>    # eta=0 indicates hard core process.
> 
>    # Fit a nonstationary area interaction with log-cubic polynomial trend
>    ## Not run: 
> ##D    ppm(swedishpines, ~polynom(x/10,y/10,3), AreaInter(r=7))
> ##D    
> ## End(Not run)
>    ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("BadGey")
> ### * BadGey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BadGey
> ### Title: Hybrid Geyer Point Process Model
> ### Aliases: BadGey
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    BadGey(c(0.1,0.2), c(1,1))
Saturated pairwise interaction family
Interaction:hybrid Geyer process
Interaction radii:	c(0.1, 0.2)
Saturation parameters:	c(1, 1)
>    # prints a sensible description of itself
>    BadGey(c(0.1,0.2), 1)
Saturated pairwise interaction family
Interaction:hybrid Geyer process
Interaction radii:	c(0.1, 0.2)
Saturation parameters:	1
> 
>    # fit a stationary Baddeley-Geyer model
>    ppm(cells ~1, BadGey(c(0.07, 0.1, 0.13), 2))
Stationary hybrid Geyer process

First order term:  beta = 2132.431

Interaction radii:	c(0.07, 0.1, 0.13)
Saturation parameters:	2
Fitted interaction parameters gamma_i
 [0,0.07)   [0,0.1)  [0,0.13) 
0.0001056 0.3050186 0.6719655 

Relevant coefficients:
Interact.1 Interact.2 Interact.3 
-9.1553884 -1.1873826 -0.3975484 

For standard errors, type coef(summary(x))
> 
>    # nonstationary process with log-cubic polynomial trend
>    ## Not run: 
> ##D    ppm(cells ~polynom(x,y,3), BadGey(c(0.07, 0.1, 0.13), 2))
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("CDF")
> ### * CDF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CDF
> ### Title: Cumulative Distribution Function From Kernel Density Estimate
> ### Aliases: CDF CDF.density
> ### Keywords: nonparametric univar
> 
> ### ** Examples
> 
>    b <- density(runif(10))
>    f <- CDF(b)
>    f(0.5)
[1] 0.4423102
>    plot(f)
> 
> 
> 
> cleanEx()
> nameEx("Concom")
> ### * Concom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Concom
> ### Title: The Connected Component Process Model
> ### Aliases: Concom
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    # prints a sensible description of itself
>    Concom(r=0.1)
Family of infinite-order interactions
Interaction:Connected component process
Distance threshold:	0.1
> 
>    # Fit the stationary connected component process to redwood data
>    ppm(redwood, ~1, Concom(r=0.07), rbord=0.07)
Stationary Connected component process

First order term:  beta = 23.45513

Distance threshold:	0.07
Fitted interaction parameter eta:	 4.51277

Relevant coefficients:
Interaction 
   1.506911 

For standard errors, type coef(summary(x))
> 
>    # Fit the stationary connected component process to `cells' data
>    ppm(cells, ~1, Concom(r=0.06), rbord=0.06)
Stationary Connected component process

First order term:  beta = 91.47395

Distance threshold:	0.06
Fitted interaction parameter eta:	 8.38115e-09

Relevant coefficients:
Interaction 
  -18.59728 

For standard errors, type coef(summary(x))
>    # eta=0 indicates hard core process.
> 
>    # Fit a nonstationary connected component model
>    # with log-cubic polynomial trend
>    ## Not run: 
> ##D    ppm(swedishpines, ~polynom(x/10,y/10,3), Concom(r=7), rbord=7)
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("DiggleGatesStibbard")
> ### * DiggleGatesStibbard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: DiggleGatesStibbard
> ### Title: Diggle-Gates-Stibbard Point Process Model
> ### Aliases: DiggleGatesStibbard
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    DiggleGatesStibbard(0.02)
Pairwise interaction family
Interaction:Diggle-Gates-Stibbard process
Interaction range:	0.02
>    # prints a sensible description of itself
> 
>    ## Not run: 
> ##D    ppm(cells ~1, DiggleGatesStibbard(0.05))
> ##D    # fit the stationary D-G-S process to `cells'
> ##D    
> ## End(Not run)
> 
>    ppm(cells ~ polynom(x,y,3), DiggleGatesStibbard(0.05))
Nonstationary Diggle-Gates-Stibbard process

Log trend:  ~x + y + I(x^2) + I(x * y) + I(y^2) + I(x^3) + I(x^2 * y) + I(x * 
y^2) + I(y^3)

Fitted trend coefficients:
(Intercept)           x           y      I(x^2)    I(x * y)      I(y^2) 
 4.45515179 -3.87045163 -0.04650163  7.45503111  2.58296379 -1.77147738 
     I(x^3)  I(x^2 * y)  I(x * y^2)      I(y^3) 
-4.33094967 -0.20195157 -2.77267033  2.19844535 

Interaction range:	0.05

For standard errors, type coef(summary(x))
>    # fit a nonstationary D-G-S process
>    # with log-cubic polynomial trend
> 
> 
> 
> cleanEx()
> nameEx("DiggleGratton")
> ### * DiggleGratton
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: DiggleGratton
> ### Title: Diggle-Gratton model
> ### Aliases: DiggleGratton
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    ppm(cells ~1, DiggleGratton(0.05, 0.1))
Stationary Diggle-Gratton process

First order term:  beta = 852.3699

Lower limit delta:	0.05
Upper limit rho:	0.1
Fitted exponent kappa:	 11.9408961

Relevant coefficients:
Interaction 
    11.9409 

For standard errors, type coef(summary(x))
> 
> 
> 
> cleanEx()
> nameEx("Emark")
> ### * Emark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Emark
> ### Title: Diagnostics for random marking
> ### Aliases: Emark Vmark
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     plot(Emark(spruces))
>     E <- Emark(spruces, method="density", kernel="epanechnikov")
>     plot(Vmark(spruces))
> 
>     plot(Emark(finpines))
>     V <- Vmark(finpines)
> 
> 
> 
> cleanEx()
> nameEx("Extract.anylist")
> ### * Extract.anylist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.anylist
> ### Title: Extract or Replace Subset of a List of Things
> ### Aliases: [.anylist [<-.anylist
> ### Keywords: spatial list manip
> 
> ### ** Examples
> 
>    x <- anylist(A=runif(10), B=runif(10), C=runif(10))
>    x[1] <- list(A=rnorm(10))
>  
> 
> 
> cleanEx()
> nameEx("Extract.fasp")
> ### * Extract.fasp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.fasp
> ### Title: Extract Subset of Function Array
> ### Aliases: [.fasp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  # Lansing woods data - multitype points with 6 types
>  woods <- lansing
>  ## Don't show: 
>  # smaller dataset
>    woods <- woods[ seq(1,npoints(woods),by=45)]
>  
> ## End(Don't show)
>  # compute 6 x 6 array of all cross-type K functions
>  a <- alltypes(woods, "K")
> 
>  # extract first three marks only
>  b <- a[1:3,1:3]
>  ## Not run: plot(b)
>  # subset of array pertaining to hickories
>  h <- a[levels(marks(woods)) == "hickory", ]
>  ## Not run: plot(h)
> 
> 
> 
> cleanEx()
> nameEx("Extract.fv")
> ### * Extract.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.fv
> ### Title: Extract or Replace Subset of Function Values
> ### Aliases: [.fv [<-.fv $<-.fv
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  K <- Kest(cells)
> 
>  # discard the estimates of K(r) for r  > 0.1
>  Ksub <- K[K$r <= 0.1, ]
> 
>  # extract the border method estimates
>  bor <- K[ , "border", drop=TRUE]
>  # or equivalently
>  bor <- K$border
> 
>  # remove the border-method estimates
>  K$border <- NULL
>  K
Function value object (class 'fv')
for the function r -> K(r)
.............................................................
      Math.label       Description                           
r     r                distance argument r                   
theo  K[pois](r)       theoretical Poisson K(r)              
trans hat(K)[trans](r) translation-corrected estimate of K(r)
iso   hat(K)[iso](r)   isotropic-corrected estimate of K(r)  
.............................................................
Default plot formula:  .~.x
where "." stands for 'iso', 'trans', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
> 
> 
> cleanEx()
> nameEx("Extract.hyperframe")
> ### * Extract.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.hyperframe
> ### Title: Extract or Replace Subset of Hyperframe
> ### Aliases: [.hyperframe [<-.hyperframe $.hyperframe $<-.hyperframe
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   h <- hyperframe(X=list(square(1), square(2)), Y=list(sin, cos))
>   h
Hyperframe:
       X          Y
1 (owin) (function)
2 (owin) (function)
>   h[1, ]
Hyperframe:
       X          Y
1 (owin) (function)
>   h[1, ,drop=TRUE]
X:
window: rectangle = [0, 1] x [0, 1] units

Y:
function (x)  .Primitive("sin")
>   h[ , 1]
Hyperframe:
       X
1 (owin)
2 (owin)
>   h[ , 1, drop=TRUE]
List of spatial objects

1:
window: rectangle = [0, 1] x [0, 1] units

2:
window: rectangle = [0, 2] x [0, 2] units
>   h[1,1]
Hyperframe:
       X
1 (owin)
>   h[1,1,drop=TRUE]
window: rectangle = [0, 1] x [0, 1] units
>   h[1,1,drop=TRUE,strip=FALSE]
List of spatial objects

X:
window: rectangle = [0, 1] x [0, 1] units
>   h[1,1] <- list(square(3))
>   # extract column
>   h$X
List of spatial objects

1:
window: rectangle = [0, 3] x [0, 3] units

2:
window: rectangle = [0, 2] x [0, 2] units
>   # replace existing column
>   h$Y <- list(cells, cells)
>   # add new column
>   h$Z <- list(cells, cells)
> 
> 
> 
> cleanEx()
> nameEx("Extract.im")
> ### * Extract.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.im
> ### Title: Extract Subset of Image
> ### Aliases: [.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  # make up an image
>  X <- setcov(unit.square())
>  plot(X)
> 
>  # a rectangular subset
>  W <- owin(c(0,0.5),c(0.2,0.8))
>  Y <- X[W]
>  plot(Y)
> 
>  # a polygonal subset
>  R <- affine(letterR, diag(c(1,1)/2), c(-2,-0.7))
>  plot(X[R, drop=FALSE])
>  plot(X[R, drop=FALSE, tight=TRUE])
> 
>  # a point pattern
>  P <- rpoispp(20)
>  Y <- X[P]
> 
>  # look up a specified location
>  X[list(x=0.1,y=0.2)]
[1] 0.7159424
> 
>  # 10 x 10 pixel array
>  X <- as.im(function(x,y) { x + y }, owin(c(-1,1),c(-1,1)), dimyx=10)
>  # 100 x 100 
>  W <- as.mask(disc(1, c(0,0)), dimyx=100)
>  # 10 x 10 raster
>  X[W,drop=FALSE]
real-valued pixel image
10 x 10 pixel array (ny, nx)
enclosing rectangle: [-1, 1] x [-1, 1] units
>  # 100 x 100 raster
>  X[W, raster=W, drop=FALSE]
real-valued pixel image
100 x 100 pixel array (ny, nx)
enclosing rectangle: [-1, 1] x [-1, 1] units
> 
> 
> 
> cleanEx()
> nameEx("Extract.influence.ppm")
> ### * Extract.influence.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.influence.ppm
> ### Title: Extract Subset of Influence Object
> ### Aliases: [.influence.ppm
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    fit <- ppm(cells, ~x)
>    infl <- influence(fit)
>    b <- owin(c(0.1, 0.3), c(0.2, 0.4))
>    infl[b]
Point process influence measure
for model: fit

Exact values:
Marked planar point pattern: 1 point
marks are numeric, of storage type  'double'
window: rectangle = [0.1, 0.3] x [0.2, 0.4] units
>    infl[1:5]
Point process influence measure
for model: fit

Exact values:
Marked planar point pattern: 5 points
marks are numeric, of storage type  'double'
window: rectangle = [0, 1] x [0, 1] units
>    marks(as.ppp(infl))[1:3]
[1] 0.01600471 0.01205264 0.01389672
> 
> 
> 
> cleanEx()
> nameEx("Extract.layered")
> ### * Extract.layered
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.layered
> ### Title: Extract or Replace Subset of a Layered Object
> ### Aliases: [.layered [<-.layered [[<-.layered
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  D <- distmap(cells)
>  L <- layered(D, cells,
+               plotargs=list(list(ribbon=FALSE), list(pch=16)))
> 
>  L[-2]
Layered object

Layer 1:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
Includes plot arguments for Layer 1
>  L[, square(0.5)]
Layered object

Layer 1:
real-valued pixel image
64 x 64 pixel array (ny, nx)
enclosing rectangle: [0, 0.5] x [0, 0.5] units

Layer 2:
Planar point pattern: 12 points
window: rectangle = [0, 0.5] x [0, 0.5] units
Includes plot arguments for Layer 1 and Layer 2
> 
>  L[[3]] <- japanesepines
>  L
Layered object

Layer 1:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units

Layer 2:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units

Layer 3:
Planar point pattern: 65 points
window: rectangle = [0, 1] x [0, 1] units (one unit = 5.7 metres)
Includes plot arguments for Layer 1 and Layer 2
> 
> 
> 
> cleanEx()
> nameEx("Extract.leverage.ppm")
> ### * Extract.leverage.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.leverage.ppm
> ### Title: Extract Subset of Leverage Object
> ### Aliases: [.leverage.ppm
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    fit <- ppm(cells ~x)
>    lev <- leverage(fit)
>    b <- owin(c(0.1, 0.3), c(0.2, 0.4))
>    lev[b]
Point process leverage function
for model: fit

Exact values:
Marked planar point pattern: 50 points
marks are numeric, of storage type  'double'
window: rectangle = [0.1, 0.3] x [0.2, 0.4] units

Smoothed values:
real-valued pixel image
51 x 51 pixel array (ny, nx)
enclosing rectangle: [0.10156, 0.30078] x [0.19922, 0.39844] units

Average value: 2.11023239973015
>    lev[cells]
 [1] 1.309495 1.018492 1.208524 1.891010 2.278735 2.953766 1.855794 1.152854
 [9] 1.061595 1.643357 3.189205 2.001375 1.400567 1.053224 1.247228 2.983848
[17] 1.353568 1.038497 1.105113 2.060593 3.412398 2.441582 1.309495 1.040142
[25] 1.577446 2.591920 3.825809 3.189205 2.267781 1.353568 1.038497 1.013560
[33] 1.643357 2.591920 1.855794 1.208524 1.891010 2.983848 2.267781 1.309495
[41] 1.038497 1.162468
> 
> 
> 
> cleanEx()
> nameEx("Extract.linim")
> ### * Extract.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.linim
> ### Title: Extract Subset of Pixel Image on Linear Network
> ### Aliases: [.linim
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   M <- as.mask.psp(as.psp(simplenet))
>   Z <- as.im(function(x,y){x}, W=M)
>   Y <- linim(simplenet, Z)
>   X <- runiflpp(4, simplenet)
>   Y[X]
[1] 0.3554688 0.5195312 0.7617188 0.7304688
>   Y[square(c(0.3, 0.6))]
Image on linear network
Linear network with 7 vertices and 6 lines
Enclosing window: binary image mask
39 x 39 pixel array (ny, nx)
enclosing rectangle: [0.296875, 0.6015625] x [0.296875, 0.6015625] units
real-valued pixel image
39 x 39 pixel array (ny, nx)
enclosing rectangle: [0.29688, 0.60156] x [0.29688, 0.60156] units
 Data frame: 108 sample points along network
 Average density: one sample point per 0.00642 units
> 
> 
> 
> cleanEx()
> nameEx("Extract.linnet")
> ### * Extract.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.linnet
> ### Title: Extract Subset of Linear Network
> ### Aliases: [.linnet
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   p <- par(mfrow=c(1,2), mar=0.2+c(0,0,1,0))
>   B <- owin(c(0.1,0.7),c(0.19,0.6))
> 
>   plot(simplenet, main="x[w, snip=TRUE]")
>   plot(simplenet[B], add=TRUE, col="green", lwd=3)
>   plot(B, add=TRUE, border="red", lty=3)
> 
>   plot(simplenet, main="x[w, snip=FALSE]")
>   plot(simplenet[B, snip=FALSE], add=TRUE, col="green", lwd=3)
>   plot(B, add=TRUE, border="red", lty=3)
> 
>   par(p)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("Extract.listof")
> ### * Extract.listof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.listof
> ### Title: Extract or Replace Subset of a List of Things
> ### Aliases: [<-.listof
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    x <- list(A=runif(10), B=runif(10), C=runif(10))
>    class(x) <- c("listof", class(x))
>    x[1] <- list(A=rnorm(10))
>  
> 
> 
> cleanEx()
> nameEx("Extract.lpp")
> ### * Extract.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.lpp
> ### Title: Extract Subset of Point Pattern on Linear Network
> ### Aliases: [.lpp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # Chicago crimes data - remove cases of assault
>   chicago[marks(chicago) != "assault"]
Point pattern on linear network
95 points
Multitype, with possible types: 
   assault burglary cartheft damage robbery theft trespass
Linear network with 338 vertices and 503 lines
Enclosing window: rectangle = [0.3894, 1281.9863] x [153.1035, 1276.5602] feet
>   # equivalent to subset(chicago, select=-assault)
> 
>   # spatial window subset
>   B <- owin(c(350, 700), c(600, 1000))
>   plot(chicago)
>   plot(B, add=TRUE, lty=2, border="red", lwd=3)
>   op <- par(mfrow=c(1,2), mar=0.6+c(0,0,1,0))
>   plot(B, main="chicago[B, snip=FALSE]", lty=3, border="red")
>   plot(chicago[, B, snip=FALSE], add=TRUE)
>   plot(B, main="chicago[B, snip=TRUE]", lty=3, border="red")
>   plot(chicago[, B, snip=TRUE], add=TRUE)
>   par(op)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("Extract.msr")
> ### * Extract.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.msr
> ### Title: Extract Subset of Signed or Vector Measure
> ### Aliases: [.msr
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X ~x+y)
>    rp <- residuals(fit, type="pearson")
>    rs <- residuals(fit, type="score")
> 
>    rp[square(0.5)]
Scalar-valued measure
Approximated by 269 quadrature points
window: rectangle = [0, 0.5] x [0, 0.5] units
12 atoms
Total mass:
discrete = 1.6941   continuous = -1.6929   total = 0.0011651
>    rs[ , 2:3]
2-dimensional vector-valued measure
vector components: 'x' and 'y'
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
x:	 discrete = 92.592   continuous = -92.592   total = -5.5327e-12
y:	 discrete = 64.064   continuous = -64.064   total = -8.1466e-12
> 
> 
> 
> cleanEx()
> nameEx("Extract.owin")
> ### * Extract.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.owin
> ### Title: Extract Subset of Window
> ### Aliases: [.owin
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  W <- owin(c(2.5, 3.2), c(1.4, 2.9))
>  plot(letterR)
>  plot(letterR[W], add=TRUE, col="red")
> 
> 
> 
> cleanEx()
> nameEx("Extract.ppp")
> ### * Extract.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.ppp
> ### Title: Extract or Replace Subset of Point Pattern
> ### Aliases: [.ppp [<-.ppp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  # Longleaf pines data
>  lon <- longleaf
>  ## Not run: 
> ##D  plot(lon)
> ##D  
> ## End(Not run)
>  ## Don't show: 
> lon <- lon[seq(1,npoints(lon),by=10)]
> ## End(Don't show)
> 
>  # adult trees defined to have diameter at least 30 cm
>  longadult <- subset(lon, marks >= 30)
>  ## Not run: 
> ##D  plot(longadult)
> ##D  
> ## End(Not run)
>  # note that the marks are still retained.
>  # Use unmark(longadult) to remove the marks
>  
>  # New Zealand trees data
>  ## Not run: 
> ##D  plot(nztrees)          # plot shows a line of trees at the far right
> ##D  abline(v=148, lty=2)   # cut along this line
> ##D  
> ## End(Not run)
>  nzw <- owin(c(0,148),c(0,95)) # the subwindow
>  # trim dataset to this subwindow
>  nzsub <- nztrees[nzw]
>  ## Not run: 
> ##D  plot(nzsub)
> ##D  
> ## End(Not run)
> 
>  # Redwood data
>  ## Not run: 
> ##D  plot(redwood)
> ##D  
> ## End(Not run)
>  # Random thinning: delete 60% of data
>  retain <- (runif(npoints(redwood)) < 0.4)
>  thinred <- redwood[retain]
>  ## Not run: 
> ##D  plot(thinred)
> ##D  
> ## End(Not run)
> 
>  # Scramble 60% of data
>  X <- redwood
>  modif <- (runif(npoints(X)) < 0.6)
>  X[modif] <- runifpoint(ex=X[modif])
> 
>  # Lansing woods data - multitype points
>  lan <- lansing
>  ## Don't show: 
>     lan <- lan[seq(1, npoints(lan), length=100)]
>  
> ## End(Don't show)
> 
>  # Hickory trees
>   hicks <- split(lansing)$hickory
> 
>  # Trees in subwindow
>   win <- owin(c(0.3, 0.6),c(0.2, 0.5))
>   lsub <- lan[win]
> 
>  # Scramble the locations of trees in subwindow, retaining their marks
>   lan[win] <- runifpoint(ex=lsub) %mark% marks(lsub)
> 
>  # Extract oaks only
>  oaknames <- c("redoak", "whiteoak", "blackoak")
>  oak <- lan[marks(lan) %in% oaknames, drop=TRUE]
>  oak <- subset(lan, marks %in% oaknames, drop=TRUE)
> 
>  # To clip or not to clip
>  X <- runifpoint(25, letterR)
>  B <- owin(c(2.2, 3.9), c(2, 3.5))
>  opa <- par(mfrow=c(1,2))
>  plot(X, main="X[B]")
>  plot(X[B], border="red", cols="red", add=TRUE, show.all=TRUE, main="")
>  plot(X, main="X[B, clip=TRUE]")
>  plot(B, add=TRUE, lty=2)
>  plot(X[B, clip=TRUE], border="blue", cols="blue", add=TRUE,
+       show.all=TRUE, main="")
>  par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("Extract.ppx")
> ### * Extract.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.ppx
> ### Title: Extract Subset of Multidimensional Point Pattern
> ### Aliases: [.ppx
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(4),y=runif(4),z=runif(4))
>    X <- ppx(data=df, coord.type=c("s","s","t"))
>    X[-2]
Multidimensional point pattern
3 points 
2-dimensional space coordinates (x,y)
1-dimensional time coordinates (z)
> 
> 
> 
> cleanEx()
> nameEx("Extract.psp")
> ### * Extract.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.psp
> ### Title: Extract Subset of Line Segment Pattern
> ### Aliases: [.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>     a <- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
>     plot(a)
>   # thinning
>     id <- sample(c(TRUE, FALSE), 20, replace=TRUE)
>     b <- a[id]
>     plot(b, add=TRUE, lwd=3)
>  # trimming
>     plot(a)
>     w <- owin(c(0.1,0.7), c(0.2, 0.8))
>     b <- a[w]
>     plot(b, add=TRUE, col="red", lwd=2)
>     plot(w, add=TRUE)
>     u <- a[w, fragments=FALSE]
>     plot(u, add=TRUE, col="blue", lwd=3)
> 
> 
> 
> cleanEx()
> nameEx("Extract.quad")
> ### * Extract.quad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.quad
> ### Title: Subset of Quadrature Scheme
> ### Aliases: [.quad
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  Q <- quadscheme(nztrees)
>  W <- owin(c(0,148),c(0,95)) # a subwindow
>  Q[W]
Quadrature scheme (Berman-Turner)
78 data points, 994 dummy points
     (provided manually)
     Total weight 14080.78125
> 
> 
> 
> cleanEx()
> nameEx("Extract.solist")
> ### * Extract.solist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.solist
> ### Title: Extract or Replace Subset of a List of Spatial Objects
> ### Aliases: [.solist [<-.solist
> ### Keywords: spatial list manip
> 
> ### ** Examples
> 
>    x <- solist(japanesepines, cells, redwood)
>    x[2:3]
List of point patterns

Component 1:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units

Component 2:
Planar point pattern: 62 points
window: rectangle = [0, 1] x [-1, 0] units
>    x[square(0.5)]
List of point patterns

Component 1:
Planar point pattern: 13 points
window: rectangle = [0, 0.5] x [0, 0.5] units (one unit = 5.7 metres)

Component 2:
Planar point pattern: 12 points
window: rectangle = [0, 0.5] x [0, 0.5] units

Component 3:
Planar point pattern: 0 points
window: rectangle = [0, 0.5] x [0, 0.5] units
>    x[1] <- list(finpines)
>  
> 
> 
> cleanEx()
> nameEx("Extract.splitppp")
> ### * Extract.splitppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.splitppp
> ### Title: Extract or Replace Sub-Patterns
> ### Aliases: [.splitppp [<-.splitppp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(amacrine)  # multitype point pattern
>   y <- split(amacrine)
>   y[1]
Point pattern split by factor 

off:
Planar point pattern: 142 points
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
>   y["off"]
Point pattern split by factor 

off:
Planar point pattern: 142 points
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
>   y[1] <- list(runifpoint(42, Window(amacrine)))
>  
> 
> 
> cleanEx()
> nameEx("Extract.ssf")
> ### * Extract.ssf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: [.ssf
> ### Title: Subset of spatially sampled function
> ### Aliases: [.ssf
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   f <- ssf(cells, data.frame(d=nndist(cells), i=1:42))
>   f
Spatially sampled function
Locations:
	Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
2-vector valued function
Component names: 'd' and 'i'
>   f[1:10,]
Spatially sampled function
Locations:
	Planar point pattern: 10 points
window: rectangle = [0, 1] x [0, 1] units
2-vector valued function
Component names: 'd' and 'i'
>   f[ ,1]
Spatially sampled function
Locations:
	Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
Scalar valued function
> 
> 
> 
> cleanEx()
> nameEx("Extract.tess")
> ### * Extract.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract.tess
> ### Title: Extract or Replace Subset of Tessellation
> ### Aliases: [.tess [<-.tess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    ## Don't show: 
> op <- spatstat.options(npixel=10)
> ## End(Don't show)
>    A <- tess(xgrid=0:4, ygrid=0:3)
>    B <- A[c(1, 3, 7)]
>    E <- A[-1]
>    A[c(2, 5, 11)] <- NULL
>    ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("F3est")
> ### * F3est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: F3est
> ### Title: Empty Space Function of a Three-Dimensional Point Pattern
> ### Aliases: F3est
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   ## Don't show: 
> op <- spatstat.options(nvoxel=2^18)
> ## End(Don't show)
>   X <- rpoispp3(42)
>   Z <- F3est(X)
>   if(interactive()) plot(Z)
>   ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("Fest")
> ### * Fest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Fest
> ### Title: Estimate the Empty Space Function or its Hazard Rate
> ### Aliases: Fest Fhazard
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    Fc <- Fest(cells, 0.01)
> 
>    # Tip: don't use F for the left hand side!
>    # That's an abbreviation for FALSE
> 
>    plot(Fc)
> 
>    # P-P style plot
>    plot(Fc, cbind(km, theo) ~ theo)
> 
>    # The empirical F is above the Poisson F
>    # indicating an inhibited pattern
> 
>    ## Not run: 
> ##D    plot(Fc, . ~ theo)
> ##D    plot(Fc, asin(sqrt(.)) ~ asin(sqrt(theo)))
> ##D    
> ## End(Not run)
>    ## Don't show: 
>    Fh <- Fhazard(cells)
>    
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("Fiksel")
> ### * Fiksel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Fiksel
> ### Title: The Fiksel Interaction
> ### Aliases: Fiksel
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    Fiksel(r=1,hc=0.02, kappa=2)
Pairwise interaction family
Interaction:Fiksel process
Interaction distance:	1
Hard core distance:	0.02
Rate parameter:	2
>    # prints a sensible description of itself
> 
>    data(spruces)
>    X <- unmark(spruces)
> 
>    fit <- ppm(X ~ 1, Fiksel(r=3.5, kappa=1))
>    plot(fitin(fit))
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("Finhom")
> ### * Finhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Finhom
> ### Title: Inhomogeneous Empty Space Function
> ### Aliases: Finhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   ## Not run: 
> ##D   plot(Finhom(swedishpines, sigma=bw.diggle, adjust=2))
> ##D   
> ## End(Not run)
>   plot(Finhom(swedishpines, sigma=10))
> 
> 
> 
> cleanEx()
> nameEx("FmultiInhom")
> ### * FmultiInhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FmultiInhom
> ### Title: Inhomogeneous Marked F-Function
> ### Aliases: FmultiInhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- amacrine
>   J <- (marks(X) == "off")
>   mod <- ppm(X ~ marks * x)
>   lam <- fitted(mod, dataonly=TRUE)
>   lmin <- min(predict(mod)[["off"]]) * 0.9
>   plot(FmultiInhom(X, J, lambda=lam, lambdamin=lmin))
> 
> 
> 
> cleanEx()
> nameEx("Frame")
> ### * Frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Frame
> ### Title: Extract or Change the Containing Rectangle of a Spatial Object
> ### Aliases: Frame Frame<- Frame.default Frame<-.default Frame<-.owin
> ###   Frame<-.ppp Frame<-.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    Frame(cells)
window: rectangle = [0, 1] x [0, 1] units
>    X <- demopat
>    Frame(X)
window: rectangle = [525, 10575] x [450, 7125] furlongs
>    Frame(X) <- owin(c(0, 11000), c(400, 8000))
> 
> 
> 
> cleanEx()
> nameEx("G3est")
> ### * G3est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: G3est
> ### Title: Nearest Neighbour Distance Distribution Function of a
> ###   Three-Dimensional Point Pattern
> ### Aliases: G3est
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- rpoispp3(42)
>   Z <- G3est(X)
>   if(interactive()) plot(Z)
> 
> 
> 
> cleanEx()
> nameEx("Gcom")
> ### * Gcom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Gcom
> ### Title: Model Compensator of Nearest Neighbour Function
> ### Aliases: Gcom
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(cells)
>     fit0 <- ppm(cells, ~1) # uniform Poisson
>     G0 <- Gcom(fit0)
>     G0
Function value object (class 'fv')
for the function r -> G(r)
...............................................................................
       Math.label               Description                                    
r      r                        distance argument r                            
pois   G[pois](r)               theoretical Poisson G(r)                       
border hat(G)[bord](r)          border-corrected nonparametric estimate of G(r)
bcom   bold(C)~hat(G)[bord](r)  model compensator of border-corrected G(r)     
han    hat(G)[han](r)           Hanisch correction estimate of G(r)            
hcom   bold(C)~hat(G)[han](r)   model compensator of Hanisch-corrected G(r)    
hvar   bold(C)^2~hat(G)[han](r) Poincare variance for Hanisch corrected G(r)   
...............................................................................
Default plot formula:  .~r
where "." stands for 'han', 'hcom', 'border', 'bcom', 'pois'
Recommended range of argument r: [0, 0.18693]
Available range of argument r: [0, 0.29539]
>     plot(G0)
> # uniform Poisson is clearly not correct
> 
> # Hanisch estimates only
>     plot(Gcom(fit0), cbind(han, hcom) ~ r)
> 
>     fit1 <- ppm(cells, ~1, Strauss(0.08))
>     plot(Gcom(fit1), cbind(han, hcom) ~ r)
> 
> # Try adjusting interaction distance
> 
>     fit2 <- update(fit1, Strauss(0.10))
>     plot(Gcom(fit2), cbind(han, hcom) ~ r)
> 
>     G3 <- Gcom(cells, interaction=Strauss(0.12))
>     plot(G3, cbind(han, hcom) ~ r)
> 
> 
> 
> cleanEx()
> nameEx("Gcross")
> ### * Gcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Gcross
> ### Title: Multitype Nearest Neighbour Distance Function (i-to-j)
> ### Aliases: Gcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # amacrine cells data
>     G01 <- Gcross(amacrine)
> 
>     # equivalent to:
>     ## Not run: 
> ##D     G01 <- Gcross(amacrine, "off", "on")
> ##D     
> ## End(Not run)
> 
>     plot(G01)
> 
>     # empty space function of `on' points
>     ## Not run: 
> ##D        F1 <- Fest(split(amacrine)$on, r = G01$r)
> ##D        lines(F1$r, F1$km, lty=3)
> ##D     
> ## End(Not run)
> 
>     # synthetic example    
>     pp <- runifpoispp(30)
>     pp <- pp %mark% factor(sample(0:1, npoints(pp), replace=TRUE))
>     G <- Gcross(pp, "0", "1")   # note: "0" not 0
> 
> 
> 
> cleanEx()
> nameEx("Gdot")
> ### * Gdot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Gdot
> ### Title: Multitype Nearest Neighbour Distance Function (i-to-any)
> ### Aliases: Gdot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # amacrine cells data
>     G0. <- Gdot(amacrine, "off") 
>     plot(G0.)
> 
>     # synthetic example    
>     pp <- runifpoispp(30)
>     pp <- pp %mark% factor(sample(0:1, npoints(pp), replace=TRUE))
>     G <- Gdot(pp, "0")
>     G <- Gdot(pp, 0) # equivalent
> 
> 
> 
> cleanEx()
> nameEx("Gest")
> ### * Gest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Gest
> ### Title: Nearest Neighbour Distance Function G
> ### Aliases: Gest nearest.neighbour
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(cells)
>   G <- Gest(cells)
>   plot(G)
> 
>   # P-P style plot
>   plot(G, cbind(km,theo) ~ theo)
> 
>   # the empirical G is below the Poisson G,
>   # indicating an inhibited pattern
> 
>   ## Not run: 
> ##D      plot(G, . ~ r)
> ##D      plot(G, . ~ theo)
> ##D      plot(G, asin(sqrt(.)) ~ asin(sqrt(theo)))
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Geyer")
> ### * Geyer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Geyer
> ### Title: Geyer's Saturation Point Process Model
> ### Aliases: Geyer
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    ppm(cells, ~1, Geyer(r=0.07, sat=2))
Stationary Geyer saturation process

First order term:  beta = 121.6634

Interaction distance:	0.07
Saturation parameter:	2
Fitted interaction parameter gamma:	 6.68e-05

Relevant coefficients:
Interaction 
  -9.614164 

For standard errors, type coef(summary(x))
>    # fit the stationary saturation process to `cells'
> 
> 
> 
> cleanEx()
> nameEx("Gfox")
> ### * Gfox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Gfox
> ### Title: Foxall's Distance Functions
> ### Aliases: Gfox Jfox
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(copper)
>   X <- copper$SouthPoints
>   Y <- copper$SouthLines
>   G <- Gfox(X,Y)
>   J <- Jfox(X,Y, correction="km")
Warning in (function (fmt, ...)  : argument not used by format
>   ## Don't show: 
>   J <- Jfox(X,Y, correction="km", eps=1)
Warning in (function (fmt, ...)  : argument not used by format
>   
> ## End(Don't show)
>   ## Not run: 
> ##D   J <- Jfox(X,Y, correction="km", eps=0.25)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Ginhom")
> ### * Ginhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ginhom
> ### Title: Inhomogeneous Nearest Neighbour Function
> ### Aliases: Ginhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   ## Not run: 
> ##D     plot(Ginhom(swedishpines, sigma=bw.diggle, adjust=2))
> ##D   
> ## End(Not run)
>   plot(Ginhom(swedishpines, sigma=10))
> 
> 
> 
> cleanEx()
> nameEx("Gmulti")
> ### * Gmulti
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Gmulti
> ### Title: Marked Nearest Neighbour Distance Function
> ### Aliases: Gmulti
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     trees <- longleaf
>      # Longleaf Pine data: marks represent diameter
>     ## Don't show: 
>       trees <- trees[seq(1, npoints(trees), by=50), ]
>     
> ## End(Don't show)
>     Gm <- Gmulti(trees, marks(trees) <= 15, marks(trees) >= 25)
>     plot(Gm)
> 
> 
> 
> cleanEx()
> nameEx("GmultiInhom")
> ### * GmultiInhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GmultiInhom
> ### Title: Inhomogeneous Marked G-Function
> ### Aliases: GmultiInhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- rescale(amacrine)
>   I <- (marks(X) == "on")
>   J <- (marks(X) == "off")
>   mod <- ppm(X ~ marks * x)
>   lam <- fitted(mod, dataonly=TRUE)
>   lmin <- min(predict(mod)[["off"]]) * 0.9
>   plot(GmultiInhom(X, I, J, lambda=lam, lambdamin=lmin))
>   # equivalent
>   plot(GmultiInhom(X, I, J, lambdaI=lam[I], lambdaJ=lam[J], lambdamin=lmin),
+        main="")
> 
> 
> 
> cleanEx()
> nameEx("Gres")
> ### * Gres
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Gres
> ### Title: Residual G Function
> ### Aliases: Gres
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(cells)
>     fit0 <- ppm(cells, ~1) # uniform Poisson
>     G0 <- Gres(fit0)
>     plot(G0)
> # Hanisch correction estimate
>     plot(G0, hres ~ r)
> # uniform Poisson is clearly not correct
> 
>     fit1 <- ppm(cells, ~1, Strauss(0.08))
>     plot(Gres(fit1), hres ~ r)
> # fit looks approximately OK; try adjusting interaction distance
> 
>     plot(Gres(cells, interaction=Strauss(0.12)))
> 
> # How to make envelopes
>     ## Not run: 
> ##D     E <- envelope(fit1, Gres, model=fit1, nsim=39)
> ##D     plot(E)
> ##D     
> ## End(Not run)
> # For computational efficiency
>     Gc <- Gcom(fit1)
>     G1 <- Gres(Gc)
> 
> 
> 
> cleanEx()
> nameEx("Hardcore")
> ### * Hardcore
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Hardcore
> ### Title: The Hard Core Point Process Model
> ### Aliases: Hardcore
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    Hardcore(0.02)
Pairwise interaction family
Interaction:Hard core process
Hard core distance:	0.02
>    # prints a sensible description of itself
> 
>    ## Not run: 
> ##D    ppm(cells, ~1, Hardcore(0.05))
> ##D    # fit the stationary hard core process to `cells'
> ##D    
> ## End(Not run)
> 
>    # estimate hard core radius from data
>    ppm(cells, ~1, Hardcore())
Stationary Hard core process

First order term:  beta = 282.7782

Hard core distance:	0.08168525

For standard errors, type coef(summary(x))
>    ppm(cells, ~1, Hardcore)
Stationary Hard core process

First order term:  beta = 282.7782

Hard core distance:	0.08168525

For standard errors, type coef(summary(x))
> 
>    ppm(cells, ~ polynom(x,y,3), Hardcore(0.05))
Nonstationary Hard core process

Log trend:  ~x + y + I(x^2) + I(x * y) + I(y^2) + I(x^3) + I(x^2 * y) + I(x * 
y^2) + I(y^3)

Fitted trend coefficients:
(Intercept)           x           y      I(x^2)    I(x * y)      I(y^2) 
  4.6413531  -3.6516352   0.2595011   6.5862445   4.1469949  -2.6755211 
     I(x^3)  I(x^2 * y)  I(x * y^2)      I(y^3) 
 -3.7101975  -0.2365586  -4.4952131   2.9835314 

Hard core distance:	0.05

For standard errors, type coef(summary(x))
>    # fit a nonstationary hard core process
>    # with log-cubic polynomial trend
> 
> 
> 
> cleanEx()
> nameEx("Hest")
> ### * Hest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Hest
> ### Title: Spherical Contact Distribution Function
> ### Aliases: Hest
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    X <- runifpoint(42)
>    H <- Hest(X)
>    Y <- rpoisline(10)
>    H <- Hest(Y)
>    H <- Hest(Y, dimyx=256)
>    X <- heather$coarse
>    plot(Hest(X))
>    H <- Hest(X, conditional=FALSE)
> 
>    P <- owin(poly=list(x=c(5.3, 8.5, 8.3, 3.7, 1.3, 3.7),
+                        y=c(9.7, 10.0, 13.6, 14.4, 10.7, 7.2)))
>    plot(X)
>    plot(P, add=TRUE, col="red")
>    H <- Hest(X, W=P)
>    Z <- as.im(FALSE, Frame(X))
>    Z[X] <- TRUE
>    Z <- Z[P, drop=FALSE]
>    plot(Z)
>    H <- Hest(Z)
> 
> 
> 
> cleanEx()
> nameEx("HierHard")
> ### * HierHard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: HierHard
> ### Title: The Hierarchical Hard Core Point Process Model
> ### Aliases: HierHard
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    h <- matrix(c(4, NA, 10, 15), 2, 2)
>    HierHard(h)
Hierarchical pairwise interaction family
Interaction:Hierarchical hard core process
2 types of points
Possible types:	 not yet determined
Hardcore radii:
     [,1] [,2]
[1,] 4    10  
[2,]      15  
>    # prints a sensible description of itself
>    ppm(ants ~1, HierHard(h))
Stationary Hierarchical hard core process

Possible marks: 'Cataglyphis' and 'Messor'

First order terms:
beta_Cataglyphis      beta_Messor 
    0.0001202088     0.0001202088 

2 types of points
Possible types and ordering:
Cataglyphis ~> Messor
Hardcore radii:
            Cataglyphis Messor
Cataglyphis 4           10    
Messor                  15    

For standard errors, type coef(summary(x))
>    # fit the stationary hierarchical hard core process to ants data
> 
> 
> 
> cleanEx()
> nameEx("HierStrauss")
> ### * HierStrauss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: HierStrauss
> ### Title: The Hierarchical Strauss Point Process Model
> ### Aliases: HierStrauss
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    r <- matrix(10 * c(3,4,4,3), nrow=2,ncol=2)
>    HierStrauss(r)
Hierarchical pairwise interaction family
Interaction:Hierarchical Strauss process
2 types of points
Possible types:	 not yet determined
Interaction radii:
     [,1] [,2]
[1,] 30   40  
[2,] 40   30  
>    # prints a sensible description of itself
>    ppm(ants ~1, HierStrauss(r, , c("Messor", "Cataglyphis")))
Stationary Hierarchical Strauss process

Possible marks: 'Cataglyphis' and 'Messor'

First order terms:
beta_Cataglyphis      beta_Messor 
    0.0001858268     0.0001858268 

2 types of points
Possible types and ordering:
Messor ~> Cataglyphis
Interaction radii:
            Cataglyphis Messor
Cataglyphis 30                
Messor      40          30    
Fitted interaction parameters gamma_ij
            Cataglyphis Messor
Cataglyphis 0.4356            
Messor      0.413       0.2277

Relevant coefficients:
markCataglyphisxCataglyphis      markMessorxCataglyphis 
                 -0.8310837                  -0.8843106 
          markMessorxMessor 
                 -1.4797349 

For standard errors, type coef(summary(x))
>    # fit the stationary hierarchical Strauss process to ants data
> 
> 
> 
> cleanEx()
> nameEx("HierStraussHard")
> ### * HierStraussHard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: HierStraussHard
> ### Title: The Hierarchical Strauss Hard Core Point Process Model
> ### Aliases: HierStraussHard
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    r <- matrix(c(30, NA, 40, 30), nrow=2,ncol=2)
>    h <- matrix(c(4, NA, 10, 15), 2, 2)
>    HierStraussHard(r, h)
Hierarchical pairwise interaction family
Interaction:Hierarchical Strauss-hard core process
2 types of points
Possible types:	 not yet determined
Interaction radii:
     [,1] [,2]
[1,] 30   40  
[2,]      30  
Hardcore radii:
     [,1] [,2]
[1,] 4    10  
[2,]      15  
>    # prints a sensible description of itself
>    ppm(ants ~1, HierStraussHard(r, h))
Stationary Hierarchical Strauss-hard core process

Possible marks: 'Cataglyphis' and 'Messor'

First order terms:
beta_Cataglyphis      beta_Messor 
    0.0001340862     0.0001340862 

2 types of points
Possible types and ordering:
Cataglyphis ~> Messor
Interaction radii:
            Cataglyphis Messor
Cataglyphis 30          40    
Messor                  30    
Hardcore radii:
            Cataglyphis Messor
Cataglyphis 4           10    
Messor                  15    
Fitted interaction parameters gamma_ij
            Cataglyphis Messor   
Cataglyphis 0.320753    1.4557823
Messor                  0.3432812

Relevant coefficients:
markCataglyphisxCataglyphis      markCataglyphisxMessor 
                 -1.1370839                   0.3755434 
          markMessorxMessor 
                 -1.0692054 

For standard errors, type coef(summary(x))
>    # fit the stationary hierarchical Strauss-hard core process to ants data
> 
> 
> 
> cleanEx()
> nameEx("Hybrid")
> ### * Hybrid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Hybrid
> ### Title: Hybrid Interaction Point Process Model
> ### Aliases: Hybrid
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   Hybrid(Strauss(0.1), Geyer(0.2, 3))
Hybrid interaction family
Interaction:Hybrid interaction
Hybrid of 2 components: 'HybridComponent1' and 'HybridComponent2'
HybridComponent1:
Interaction:Strauss process
Interaction distance:	0.1
HybridComponent2:
Interaction:Geyer saturation process
Interaction distance:	0.2
Saturation parameter:	3

> 
>   Hybrid(Ha=Hardcore(0.05), St=Strauss(0.1), Ge=Geyer(0.2, 3))
Hybrid interaction family
Interaction:Hybrid interaction
Hybrid of 3 components: 'Ha', 'St' and 'Ge'
Ha:
Interaction:Hard core process
Hard core distance:	0.05
St:
Interaction:Strauss process
Interaction distance:	0.1
Ge:
Interaction:Geyer saturation process
Interaction distance:	0.2
Saturation parameter:	3

> 
>   fit <- ppm(redwood, ~1, Hybrid(A=Strauss(0.02), B=Geyer(0.1, 2)))
>   fit
Stationary Hybrid interaction

First order term:  beta = 14.64256

Hybrid of 2 components: 'A' and 'B'
A:
Interaction:Strauss process
Interaction distance:	0.02
B:
Interaction:Geyer saturation process
Interaction distance:	0.1
Saturation parameter:	2

Fitted A interaction parameter gamma:	2e-07
Fitted B interaction parameter gamma:	2.5879329

Relevant coefficients:
         A.          B. 
-15.5907711   0.9508595 

For standard errors, type coef(summary(x))
> 
>   ctr <- rmhcontrol(nrep=5e4, expand=1)
>   plot(simulate(fit, control=ctr))
> 
>   # hybrid components can be models (including hybrid models)
>   Hybrid(fit, S=Softcore(0.5))
Hybrid interaction family
Interaction:Hybrid interaction
Hybrid of 3 components: 'A', 'B' and 'S'
A:
Interaction:Strauss process
Interaction distance:	0.02
B:
Interaction:Geyer saturation process
Interaction distance:	0.1
Saturation parameter:	2
S:
Interaction:Soft core process
Exponent kappa:	0.5
Initial approximation to sigma:	NA

> 
>   # plot.fii only works if every component is a pairwise interaction
>   data(swedishpines)
>   fit2 <- ppm(swedishpines, ~1, Hybrid(DG=DiggleGratton(2,10), S=Strauss(5)))
>   plot(fitin(fit2))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in sprintf(legdesc, ylab) : argument not used by format
>   plot(fitin(fit2), separate=TRUE, mar.panel=rep(4,4))
Warning in sprintf(legdesc, ylab) : argument not used by format
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("Iest")
> ### * Iest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Iest
> ### Title: Estimate the I-function
> ### Aliases: Iest
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(amacrine)
>    Ic <- Iest(amacrine)
>    plot(Ic, main="Amacrine Cells data")
>    # values are below I= 0, suggesting negative association
>    # between 'on' and 'off' cells.
> 
> 
> 
> cleanEx()
> nameEx("Jcross")
> ### * Jcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Jcross
> ### Title: Multitype J Function (i-to-j)
> ### Aliases: Jcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>      # Lansing woods data: 6 types of trees
>     woods <- lansing
>     ## Don't show: 
>        woods <- woods[seq(1,npoints(woods), by=30)]
>     
> ## End(Don't show)
>     Jhm <- Jcross(woods, "hickory", "maple")
>     # diagnostic plot for independence between hickories and maples
>     plot(Jhm)
> 
>     # synthetic example with two types "a" and "b"
>     pp <- runifpoint(30) %mark% factor(sample(c("a","b"), 30, replace=TRUE))
>     J <- Jcross(pp)
> 
> 
> 
> cleanEx()
> nameEx("Jdot")
> ### * Jdot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Jdot
> ### Title: Multitype J Function (i-to-any)
> ### Aliases: Jdot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>      # Lansing woods data: 6 types of trees
>    woods <- lansing
> 
>     ## Don't show: 
>         woods <- woods[seq(1,npoints(woods), by=30), ]
>     
> ## End(Don't show)
>     Jh. <- Jdot(woods, "hickory")
>     plot(Jh.)
>     # diagnostic plot for independence between hickories and other trees
>     Jhh <- Jest(split(woods)$hickory)
>     plot(Jhh, add=TRUE, legendpos="bottom")
> 
>     ## Not run: 
> ##D     # synthetic example with two marks "a" and "b"
> ##D     pp <- runifpoint(30) %mark% factor(sample(c("a","b"), 30, replace=TRUE))
> ##D     J <- Jdot(pp, "a")
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Jest")
> ### * Jest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Jest
> ### Title: Estimate the J-function
> ### Aliases: Jest
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(cells)
>    J <- Jest(cells, 0.01)
>    plot(J, main="cells data")
>    # values are far above J = 1, indicating regular pattern
> 
>    data(redwood)
>    J <- Jest(redwood, 0.01, legendpos="center")
>    plot(J, main="redwood data")
>    # values are below J = 1, indicating clustered pattern
> 
> 
> 
> cleanEx()
> nameEx("Jinhom")
> ### * Jinhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Jinhom
> ### Title: Inhomogeneous J-function
> ### Aliases: Jinhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   ## Not run: 
> ##D     plot(Jinhom(swedishpines, sigma=bw.diggle, adjust=2))
> ##D   
> ## End(Not run)
>   plot(Jinhom(swedishpines, sigma=10))
> 
> 
> 
> cleanEx()
> nameEx("Jmulti")
> ### * Jmulti
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Jmulti
> ### Title: Marked J Function
> ### Aliases: Jmulti
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     trees <- longleaf
>      # Longleaf Pine data: marks represent diameter
>     ## Don't show: 
>         trees <- trees[seq(1,npoints(trees), by=50)]
>     
> ## End(Don't show)
>     Jm <- Jmulti(trees, marks(trees) <= 15, marks(trees) >= 25)
>     plot(Jm)
> 
> 
> 
> cleanEx()
> nameEx("K3est")
> ### * K3est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: K3est
> ### Title: K-function of a Three-Dimensional Point Pattern
> ### Aliases: K3est
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- rpoispp3(42)
>   Z <- K3est(X)
>   if(interactive()) plot(Z)
> 
> 
> 
> cleanEx()
> nameEx("Kcom")
> ### * Kcom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kcom
> ### Title: Model Compensator of K Function
> ### Aliases: Kcom
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     fit0 <- ppm(cells, ~1) # uniform Poisson
>     ## Don't show: 
> fit0 <- ppm(cells, ~1, nd=16)
> ## End(Don't show)
> 
>     if(interactive()) {
+       plot(Kcom(fit0))
+ # compare the isotropic-correction estimates
+       plot(Kcom(fit0), cbind(iso, icom) ~ r)
+ # uniform Poisson is clearly not correct
+     }
> 
>     fit1 <- ppm(cells, ~1, Strauss(0.08))
>     ## Don't show: 
> fit1 <- ppm(cells, ~1, Strauss(0.08), nd=16)
> ## End(Don't show)
>     K1 <- Kcom(fit1)
>     K1
Function value object (class 'fv')
for the function r -> K(r)
................................................................................
        Math.label                    
r       r                             
pois    K[pois](r)                    
border  hat(K)[bord](r)               
bcom    bold(C)~hat(K)[bord](r)       
trans   hat(K)[trans](r)              
tcom    bold(C)~hat(K)[trans](r)      
iso     hat(K)[iso](r)                
icom    bold(C)~hat(K)[iso](r)        
ivar    bold(C)^2~hat(K)[iso](r)      
isd     sqrt(bold(C)^2~hat(K)[iso](r))
ihi     bold(R)~hat(K)[hi](r)         
ilo     bold(R)~hat(K)[lo](r)         
ivarsum hat(C)^2~hat(K)[iso](r)       
        Description                                                    
r       distance argument r                                            
pois    expected K(r) for CSR                                          
border  reweighted border-corrected nonparametric estimate of K(r)     
bcom    model compensator of reweighted border-corrected K(r)          
trans   reweighted translation-corrected nonparametric estimate of K(r)
tcom    model compensator of reweighted translation-corrected K(r)     
iso     reweighted isotropic-corrected nonparametric estimate of K(r)  
icom    model compensator of reweighted isotropic-corrected K(r)       
ivar    Poincare variance of isotropic-corrected K(r)                  
isd     sqrt(Poincare variance)  of isotropic-corrected K(r)           
ihi     upper critical band for isotropic-corrected K(r)               
ilo     lower critical band for isotropic-corrected K(r)               
ivarsum data estimate of Poincare variance of K(r)                     
................................................................................
Default plot formula:  .~r
where "." stands for 'icom', 'iso', 'tcom', 'trans', 'bcom', 'border', 'pois'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
>     if(interactive()) {
+       plot(K1)
+       plot(K1, cbind(iso, icom) ~ r)
+       plot(K1, cbind(trans, tcom) ~ r)
+ # how to plot the difference between nonparametric estimates and compensators
+       plot(K1, iso - icom ~ r)
+ # fit looks approximately OK; try adjusting interaction distance
+     }
>     fit2 <- ppm(cells, ~1, Strauss(0.12))
>     ## Don't show: 
> fit2 <- ppm(cells, ~1, Strauss(0.12), nd=16)
> ## End(Don't show)
>     K2 <- Kcom(fit2)
>     if(interactive()) {
+       plot(K2)
+       plot(K2, cbind(iso, icom) ~ r)
+       plot(K2, iso - icom ~ r)
+     }
> 
> 
> 
> cleanEx()
> nameEx("Kcross")
> ### * Kcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kcross
> ### Title: Multitype K Function (Cross-type)
> ### Aliases: Kcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # amacrine cells data
>     K01 <- Kcross(amacrine, "off", "on") 
>     plot(K01)
> 
>     ## Don't show: 
>     K01 <- Kcross(amacrine, "off", "on", ratio=TRUE) 
>     
> ## End(Don't show)
>     ## Not run: 
> ##D     K10 <- Kcross(amacrine, "on", "off")
> ##D 
> ##D     # synthetic example: point pattern with marks 0 and 1
> ##D     pp <- runifpoispp(50)
> ##D     pp <- pp %mark% factor(sample(0:1, npoints(pp), replace=TRUE))
> ##D     K <- Kcross(pp, "0", "1")
> ##D     K <- Kcross(pp, 0, 1) # equivalent
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Kcross.inhom")
> ### * Kcross.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kcross.inhom
> ### Title: Inhomogeneous Cross K Function
> ### Aliases: Kcross.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # Lansing Woods data
>     woods <- lansing
>     ## Don't show: 
> woods <- woods[seq(1,npoints(woods), by=10)]
> ## End(Don't show)
>     ma <- split(woods)$maple
>     wh <- split(woods)$whiteoak
> 
>     # method (1): estimate intensities by nonparametric smoothing
>     lambdaM <- density.ppp(ma, sigma=0.15, at="points")
>     lambdaW <- density.ppp(wh, sigma=0.15, at="points")
>     K <- Kcross.inhom(woods, "whiteoak", "maple", lambdaW, lambdaM)
> 
>     # method (2): leave-one-out
>     K <- Kcross.inhom(woods, "whiteoak", "maple", sigma=0.15)
> 
>     # method (3): fit parametric intensity model
>     fit <- ppm(woods ~marks * polynom(x,y,2))
>     # alternative (a): use fitted model as 'lambda' argument
>     K <- Kcross.inhom(woods, "whiteoak", "maple",
+                       lambdaI=fit, lambdaJ=fit, update=FALSE)
>     K <- Kcross.inhom(woods, "whiteoak", "maple",
+                       lambdaX=fit, update=FALSE)
>     # alternative (b): evaluate fitted intensities at data points
>     # (these are the intensities of the sub-processes of each type)
>     inten <- fitted(fit, dataonly=TRUE)
>     # split according to types of points
>     lambda <- split(inten, marks(woods))
>     K <- Kcross.inhom(woods, "whiteoak", "maple",
+               lambda$whiteoak, lambda$maple)
>     
>     # synthetic example: type A points have intensity 50,
>     #                    type B points have intensity 100 * x
>     lamB <- as.im(function(x,y){50 + 100 * x}, owin())
>     X <- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
>     K <- Kcross.inhom(X, "A", "B",
+         lambdaI=as.im(50, Window(X)), lambdaJ=lamB)
> 
> 
> 
> cleanEx()
> nameEx("Kdot")
> ### * Kdot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kdot
> ### Title: Multitype K Function (i-to-any)
> ### Aliases: Kdot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>      # Lansing woods data: 6 types of trees
>     woods <- lansing
> 
>     ## Don't show: 
> woods <- woods[seq(1, npoints(woods), by=80)]
> ## End(Don't show)
> 
>     Kh. <- Kdot(woods, "hickory") 
>     # diagnostic plot for independence between hickories and other trees
>     plot(Kh.)
> 
>     ## Not run: 
> ##D     # synthetic example with two marks "a" and "b"
> ##D     pp <- runifpoispp(50)
> ##D     pp <- pp %mark% factor(sample(c("a","b"), npoints(pp), replace=TRUE))
> ##D     K <- Kdot(pp, "a")
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Kdot.inhom")
> ### * Kdot.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kdot.inhom
> ### Title: Inhomogeneous Multitype K Dot Function
> ### Aliases: Kdot.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # Lansing Woods data
>     woods <- lansing
>     woods <- woods[seq(1,npoints(woods), by=10)]
>     ma <- split(woods)$maple
>     lg <- unmark(woods)
> 
>     # Estimate intensities by nonparametric smoothing
>     lambdaM <- density.ppp(ma, sigma=0.15, at="points")
>     lambdadot <- density.ppp(lg, sigma=0.15, at="points")
>     K <- Kdot.inhom(woods, "maple", lambdaI=lambdaM,
+                                       lambdadot=lambdadot)
> 
>     # Equivalent
>     K <- Kdot.inhom(woods, "maple", sigma=0.15)
> 
>     # Fit model
>     fit <- ppm(woods ~ marks * polynom(x,y,2))
>     K <- Kdot.inhom(woods, "maple", lambdaX=fit, update=FALSE)
>     
>     # synthetic example: type A points have intensity 50,
>     #                    type B points have intensity 50 + 100 * x
>     lamB <- as.im(function(x,y){50 + 100 * x}, owin())
>     lamdot <- as.im(function(x,y) { 100 + 100 * x}, owin())
>     X <- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
>     K <- Kdot.inhom(X, "B",  lambdaI=lamB,     lambdadot=lamdot)
> 
> 
> 
> cleanEx()
> nameEx("Kest")
> ### * Kest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kest
> ### Title: K-function
> ### Aliases: Kest
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  X <- runifpoint(50)
>  K <- Kest(X)
>  K <- Kest(cells, correction="isotropic")
>  plot(K)
>  plot(K, main="K function for cells")
>  # plot the L function
>  plot(K, sqrt(iso/pi) ~ r)
>  plot(K, sqrt(./pi) ~ r, ylab="L(r)", main="L function for cells")
> 
> 
> 
> cleanEx()
> nameEx("Kest.fft")
> ### * Kest.fft
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kest.fft
> ### Title: K-function using FFT
> ### Aliases: Kest.fft
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  pp <- runifpoint(10000)
>  ## Don't show: 
>   op <- spatstat.options(npixel=125)
>  
> ## End(Don't show)
>  Kpp <- Kest.fft(pp, 0.01)
>  plot(Kpp)
>  ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("Kinhom")
> ### * Kinhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kinhom
> ### Title: Inhomogeneous K-function
> ### Aliases: Kinhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   # inhomogeneous pattern of maples
>   X <- unmark(split(lansing)$maple)
>   ## Don't show: 
>      sub <- sample(c(TRUE,FALSE), npoints(X), replace=TRUE, prob=c(0.1,0.9))
>      X <- X[sub]
>   
> ## End(Don't show)
> 
>   # (1) intensity function estimated by model-fitting
>   # Fit spatial trend: polynomial in x and y coordinates
>   fit <- ppm(X, ~ polynom(x,y,2), Poisson())
>   # (a) predict intensity values at points themselves,
>   #     obtaining a vector of lambda values
>   lambda <- predict(fit, locations=X, type="trend")
>   # inhomogeneous K function
>   Ki <- Kinhom(X, lambda)
>   plot(Ki)
>   # (b) predict intensity at all locations,
>   #     obtaining a pixel image
>   lambda <- predict(fit, type="trend")
>   Ki <- Kinhom(X, lambda)
>   plot(Ki)
> 
>   # (2) intensity function estimated by heavy smoothing
>   Ki <- Kinhom(X, sigma=0.1)
>   plot(Ki)
> 
>   # (3) simulated data: known intensity function
>   lamfun <- function(x,y) { 50 + 100 * x }
>   # inhomogeneous Poisson process
>   Y <- rpoispp(lamfun, 150, owin())
>   # inhomogeneous K function
>   Ki <- Kinhom(Y, lamfun)
>   plot(Ki)
> 
>   # How to make simulation envelopes:
>   #      Example shows method (2)
>   ## Not run: 
> ##D   smo <- density.ppp(X, sigma=0.1)
> ##D   Ken <- envelope(X, Kinhom, nsim=99,
> ##D                   simulate=expression(rpoispp(smo)),
> ##D                   sigma=0.1, correction="trans")
> ##D   plot(Ken)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Kmark")
> ### * Kmark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kmark
> ### Title: Mark-Weighted K Function
> ### Aliases: Kmark markcorrint
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # CONTINUOUS-VALUED MARKS:
>     # (1) Spruces
>     # marks represent tree diameter
>     # mark correlation function
>     ms <- Kmark(spruces)
>     plot(ms)
> 
>     # (2) simulated data with independent marks
>     X <- rpoispp(100)
>     X <- X %mark% runif(npoints(X))
>     Xc <- Kmark(X)
>     plot(Xc)
>     
>     # MULTITYPE DATA:
>     # Hughes' amacrine data
>     # Cells marked as 'on'/'off'
>     M <- Kmark(amacrine, function(m1,m2) {m1==m2},
+                          correction="translate")
>     plot(M)
> 
> 
> 
> cleanEx()
> nameEx("Kmeasure")
> ### * Kmeasure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kmeasure
> ### Title: Reduced Second Moment Measure
> ### Aliases: Kmeasure
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  plot(Kmeasure(cells, 0.05))
>  # shows pronounced dip around origin consistent with strong inhibition
>  plot(Kmeasure(redwood, 0.03), col=grey(seq(1,0,length=32)))
>  # shows peaks at several places, reflecting clustering and ?periodicity
>  M <- Kmeasure(cells, 0.05)
>  # evaluate measure on a sector
>  W <- Window(M)
>  ang <- as.im(atan2, W)
>  rad <- as.im(function(x,y){sqrt(x^2+y^2)}, W)
>  sector <- solutionset(ang > 0 & ang < 1 & rad < 0.6)
>  integral.im(M[sector, drop=FALSE])
[1] 0.1881531
> 
> 
> 
> cleanEx()
> nameEx("Kmodel.dppm")
> ### * Kmodel.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kmodel.dppm
> ### Title: K-function or Pair Correlation Function of a Determinantal Point
> ###   Process Model
> ### Aliases: Kmodel.detpointprocfamily pcfmodel.detpointprocfamily
> ###   Kmodel.dppm pcfmodel.dppm
> 
> ### ** Examples
> 
>   model <- dppMatern(lambda=100, alpha=.01, nu=1, d=2)
>   KMatern <- Kmodel(model)
>   pcfMatern <- pcfmodel(model)
>   plot(KMatern, xlim = c(0,0.05))
>   plot(pcfMatern, xlim = c(0,0.05))
> 
> 
> 
> cleanEx()
> nameEx("Kmodel.kppm")
> ### * Kmodel.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kmodel.kppm
> ### Title: K Function or Pair Correlation Function of Cluster Model or Cox
> ###   model
> ### Aliases: Kmodel.kppm pcfmodel.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   data(redwood)
>   fit <- kppm(redwood, ~x, "MatClust")
>   K <- Kmodel(fit)
>   K(c(0.1, 0.2))
[1] 0.0613610 0.1675177
>   curve(K(x), from=0, to=0.25)
> 
> 
> 
> cleanEx()
> nameEx("Kmodel.ppm")
> ### * Kmodel.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kmodel.ppm
> ### Title: K Function or Pair Correlation Function of Gibbs Point Process
> ###   model
> ### Aliases: Kmodel.ppm pcfmodel.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- ppm(swedishpines, ~1, Strauss(8))
>   p <- pcfmodel(fit)
>   K <- Kmodel(fit)
>   p(6)
[1] 0.4114234
>   K(8)
[1] 89.1035
>   curve(K(x), from=0, to=15)
> 
> 
> 
> cleanEx()
> nameEx("Kmulti")
> ### * Kmulti
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kmulti
> ### Title: Marked K-Function
> ### Aliases: Kmulti
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>      # Longleaf Pine data: marks represent diameter
>     trees <- longleaf
>     ## Don't show: 
>         trees <- trees[seq(1,npoints(trees), by=50), ]
>     
> ## End(Don't show)
>     K <- Kmulti(trees, marks(trees) <= 15, marks(trees) >= 25)
>     plot(K)
>     # functions determining subsets
>     f1 <- function(X) { marks(X) <= 15 }
>     f2 <- function(X) { marks(X) >= 15 }
>     K <- Kmulti(trees, f1, f2)
>    ## Don't show: 
>         rm(trees)
>     
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("Kmulti.inhom")
> ### * Kmulti.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kmulti.inhom
> ### Title: Inhomogeneous Marked K-Function
> ### Aliases: Kmulti.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # Finnish Pines data: marked by diameter and height
>     plot(finpines, which.marks="height")
>     II <- (marks(finpines)$height <= 2)
>     JJ <- (marks(finpines)$height > 3)
>     K <- Kmulti.inhom(finpines, II, JJ)
>     plot(K)
>     # functions determining subsets
>     f1 <- function(X) { marks(X)$height <= 2 }
>     f2 <- function(X) { marks(X)$height > 3 }
>     K <- Kmulti.inhom(finpines, f1, f2)
> 
> 
> 
> cleanEx()
> nameEx("Kres")
> ### * Kres
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kres
> ### Title: Residual K Function
> ### Aliases: Kres
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(cells)
>     fit0 <- ppm(cells, ~1) # uniform Poisson
>     ## Don't show: 
>     fit0 <- ppm(cells, ~1, nd=16)
> ## End(Don't show)
>     K0 <- Kres(fit0)
>     K0
Function value object (class 'fv')
for the function r -> bold(R)~hat(K)(r)
................................................................................
        Math.label                    
r       r                             
theo    bold(R)~K[theo](r)            
bres    bold(R)~hat(K)[bord](r)       
tres    bold(R)~hat(K)[trans](r)      
ires    bold(R)~hat(K)[iso](r)        
ivar    bold(C)^2~hat(K)[iso](r)      
isd     sqrt(bold(C)^2~hat(K)[iso](r))
ihi     bold(R)~hat(K)[Hi](r)         
ilo     bold(R)~hat(K)[Lo](r)         
istdres bold(T)~hat(K)[iso](r)        
        Description                                                           
r       distance argument r                                                   
theo    value 0 corresponding to perfect fit                                  
bres    residual function bold(R)~hat(K)(r) based on border correction        
tres    residual function bold(R)~hat(K)(r) based on translation correction   
ires    residual function bold(R)~hat(K)(r) based on isotropic correction     
ivar    pseudovariance of isotropic-corrected residual bold(R)~hat(K)(r)      
isd     pseudo-SD of isotropic-corrected residual bold(R)~hat(K)(r)           
ihi     upper critical band for isotropic-corrected residual bold(R)~hat(K)(r)
ilo     lower critical band for isotropic-corrected residual bold(R)~hat(K)(r)
istdres standardised isotropic-corrected residual bold(R)~hat(K)(r)           
................................................................................
Default plot formula:  .~r
where "." stands for 'ires', 'tres', 'bres', 'theo', 'ihi', 'ilo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
>     plot(K0)
> # isotropic-correction estimate
>     plot(K0, ires ~ r)
> # uniform Poisson is clearly not correct
> 
>     fit1 <- ppm(cells, ~1, Strauss(0.08))
>     ## Don't show: 
> fit1 <- ppm(cells, ~1, Strauss(0.08), nd=16)
> ## End(Don't show)
>     K1 <- Kres(fit1)
> 
>     if(interactive()) {
+       plot(K1, ires ~ r)
+    # fit looks approximately OK; try adjusting interaction distance
+       plot(Kres(cells, interaction=Strauss(0.12)))
+     }
> 
> # How to make envelopes
>     ## Not run: 
> ##D     E <- envelope(fit1, Kres, model=fit1, nsim=19)
> ##D     plot(E)
> ##D     
> ## End(Not run)
> 
> # For computational efficiency
>     Kc <- Kcom(fit1)
>     K1 <- Kres(Kc)
> 
> 
> 
> cleanEx()
> nameEx("Kscaled")
> ### * Kscaled
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Kscaled
> ### Title: Locally Scaled K-function
> ### Aliases: Kscaled Lscaled
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(bronzefilter)
>   X <- unmark(bronzefilter)
>   K <- Kscaled(X)
>   fit <- ppm(X, ~x)
>   lam <- predict(fit)
>   K <- Kscaled(X, lam)
> 
> 
> 
> cleanEx()
> nameEx("Ksector")
> ### * Ksector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ksector
> ### Title: Sector K-function
> ### Aliases: Ksector
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  K <- Ksector(swedishpines, 0, 90)
>  plot(K)
> 
> 
> 
> cleanEx()
> nameEx("LambertW")
> ### * LambertW
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LambertW
> ### Title: Lambert's W Function
> ### Aliases: LambertW
> ### Keywords: math
> 
> ### ** Examples
> 
>    LambertW(exp(1))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("Lcross")
> ### * Lcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Lcross
> ### Title: Multitype L-function (cross-type)
> ### Aliases: Lcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  data(amacrine)
>  L <- Lcross(amacrine, "off", "on")
>  plot(L)
> 
> 
> 
> cleanEx()
> nameEx("Lcross.inhom")
> ### * Lcross.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Lcross.inhom
> ### Title: Inhomogeneous Cross Type L Function
> ### Aliases: Lcross.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # Lansing Woods data
>     woods <- lansing
>     ## Don't show: 
> woods <- woods[seq(1,npoints(woods), by=10)]
> ## End(Don't show)
>     ma <- split(woods)$maple
>     wh <- split(woods)$whiteoak
> 
>     # method (1): estimate intensities by nonparametric smoothing
>     lambdaM <- density.ppp(ma, sigma=0.15, at="points")
>     lambdaW <- density.ppp(wh, sigma=0.15, at="points")
>     L <- Lcross.inhom(woods, "whiteoak", "maple", lambdaW, lambdaM)
> 
>     # method (2): fit parametric intensity model
>     fit <- ppm(woods ~marks * polynom(x,y,2))
>     # evaluate fitted intensities at data points
>     # (these are the intensities of the sub-processes of each type)
>     inten <- fitted(fit, dataonly=TRUE)
>     # split according to types of points
>     lambda <- split(inten, marks(woods))
>     L <- Lcross.inhom(woods, "whiteoak", "maple",
+               lambda$whiteoak, lambda$maple)
>     
>     # synthetic example: type A points have intensity 50,
>     #                    type B points have intensity 100 * x
>     lamB <- as.im(function(x,y){50 + 100 * x}, owin())
>     X <- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
>     L <- Lcross.inhom(X, "A", "B",
+         lambdaI=as.im(50, Window(X)), lambdaJ=lamB)
> 
> 
> 
> cleanEx()
> nameEx("Ldot")
> ### * Ldot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ldot
> ### Title: Multitype L-function (i-to-any)
> ### Aliases: Ldot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  data(amacrine)
>  L <- Ldot(amacrine, "off")
>  plot(L)
> 
> 
> 
> cleanEx()
> nameEx("Ldot.inhom")
> ### * Ldot.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ldot.inhom
> ### Title: Inhomogeneous Multitype L Dot Function
> ### Aliases: Ldot.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # Lansing Woods data
>     lan <- lansing
>     lan <- lan[seq(1,npoints(lan), by=10)]
>     ma <- split(lan)$maple
>     lg <- unmark(lan)
> 
>     # Estimate intensities by nonparametric smoothing
>     lambdaM <- density.ppp(ma, sigma=0.15, at="points")
>     lambdadot <- density.ppp(lg, sigma=0.15, at="points")
>     L <- Ldot.inhom(lan, "maple", lambdaI=lambdaM,
+                                   lambdadot=lambdadot)
> 
> 
>     # synthetic example: type A points have intensity 50,
>     #                    type B points have intensity 50 + 100 * x
>     lamB <- as.im(function(x,y){50 + 100 * x}, owin())
>     lamdot <- as.im(function(x,y) { 100 + 100 * x}, owin())
>     X <- superimpose(A=runifpoispp(50), B=rpoispp(lamB))
>     L <- Ldot.inhom(X, "B",  lambdaI=lamB,     lambdadot=lamdot)
> 
> 
> 
> cleanEx()
> nameEx("LennardJones")
> ### * LennardJones
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LennardJones
> ### Title: The Lennard-Jones Potential
> ### Aliases: LennardJones
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    badfit <- ppm(cells ~1, LennardJones(), rbord=0.1)
>    badfit
Stationary Lennard-Jones process

First order term:  beta = 4148.798

Initial approximation to sigma:	0.08363014
Fitted interaction parameters
       sigma      epsilon 
 2.15321e-02 -3.92379e+03 

Relevant coefficients:
  Interact.1   Interact.2 
-0.001331796 -4.571951946 

For standard errors, type coef(summary(x))

*** Model is not valid ***
*** Interaction parameters are outside valid range ***
> 
>    fit <- ppm(unmark(longleaf) ~1, LennardJones(), rbord=1)
>    fit
Stationary Lennard-Jones process

First order term:  beta = 0.01425025

Initial approximation to sigma:	0.2
Fitted interaction parameters
   sigma  epsilon 
0.179876 2.372750 

Relevant coefficients:
Interact.1 Interact.2 
  2.658415   5.023048 

For standard errors, type coef(summary(x))
>    plot(fitin(fit))
Warning in sprintf(legdesc, ylab) : argument not used by format
>    # Note the Longleaf Pines coordinates are rounded to the nearest decimetre
>    # (multiple of 0.1 metres) so the apparent inhibition may be an artefact
> 
> 
> 
> cleanEx()
> nameEx("Lest")
> ### * Lest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Lest
> ### Title: L-function
> ### Aliases: Lest
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  data(cells)
>  L <- Lest(cells)
>  plot(L, main="L function for cells")
> 
> 
> 
> cleanEx()
> nameEx("Linhom")
> ### * Linhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Linhom
> ### Title: Inhomogeneous L-function
> ### Aliases: Linhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  data(japanesepines)
>  X <- japanesepines
>  L <- Linhom(X, sigma=0.1)
>  plot(L, main="Inhomogeneous L function for Japanese Pines")
> 
> 
> 
> cleanEx()
> nameEx("Math.im")
> ### * Math.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Math.im
> ### Title: S3 Group Generic methods for images
> ### Aliases: Math.im Ops.im Complex.im Summary.im
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   ## Convert gradient values to angle of inclination:
>   V <- atan(bei.extra$grad) * 180/pi
>   ## Make logical image which is TRUE when heat equals 'Moderate': 
>   A <- (gorillas.extra$heat == "Moderate")
>   ## Summary:
>   any(A)
[1] TRUE
>   ## Complex:
>   Z <- exp(1 + V * 1i)
>   Z
complex-valued pixel image
101 x 201 pixel array (ny, nx)
enclosing rectangle: [-2.5, 1002.5] x [-2.5, 502.5] metres
>   Re(Z)
real-valued pixel image
101 x 201 pixel array (ny, nx)
enclosing rectangle: [-2.5, 1002.5] x [-2.5, 502.5] metres
> 
> 
> 
> cleanEx()
> nameEx("Math.imlist")
> ### * Math.imlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Math.imlist
> ### Title: S3 Group Generic methods for List of Images
> ### Aliases: Math.imlist Ops.imlist Complex.imlist Summary.imlist
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   a <- Smooth(finpines, 2)
>   log(a)/2 - sqrt(a)
List of pixel images

diameter:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [-5, 5] x [-8, 2] metres

height:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [-5, 5] x [-8, 2] metres
>   range(a)
[1] 2.173616 3.873350
> 
> 
> 
> cleanEx()
> nameEx("Math.linim")
> ### * Math.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Math.linim
> ### Title: S3 Group Generic Methods for Images on a Linear Network
> ### Aliases: Math.linim Ops.linim Summary.linim Complex.linim
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   fx <- function(x,y,seg,tp) { (x - y)^2 }
>   fL <- linfun(fx, simplenet)
>   Z <- as.linim(fL)
>   A <- Z+2
>   A <- -Z
>   A <- sqrt(Z)
>   A <- !(Z > 0.1)
> 
> 
> 
> cleanEx()
> nameEx("MinkowskiSum")
> ### * MinkowskiSum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MinkowskiSum
> ### Title: Minkowski Sum of Windows
> ### Aliases: MinkowskiSum %(+)% dilationAny
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   B <- square(0.2)
>   RplusB <- letterR %(+)% B
> 
>   opa <- par(mfrow=c(1,2))
>   FR <- grow.rectangle(Frame(letterR), 0.3)
>   plot(FR, main="")
>   plot(letterR, add=TRUE, lwd=2, hatch=TRUE, hatchargs=list(texture=5))
>   plot(shift(B, vec=c(3.675, 3)),
+        add=TRUE, border="red", lwd=2)
>   plot(FR, main="")
>   plot(letterR, add=TRUE, lwd=2, hatch=TRUE, hatchargs=list(texture=5))
>   plot(RplusB, add=TRUE, border="blue", lwd=2,
+          hatch=TRUE, hatchargs=list(col="blue"))
>   par(opa)
> 
>   plot(cells %(+)% square(0.1))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("MultiHard")
> ### * MultiHard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MultiHard
> ### Title: The Multitype Hard Core Point Process Model
> ### Aliases: MultiHard
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    h <- matrix(c(1,2,2,1), nrow=2,ncol=2)
> 
>    # prints a sensible description of itself
>    MultiHard(h)
Pairwise interaction family
Interaction:Multitype Hardcore process
2 types of points
Possible types:	 not yet determined
Hardcore radii:
     [,1] [,2]
[1,]    1    2
[2,]    2    1
> 
>    # Fit the stationary multitype hardcore process to `amacrine'
>    # with hard core operating only between cells of the same type.
>    h <- 0.02 * matrix(c(1, NA, NA, 1), nrow=2,ncol=2)
>    ppm(amacrine ~1, MultiHard(h))
Stationary Multitype Hardcore process

Possible marks: 'off' and 'on'

First order terms:
beta_off  beta_on 
99.62802 99.62802 

2 types of points
Possible types:
[1] off on 
Hardcore radii:
     off   on
off 0.02   NA
on    NA 0.02

For standard errors, type coef(summary(x))
> 
> 
> 
> cleanEx()
> nameEx("MultiStrauss")
> ### * MultiStrauss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MultiStrauss
> ### Title: The Multitype Strauss Point Process Model
> ### Aliases: MultiStrauss
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    r <- matrix(c(1,2,2,1), nrow=2,ncol=2)
>    MultiStrauss(r)
Pairwise interaction family
Interaction:Multitype Strauss process
2 types of points
Possible types:	 not yet determined
Interaction radii:
     [,1] [,2]
[1,]    1    2
[2,]    2    1
>    # prints a sensible description of itself
>    r <- 0.03 * matrix(c(1,2,2,1), nrow=2,ncol=2)
>    X <- amacrine
>    ## Don't show: 
>       X <- X[ owin(c(0, 0.8), c(0, 1)) ]
>    
> ## End(Don't show)
>    ppm(X ~1, MultiStrauss(r))
Stationary Multitype Strauss process

Possible marks: 'off' and 'on'

First order terms:
beta_off  beta_on 
108.3777 108.3777 

2 types of points
Possible types:
[1] off on 
Interaction radii:
     off   on
off 0.03 0.06
on  0.06 0.03
Fitted interaction parameters gamma_ij
         off        on
off 0.139504 1.0280191
on  1.028019 0.0000001

Relevant coefficients:
 markoffxoff   markoffxon    markonxon 
 -1.96966221   0.02763376 -16.77579178 

For standard errors, type coef(summary(x))

*** Model is not valid ***
*** Interaction parameters are outside valid range ***
>    # fit the stationary multitype Strauss process to `amacrine'
> 
>    ## Not run: 
> ##D    ppm(X ~polynom(x,y,3), MultiStrauss(r, c("off","on")))
> ##D    # fit a nonstationary multitype Strauss process with log-cubic trend
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("MultiStraussHard")
> ### * MultiStraussHard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MultiStraussHard
> ### Title: The Multitype/Hard Core Strauss Point Process Model
> ### Aliases: MultiStraussHard
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    r <- matrix(3, nrow=2,ncol=2)
>    h <- matrix(c(1,2,2,1), nrow=2,ncol=2)
>    MultiStraussHard(r,h)
Pairwise interaction family
Interaction:Multitype Strauss Hardcore process
2 types of points
Possible types:	 not yet determined
Interaction radii:
     [,1] [,2]
[1,]    3    3
[2,]    3    3
Hardcore radii:
     [,1] [,2]
[1,]    1    2
[2,]    2    1
>    # prints a sensible description of itself
>    r <- 0.04 * matrix(c(1,2,2,1), nrow=2,ncol=2)
>    h <- 0.02 * matrix(c(1,NA,NA,1), nrow=2,ncol=2)
>    X <- amacrine
>    ## Don't show: 
>        X <- X[owin(c(0,0.8), c(0,1))]
>    
> ## End(Don't show)
>    fit <- ppm(X ~1, MultiStraussHard(r,h))
>    # fit stationary multitype hardcore Strauss process to `amacrine'
> 
> 
> 
> cleanEx()
> nameEx("Ops.msr")
> ### * Ops.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ops.msr
> ### Title: Arithmetic Operations on Measures
> ### Aliases: Ops.msr
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    rp <- residuals(fit, type="pearson")
>    rp
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 10.577   continuous = -10.463   total = 0.11362
> 
>    -rp
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = -10.577   continuous = 10.463   total = -0.11362
>    2 * rp
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 21.154   continuous = -20.927   total = 0.22724
>    rp /2
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 5.2885   continuous = -5.2317   total = 0.05681
> 
>    rp - rp
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 0   continuous = 0   total = 0
> 
>    rr <- residuals(fit, type="raw")
>    rp - rr
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = -118.42   continuous = 118.54   total = 0.11362
> 
> 
> 
> cleanEx()
> nameEx("PPversion")
> ### * PPversion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPversion
> ### Title: Transform a Function into its P-P or Q-Q Version
> ### Aliases: PPversion QQversion
> ### Keywords: spatial nonparametric manip
> 
> ### ** Examples
> 
>   opa <- par(mar=0.1+c(5,5,4,2))
>   G <- Gest(redwoodfull)
>   plot(PPversion(G))
>   plot(QQversion(G))
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("PairPiece")
> ### * PairPiece
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PairPiece
> ### Title: The Piecewise Constant Pairwise Interaction Point Process Model
> ### Aliases: PairPiece
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    PairPiece(c(0.1,0.2))
Pairwise interaction family
Interaction:Piecewise constant pairwise interaction process
Interaction thresholds:	c(0.1, 0.2)
>    # prints a sensible description of itself
>    data(cells) 
> 
>    ## Not run: 
> ##D    ppm(cells, ~1, PairPiece(r = c(0.05, 0.1, 0.2)))
> ##D    # fit a stationary piecewise constant pairwise interaction process
> ##D    
> ## End(Not run)
> 
>    ppm(cells, ~polynom(x,y,3), PairPiece(c(0.05, 0.1)))
Nonstationary Piecewise constant pairwise interaction process

Log trend:  ~x + y + I(x^2) + I(x * y) + I(y^2) + I(x^3) + I(x^2 * y) + I(x * 
y^2) + I(y^3)

Fitted trend coefficients:
(Intercept)           x           y      I(x^2)    I(x * y)      I(y^2) 
   9.664167   -5.555809   -9.932433   -1.385443   12.784450   18.847027 
     I(x^3)  I(x^2 * y)  I(x * y^2)      I(y^3) 
   6.537432   -8.863096   -2.577533  -14.372586 

Interaction thresholds:	c(0.05, 0.1)
Fitted interaction parameters gamma_i
  [0,0.05) [0.05,0.1) 
 0.0000000  0.0081635 

Relevant coefficients:
Interact.1 Interact.2 
-21.940903  -4.808081 

For standard errors, type coef(summary(x))
>    # nonstationary process with log-cubic polynomial trend
> 
> 
> 
> cleanEx()
> nameEx("Pairwise")
> ### * Pairwise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Pairwise
> ### Title: Generic Pairwise Interaction model
> ### Aliases: Pairwise
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    #This is the same as StraussHard(r=0.7,h=0.05)
>    strpot <- function(d,par) {
+          r <- par$r
+          h <- par$h
+          value <- (d <= r)
+          value[d < h] <- -Inf
+          value
+    }
>    mySH <- Pairwise(strpot, "StraussHard process", list(r=0.7,h=0.05),
+            c("interaction distance r", "hard core distance h"))
>    data(cells)
>    ppm(cells, ~ 1, mySH, correction="isotropic")
Stationary StraussHard process

First order term:  beta = 257.166

Potential function:
function (d, par) 
{
    r <- par$r
    h <- par$h
    value <- (d <= r)
    value[d < h] <- -Inf
    value
}
interaction distance r :	0.7 
hard core distance h :	0.05 
Fitted interaction terms:	 0.978448595029958

Relevant coefficients:
Interaction 
-0.02178703 

For standard errors, type coef(summary(x))

[Validity of model could not be checked]
> 
>    # Fiksel (1984) double exponential interaction
>    # see Stoyan, Kendall, Mecke 1987 p 161
> 
>    fikspot <- function(d, par) {
+       r <- par$r
+       h <- par$h
+       zeta <- par$zeta
+       value <- exp(-zeta * d)
+       value[d < h] <- -Inf
+       value[d > r] <- 0
+       value
+    }
>    Fiksel <- Pairwise(fikspot, "Fiksel double exponential process",
+                       list(r=3.5, h=1, zeta=1),
+                       c("interaction distance r",
+                         "hard core distance h",
+                         "exponential coefficient zeta"))
>    data(spruces)
>    fit <- ppm(unmark(spruces), ~1, Fiksel, rbord=3.5)
>    fit
Stationary Fiksel double exponential process

First order term:  beta = 0.3223968

Potential function:
function (d, par) 
{
    r <- par$r
    h <- par$h
    zeta <- par$zeta
    value <- exp(-zeta * d)
    value[d < h] <- -Inf
    value[d > r] <- 0
    value
}
interaction distance r :	3.5 
hard core distance h :	1 
exponential coefficient zeta :	1 
Fitted interaction terms:	 0.000424736454665402

Relevant coefficients:
Interaction 
  -7.764042 

For standard errors, type coef(summary(x))

[Validity of model could not be checked]
>    plot(fitin(fit), xlim=c(0,4))
Warning in sprintf(legdesc, ylab) : argument not used by format
>    coef(fit)
(Intercept) Interaction 
  -1.131972   -7.764042 
>    # corresponding values obtained by Fiksel (1984) were -1.9 and -6.0
> 
> 
> 
> cleanEx()
> nameEx("Penttinen")
> ### * Penttinen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Penttinen
> ### Title: Penttinen Interaction
> ### Aliases: Penttinen
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit <- ppm(cells ~ 1, Penttinen(0.07))
>    fit
Stationary Penttinen process

First order term:  beta = 2772.658

Circle radius:	0.07
Fitted interaction parameter gamma:	 1.47e-05

Relevant coefficients:
Interaction 
  -11.12685 

For standard errors, type coef(summary(x))
>    reach(fit) # interaction range is circle DIAMETER
[1] 0.14
> 
> 
> 
> cleanEx()
> nameEx("Poisson")
> ### * Poisson
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Poisson
> ### Title: Poisson Point Process Model
> ### Aliases: Poisson
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>  ppm(nztrees ~1, Poisson())
Stationary Poisson process
Intensity: 0.005916753
             Estimate      S.E.   CI95.lo   CI95.hi Ztest      Zval
log(lambda) -5.129968 0.1078328 -5.341316 -4.918619   *** -47.57336
>  # fit the stationary Poisson process to 'nztrees'
>  # no edge correction needed
> 
>  lon <- longleaf
>  ## Don't show: 
>    lon <- lon[seq(1, npoints(lon), by=50)]
>  
> ## End(Don't show)
>  longadult <- unmark(subset(lon, marks >= 30))
>  ppm(longadult ~ x, Poisson())
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-8.052540160 -0.003695126 

                Estimate       S.E.     CI95.lo      CI95.hi Ztest        Zval
(Intercept) -8.052540160 0.61260076 -9.25321559 -6.851864729   *** -13.1448419
x           -0.003695126 0.00585391 -0.01516858  0.007778328        -0.6312235
>  # fit the nonstationary Poisson process 
>  # with intensity lambda(x,y) = exp( a + bx)
> 
>  # trees marked by species
>  lans <- lansing
>  ## Don't show: 
>      lans <- lans[seq(1, npoints(lans), by=30)]
>  
> ## End(Don't show)
>  ppm(lans ~ marks, Poisson())
Stationary multitype Poisson process

Possible marks: 'blackoak', 'hickory', 'maple', 'misc', 'redoak' and 'whiteoak'

Log intensity:  ~marks

Intensities:
beta_blackoak  beta_hickory    beta_maple     beta_misc   beta_redoak 
            5            23            18             3            12 
beta_whiteoak 
           15 

                Estimate      S.E.     CI95.lo   CI95.hi Ztest       Zval
(Intercept)    1.6094379 0.4472136  0.73291537 2.4859605   ***  3.5988126
markshickory   1.5260563 0.4934352  0.55894115 2.4931715    **  3.0927190
marksmaple     1.2809338 0.5055250  0.29012299 2.2717447     *  2.5338683
marksmisc     -0.5108256 0.7302967 -1.94218092 0.9205297       -0.6994768
marksredoak    0.8754687 0.5322906 -0.16780176 1.9187392        1.6447194
markswhiteoak  1.0986123 0.5163978  0.08649124 2.1107333     *  2.1274535
>  # fit stationary marked Poisson process
>  # with different intensity for each species
> 
> ## Not run: 
> ##D  ppm(lansing ~ marks * polynom(x,y,3), Poisson())
> ## End(Not run)
>  # fit nonstationary marked Poisson process
>  # with different log-cubic trend for each species
> ## Don't show: 
>    # equivalent functionality - smaller dataset
>    ppm(amacrine ~ marks * polynom(x,y,2), Poisson())
Nonstationary multitype Poisson process

Possible marks: 'off' and 'on'

Log intensity:  ~marks * (x + y + I(x^2) + I(x * y) + I(y^2))

Fitted trend coefficients:
     (Intercept)          markson                x                y 
      4.35862320       0.43233261       0.41593354      -0.01222004 
          I(x^2)         I(x * y)           I(y^2)        markson:x 
     -0.23679813       0.10092463      -0.12164102      -0.76352123 
       markson:y   markson:I(x^2) markson:I(x * y)   markson:I(y^2) 
     -0.79307899       0.39926862       0.18035163       0.68937176 

                    Estimate      S.E.    CI95.lo   CI95.hi Ztest         Zval
(Intercept)       4.35862320 0.4372199  3.5016879 5.2155585   ***  9.968949300
markson           0.43233261 0.5902626 -0.7245609 1.5892261        0.732441118
x                 0.41593354 0.8074404 -1.1666206 1.9984877        0.515125981
y                -0.01222004 1.2731005 -2.5074512 2.4830111       -0.009598646
I(x^2)           -0.23679813 0.4465914 -1.1121012 0.6385049       -0.530234416
I(x * y)          0.10092463 0.6451864 -1.1636175 1.3654667        0.156427091
I(y^2)           -0.12164102 1.1307085 -2.3377889 2.0945068       -0.107579477
markson:x        -0.76352123 1.1022043 -2.9238019 1.3967595       -0.692722067
markson:y        -0.79307899 1.7460775 -4.2153280 2.6291700       -0.454206064
markson:I(x^2)    0.39926862 0.6139038 -0.8039606 1.6024979        0.650376573
markson:I(x * y)  0.18035163 0.8738902 -1.5324418 1.8931450        0.206377894
markson:I(y^2)    0.68937176 1.5608985 -2.3699330 3.7486765        0.441650615
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("Replace.im")
> ### * Replace.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Replace.im
> ### Title: Reset Values in Subset of Image
> ### Aliases: [<-.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  # make up an image
>  X <- setcov(unit.square())
>  plot(X)
> 
>  # a rectangular subset
>  W <- owin(c(0,0.5),c(0.2,0.8))
>  X[W] <- 2
>  plot(X)
> 
>  # a polygonal subset
>  data(letterR)
>  R <- affine(letterR, diag(c(1,1)/2), c(-2,-0.7))
>  X[R] <- 3
>  plot(X)
> 
>  # a point pattern
>  P <- rpoispp(20)
>  X[P] <- 10
>  plot(X)
> 
>  # change pixel value at a specific location
>  X[list(x=0.1,y=0.2)] <- 7
> 
>  # matrix indexing --- single vector index
>  X[1:2570] <- 10
>  plot(X)
> 
>  # matrix indexing using double indices
>  X[1:257,1:10] <- 5
>  plot(X)
> 
>  # matrix indexing using a matrix of indices
>  X[cbind(1:257,1:257)] <- 10
>  X[cbind(257:1,1:257)] <- 10
>  plot(X)
> 
>  # Blank indices
>  Y <- as.im(letterR)
>  plot(Y)
>  Y[] <- 42  # replace values only inside the window 'R'
>  plot(Y)
>  Y[drop=FALSE] <- 7 # replace all values in the rectangle
>  plot(Y)
> 
>  Z <- as.im(letterR)
>  Z[] <- raster.x(Z, drop=TRUE) # excludes NA
>  plot(Z)
>  Z[drop=FALSE] <- raster.y(Z, drop=FALSE) # includes NA
>  plot(Z)
> 
> 
> 
> cleanEx()
> nameEx("Replace.linim")
> ### * Replace.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Replace.linim
> ### Title: Reset Values in Subset of Image on Linear Network
> ### Aliases: [<-.linim
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # make a function
>   Y <- as.linim(distfun(runiflpp(5, simplenet)))
>   # replace some values
>   B <- square(c(0.25, 0.55))
>   Y[B] <- 2
>   plot(Y, main="")
>   plot(B, add=TRUE, lty=3)
>   X <- runiflpp(4, simplenet)
>   Y[X] <- 5
> 
> 
> 
> cleanEx()
> nameEx("SatPiece")
> ### * SatPiece
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SatPiece
> ### Title: Piecewise Constant Saturated Pairwise Interaction Point Process
> ###   Model
> ### Aliases: SatPiece
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    SatPiece(c(0.1,0.2), c(1,1))
Saturated pairwise interaction family
Interaction:piecewise constant Saturated pairwise interaction process
Interaction thresholds:	c(0.1, 0.2)
Saturation parameters:	c(1, 1)
>    # prints a sensible description of itself
>    SatPiece(c(0.1,0.2), 1)
Saturated pairwise interaction family
Interaction:piecewise constant Saturated pairwise interaction process
Interaction thresholds:	c(0.1, 0.2)
Saturation parameters:	1
>    data(cells) 
>    ppm(cells, ~1, SatPiece(c(0.07, 0.1, 0.13), 2))
Stationary piecewise constant Saturated pairwise interaction process

First order term:  beta = 2574.033

Interaction thresholds:	c(0.07, 0.1, 0.13)
Saturation parameters:	2
Fitted interaction parameters gamma_i
  [0,0.07) [0.07,0.1) [0.1,0.13) 
 0.0000223  0.2465355  0.6438497 

Relevant coefficients:
Interact.1 Interact.2 Interact.3 
-10.711217  -1.400249  -0.440290 

For standard errors, type coef(summary(x))
>    # fit a stationary piecewise constant Saturated pairwise interaction process
> 
>    ## Not run: 
> ##D    ppm(cells, ~polynom(x,y,3), SatPiece(c(0.07, 0.1, 0.13), 2))
> ##D    # nonstationary process with log-cubic polynomial trend
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Smooth.fv")
> ### * Smooth.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Smooth.fv
> ### Title: Apply Smoothing to Function Values
> ### Aliases: Smooth.fv
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(cells)
>    G <- Gest(cells)
>    plot(G)
>    plot(Smooth(G, df=9), add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("Smooth.msr")
> ### * Smooth.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Smooth.msr
> ### Title: Smooth a Signed or Vector-Valued Measure
> ### Aliases: Smooth.msr
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    rp <- residuals(fit, type="pearson")
>    rs <- residuals(fit, type="score")
> 
>    plot(Smooth(rp))
>    plot(Smooth(rs))
> 
> 
> 
> cleanEx()
> nameEx("Smooth.ppp")
> ### * Smooth.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Smooth.ppp
> ### Title: Spatial smoothing of observations at irregular points
> ### Aliases: Smooth.ppp markmean markvar
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    # Longleaf data - tree locations, marked by tree diameter
>    # Local smoothing of tree diameter (automatic bandwidth selection)
>    Z <- Smooth(longleaf)
>    # Kernel bandwidth sigma=5
>    plot(Smooth(longleaf, 5))
>    # mark variance
>    plot(markvar(longleaf, sigma=5))
>    # data frame of marks: trees marked by diameter and height
>    plot(Smooth(finpines, sigma=2))
>    head(Smooth(finpines, sigma=2, at="points"))
  diameter   height
1 2.524097 2.665821
2 2.308315 2.537044
3 3.495364 3.339404
4 2.917015 2.961783
5 3.021642 2.992051
6 2.827055 2.823017
> 
> 
> 
> cleanEx()
> nameEx("Smooth.ssf")
> ### * Smooth.ssf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Smooth.ssf
> ### Title: Smooth a Spatially Sampled Function
> ### Aliases: Smooth.ssf
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    f <- ssf(redwood, nndist(redwood))
>    Smooth(f, sigma=0.1)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [-1, 0] units
> 
> 
> 
> cleanEx()
> nameEx("Smoothfun.ppp")
> ### * Smoothfun.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Smoothfun.ppp
> ### Title: Smooth Interpolation of Marks as a Spatial Function
> ### Aliases: Smoothfun Smoothfun.ppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   f <- Smoothfun(longleaf)
>   f
function(x,y) which returns values interpolated from
Marked planar point pattern: 584 points
marks are numeric, of storage type  'double'
window: rectangle = [0, 200] x [0, 200] metres
>   f(120, 80)
[1] 38.99538
attr(,"sigma")
[1] 5.198041
>   plot(f)
> 
> 
> 
> cleanEx()
> nameEx("Softcore")
> ### * Softcore
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Softcore
> ### Title: The Soft Core Point Process Model
> ### Aliases: Softcore
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    # fit the stationary Soft Core process to `cells' 
>    fit5 <- ppm(cells ~1, Softcore(kappa=0.5), correction="isotropic")
> 
>    # study shape of interaction and explore effect of parameters
>    fit2 <- update(fit5, Softcore(kappa=0.2))
>    fit8 <- update(fit5, Softcore(kappa=0.8))
>    plot(fitin(fit2), xlim=c(0, 0.4),
+         main="Pair potential (sigma = 0.1)", 
+         xlab=expression(d), ylab=expression(h(d)), legend=FALSE)
Warning in sprintf(legdesc, ylab) : argument not used by format
>    plot(fitin(fit5), add=TRUE, col=4)
Warning in sprintf(legdesc, ylab) : argument not used by format
>    plot(fitin(fit8), add=TRUE, col=3)
Warning in sprintf(legdesc, ylab) : argument not used by format
>    legend("bottomright", col=c(1,4,3), lty=1,
+           legend=expression(kappa==0.2, kappa==0.5, kappa==0.8))
> 
> 
> 
> cleanEx()
> nameEx("Strauss")
> ### * Strauss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Strauss
> ### Title: The Strauss Point Process Model
> ### Aliases: Strauss
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    Strauss(r=0.1)
Pairwise interaction family
Interaction:Strauss process
Interaction distance:	0.1
>    # prints a sensible description of itself
>    data(cells)
> 
>    ## Not run: 
> ##D    ppm(cells, ~1, Strauss(r=0.07))
> ##D    # fit the stationary Strauss process to `cells'
> ##D    
> ## End(Not run)
> 
> 
>    ppm(cells, ~polynom(x,y,3), Strauss(r=0.07))
Nonstationary Strauss process

Log trend:  ~x + y + I(x^2) + I(x * y) + I(y^2) + I(x^3) + I(x^2 * y) + I(x * 
y^2) + I(y^3)

Fitted trend coefficients:
(Intercept)           x           y      I(x^2)    I(x * y)      I(y^2) 
  3.5542656  10.0744930  -2.5665867 -21.5637088  10.7003601   0.3194518 
     I(x^3)  I(x^2 * y)  I(x * y^2)      I(y^3) 
 11.2068783   4.9464404 -16.3830444   3.6298402 

Interaction distance:	0.07
Fitted interaction parameter gamma:	 0

Relevant coefficients:
Interaction 
    -19.394 

For standard errors, type coef(summary(x))
>    # fit a nonstationary Strauss process with log-cubic polynomial trend
> 
> 
> 
> cleanEx()
> nameEx("StraussHard")
> ### * StraussHard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: StraussHard
> ### Title: The Strauss / Hard Core Point Process Model
> ### Aliases: StraussHard
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    StraussHard(r=1,hc=0.02)
Pairwise interaction family
Interaction:Strauss - hard core process
Interaction distance:	1
Hard core distance:	0.02
>    # prints a sensible description of itself
> 
>    data(cells)
> 
>    ## Not run: 
> ##D    ppm(cells, ~1, StraussHard(r=0.1, hc=0.05))
> ##D    # fit the stationary Strauss/hard core  process to `cells'
> ##D    
> ## End(Not run)
> 
>    ppm(cells, ~ polynom(x,y,3), StraussHard(r=0.1, hc=0.05))
Nonstationary Strauss - hard core process

Log trend:  ~x + y + I(x^2) + I(x * y) + I(y^2) + I(x^3) + I(x^2 * y) + I(x * 
y^2) + I(y^3)

Fitted trend coefficients:
(Intercept)           x           y      I(x^2)    I(x * y)      I(y^2) 
   9.664167   -5.555809   -9.932433   -1.385443   12.784450   18.847027 
     I(x^3)  I(x^2 * y)  I(x * y^2)      I(y^3) 
   6.537432   -8.863096   -2.577533  -14.372586 

Interaction distance:	0.1
Hard core distance:	0.05
Fitted interaction parameter gamma:	 0.0081635

Relevant coefficients:
Interaction 
  -4.808081 

For standard errors, type coef(summary(x))
>    # fit a nonstationary Strauss/hard core process
>    # with log-cubic polynomial trend
> 
> 
> 
> cleanEx()
> nameEx("Triplets")
> ### * Triplets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Triplets
> ### Title: The Triplet Point Process Model
> ### Aliases: Triplets
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    Triplets(r=0.1)
Family of third-order interactions
Interaction:Triplets process
Interaction distance:	0.1
>    # prints a sensible description of itself
> 
>    ## Not run: 
> ##D    ppm(cells, ~1, Triplets(r=0.2))
> ##D    # fit the stationary Triplets process to `cells'
> ##D    
> ## End(Not run)
> 
>    ppm(cells, ~polynom(x,y,3), Triplets(r=0.2))
Nonstationary Triplets process

Log trend:  ~x + y + I(x^2) + I(x * y) + I(y^2) + I(x^3) + I(x^2 * y) + I(x * 
y^2) + I(y^3)

Fitted trend coefficients:
(Intercept)           x           y      I(x^2)    I(x * y)      I(y^2) 
  23.437057  -50.348833  -31.660490    4.588321  238.625780  -69.580310 
     I(x^3)  I(x^2 * y)  I(x * y^2)      I(y^3) 
  17.523650  -67.886762 -171.079375  104.848888 

Interaction distance:	0.2
Fitted interaction parameter gamma:	 0.2759337

Relevant coefficients:
Interaction 
  -1.287595 

For standard errors, type coef(summary(x))
>    # fit a nonstationary Triplets process with log-cubic polynomial trend
> 
> 
> 
> cleanEx()
> nameEx("Tstat")
> ### * Tstat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Tstat
> ### Title: Third order summary statistic
> ### Aliases: Tstat
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   plot(Tstat(redwood))
Searching 59340 potential triangles; estimated time 0.000426 sec
> 
> 
> 
> cleanEx()
> nameEx("Window")
> ### * Window
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Window
> ### Title: Extract or Change the Window of a Spatial Object
> ### Aliases: Window Window<- Window.ppp Window<-.ppp Window.psp
> ###   Window<-.psp Window.im Window<-.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    ## point patterns
>    Window(cells)
window: rectangle = [0, 1] x [0, 1] units
>    X <- demopat
>    Window(X)
window: polygonal boundary
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
>    Window(X) <- as.rectangle(Window(X))
> 
>    ## line segment patterns
>    X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>    Window(X)
window: rectangle = [0, 1] x [0, 1] units
>    Window(X) <- square(0.5)
> 
>    ## images
>    Z <- setcov(owin())
>    Window(Z)
window: binary image mask
257 x 257 pixel array (ny, nx)
enclosing rectangle: [-1, 1] x [-1, 1] units
>    Window(Z) <- square(0.5)
> 
> 
> 
> cleanEx()
> nameEx("WindowOnly")
> ### * WindowOnly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: WindowOnly
> ### Title: Extract Window of Spatial Object
> ### Aliases: Window.ppm Window.kppm Window.dppm Window.lpp Window.lppm
> ###   Window.msr Window.quad Window.quadratcount Window.quadrattest
> ###   Window.tess Window.layered Window.distfun Window.nnfun Window.funxy
> ###   Window.rmhmodel Window.leverage.ppm Window.influence.ppm
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    X <- quadratcount(cells, 4)
>    Window(X)
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("adaptive.density")
> ### * adaptive.density
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adaptive.density
> ### Title: Adaptive Estimate of Intensity of Point Pattern
> ### Aliases: adaptive.density
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   plot(adaptive.density(nztrees, 1), main="Voronoi estimate")

     PLEASE NOTE:  The components "delsgs" and "summary" of the
 object returned by deldir() are now DATA FRAMES rather than
 matrices (as they were prior to release 0.0-18).
 See help("deldir").
 
     PLEASE NOTE: The process that deldir() uses for determining
 duplicated points has changed from that used in version
 0.0-9 of this package (and previously). See help("deldir").


> 
> 
> 
> cleanEx()
> nameEx("add.texture")
> ### * add.texture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add.texture
> ### Title: Fill Plot With Texture
> ### Aliases: add.texture
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   W <- Window(chorley)
>   plot(W, main="")
>   add.texture(W, 7)
> 
> 
> 
> cleanEx()
> nameEx("addVertices")
> ### * addVertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addVertices
> ### Title: Add New Vertices to a Linear Network
> ### Aliases: addVertices
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    opa <- par(mfrow=c(1,3))
>    L <- simplenet
>    X <- runifpoint(20, Window(simplenet))
>    plot(L)
>    plot(X, add=TRUE, cols="green", pch=16, cex=2)
>    plot(addVertices(L, X, "nearest"), col="red")
>    plot(L, add=TRUE, col="grey", lwd=3)
>    plot(X, add=TRUE, cols="green", pch=16, cex=2)
>    plot(addVertices(L, X, "vertices"), col="red")
>    plot(L, add=TRUE, col="grey", lwd=3)
>    plot(X, add=TRUE, cols="green", pch=16, cex=2)
>    par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("addvar")
> ### * addvar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addvar
> ### Title: Added Variable Plot for Point Process Model
> ### Aliases: addvar
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <-  rpoispp(function(x,y){exp(3+3*x)})
>   model <- ppm(X, ~y)
>   adv <- addvar(model, "x")
>   plot(adv)
Warning in sprintf(legdesc, ylab) : argument not used by format
>   adv <- addvar(model, "x", subregion=square(0.5))
> 
> 
> 
> cleanEx()
> nameEx("affine.im")
> ### * affine.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: affine.im
> ### Title: Apply Affine Transformation To Pixel Image
> ### Aliases: affine.im
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- setcov(owin())
>   stretch <- diag(c(2,3))
>   Y <- affine(X, mat=stretch)
>   shear <- matrix(c(1,0,0.6,1),ncol=2, nrow=2)
>   Z <- affine(X, mat=shear)
> 
> 
> 
> cleanEx()
> nameEx("affine.linnet")
> ### * affine.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: affine.linnet
> ### Title: Apply Geometrical Transformations to a Linear Network
> ### Aliases: affine.linnet shift.linnet rotate.linnet rescale.linnet
> ###   scalardilate.linnet
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   U <- rotate(simplenet, pi)
>   stretch <- diag(c(2,3))
>   Y <- affine(simplenet, mat=stretch)
>   shear <- matrix(c(1,0,0.6,1),ncol=2, nrow=2)
>   Z <- affine(simplenet, mat=shear, vec=c(0, 1))
> 
> 
> 
> cleanEx()
> nameEx("affine.lpp")
> ### * affine.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: affine.lpp
> ### Title: Apply Geometrical Transformations to Point Pattern on a Linear
> ###   Network
> ### Aliases: affine.lpp shift.lpp rotate.lpp rescale.lpp scalardilate.lpp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- rpoislpp(2, simplenet)
>   U <- rotate(X, pi)
>   V <- shift(X, c(0.1, 0.2))
>   stretch <- diag(c(2,3))
>   Y <- affine(X, mat=stretch)
>   shear <- matrix(c(1,0,0.6,1),ncol=2, nrow=2)
>   Z <- affine(X, mat=shear, vec=c(0, 1))
> 
> 
> 
> cleanEx()
> nameEx("affine.owin")
> ### * affine.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: affine.owin
> ### Title: Apply Affine Transformation To Window
> ### Aliases: affine.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # shear transformation
>   shear <- matrix(c(1,0,0.6,1),ncol=2)
>   X <- affine(owin(), shear)
>   ## Not run: 
> ##D   plot(X)
> ##D   
> ## End(Not run)
>   data(letterR)
>   affine(letterR, shear, c(0, 0.5))
window: polygonal boundary
enclosing rectangle: [2.4088, 5.475] x [1.145, 3.778] units
>   affine(as.mask(letterR), shear, c(0, 0.5))
window: binary image mask
177 x 206 pixel array (ny, nx)
enclosing rectangle: [2.404, 5.478858] x [1.145, 3.778] units
> 
> 
> 
> cleanEx()
> nameEx("affine.ppp")
> ### * affine.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: affine.ppp
> ### Title: Apply Affine Transformation To Point Pattern
> ### Aliases: affine.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(cells)
>   # shear transformation
>   X <- affine(cells, matrix(c(1,0,0.6,1),ncol=2))
>   ## Not run: 
> ##D   plot(X)
> ##D   # rescale y coordinates by factor 1.3
> ##D   plot(affine(cells, diag(c(1,1.3))))
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("affine.psp")
> ### * affine.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: affine.psp
> ### Title: Apply Affine Transformation To Line Segment Pattern
> ### Aliases: affine.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   oldpar <- par(mfrow=c(2,1))
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(X, main="original")
>   # shear transformation
>   Y <- affine(X, matrix(c(1,0,0.6,1),ncol=2))
>   plot(Y, main="transformed")
>   par(oldpar)
>   # 
>   # rescale y coordinates by factor 0.2
>   affine(X, diag(c(1,0.2)))
planar line segment pattern: 10 line segments
window: rectangle = [0, 1] x [0, 0.2] units
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("affine.tess")
> ### * affine.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: affine.tess
> ### Title: Apply Geometrical Transformation To Tessellation
> ### Aliases: reflect.tess flipxy.tess shift.tess rotate.tess
> ###   scalardilate.tess affine.tess
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   live <- interactive()
>   if(live) {
+     H <- hextess(letterR, 0.2)
+     plot(H)
+     plot(reflect(H))
+     plot(rotate(H, pi/3))
+   } else H <- hextess(letterR, 0.6)
> 
>   # shear transformation
>   shear <- matrix(c(1,0,0.6,1),2,2)
>   sH <- affine(H, shear)
>   if(live) plot(sH)
> 
> 
> 
> cleanEx()
> nameEx("allstats")
> ### * allstats
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: allstats
> ### Title: Calculate four standard summary functions of a point pattern.
> ### Aliases: allstats
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
> 	data(swedishpines)
>         a <- allstats(swedishpines,dataname="Swedish Pines")
>         ## Not run: 
> ##D         plot(a)
> ##D         plot(a, subset=list("r<=15","r<=15","r<=15","r<=50"))
> ##D         
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("alltypes")
> ### * alltypes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alltypes
> ### Title: Calculate Summary Statistic for All Types in a Multitype Point
> ###   Pattern
> ### Aliases: alltypes
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    # bramblecanes (3 marks).
>    bram <- bramblecanes
>    ## Don't show: 
>       bram <- bram[c(seq(1, 744, by=20), seq(745, 823, by=4))]
>    
> ## End(Don't show)
>    bF <- alltypes(bram,"F",verb=TRUE)
i = 1 j = 1 
i = 2 j = 1 
i = 3 j = 1 
>    plot(bF)
>    if(interactive()) {
+      plot(alltypes(bram,"G"))
+      plot(alltypes(bram,"Gdot"))
+    }
>    
>    # Swedishpines (unmarked).
>   swed <- swedishpines
>    ## Don't show: 
>      swed <- swed[1:25]
>    
> ## End(Don't show)
>    plot(alltypes(swed,"K"))
> 
>    plot(alltypes(amacrine, "pcf"), ylim=c(0,1.3))
> 
>    # A setting where you might REALLY want to use dataname:
>    ## Not run: 
> ##D    xxx <- alltypes(ppp(Melvin$x,Melvin$y,
> ##D                 window=as.owin(c(5,20,15,50)),marks=clyde),
> ##D                 fun="F",verb=TRUE,dataname="Melvin")
> ##D    
> ## End(Not run)
> 
>    # envelopes
>    bKE <- alltypes(bram,"K",envelope=TRUE,nsim=19)
>    ## Not run: 
> ##D    bFE <- alltypes(bram,"F",envelope=TRUE,nsim=19,global=TRUE)
> ##D    
> ## End(Not run)
> 
>    # extract one entry
>    as.fv(bKE[1,1])
Pointwise critical envelopes for Kcross["0","0"](r)
and observed value for 'bram'
Edge correction: "iso"
Obtained from 19 simulations of CSR
Alternative: two.sided
Significance level of pointwise Monte Carlo test: 2/20 = 0.1
................................................................................
     Math.label                  
r    r                           
obs  {hat(K)[list(0,0)]^{obs}}(r)
theo {K[list(0,0)]^{theo}}(r)    
lo   {hat(K)[list(0,0)]^{lo}}(r) 
hi   {hat(K)[list(0,0)]^{hi}}(r) 
     Description                                                    
r    distance argument r                                            
obs  observed value of Kcross["0","0"](r) for data pattern          
theo theoretical value of Kcross["0","0"](r) for CSR                
lo   lower pointwise envelope of Kcross["0","0"](r) from simulations
hi   upper pointwise envelope of Kcross["0","0"](r) from simulations
................................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
Unit of length: 9 metres
>    
> 
> 
> 
> cleanEx()
> nameEx("angles.psp")
> ### * angles.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: angles.psp
> ### Title: Orientation Angles of Line Segments
> ### Aliases: angles.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   b <- angles.psp(a)   
> 
> 
> 
> cleanEx()
> nameEx("anova.lppm")
> ### * anova.lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anova.lppm
> ### Title: ANOVA for Fitted Point Process Models on Linear Network
> ### Aliases: anova.lppm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>  X <- runiflpp(10, simplenet)
>  mod0 <- lppm(X ~1)
>  modx <- lppm(X ~x)
>  anova(mod0, modx, test="Chi")
Analysis of Deviance Table

Model 1: ~1 	 Poisson
Model 2: ~x 	 Poisson
  Npar Df Deviance Pr(>Chi)
1    1                     
2    2  1    1.033   0.3095
> 
> 
> 
> cleanEx()
> nameEx("anova.mppm")
> ### * anova.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anova.mppm
> ### Title: ANOVA for Fitted Point Process Models for Replicated Patterns
> ### Aliases: anova.mppm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>  H <- hyperframe(X=waterstriders)
>  #' test for loglinear trend in x coordinate
>  mod0 <- mppm(X~1, data=H, Poisson())
>  modx <- mppm(X~x, data=H, Poisson())
>  anova(mod0, modx, test="Chi")
Analysis of Deviance Table

Model 1: X ~ 1
Model 2: X ~ x
  Npar Df Deviance Pr(>Chi)
1    1                     
2    2  1  0.65244   0.4192
>  # not significant
>  anova(modx, test="Chi")
Analysis of Deviance Table
Terms added sequentially (first to last)

     Df Deviance Npar Pr(>Chi)
NULL                1         
x     1  0.65244    2   0.4192
>  # not significant
> 
>  #' test for inhibition
>  mod0S <- mppm(X~1, data=H, Strauss(2))
>  anova(mod0, mod0S, test="Chi")
Warning: anova.mppm now computes the *adjusted* deviances when the models are not Poisson processes.
Analysis of Deviance Table

Model 1: X ~ 1
Model 2: X ~ 1
  Npar Df AdjDeviance Pr(>Chi)   
1    1                           
2    2  1      9.0688   0.0026 **
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
>  # significant! 
> 
>  #' test for trend after accounting for inhibition
>  modxS <- mppm(X~x, data=H, Strauss(2))
>  anova(mod0S, modxS, test="Chi")
Analysis of Deviance Table

Model 1: X ~ 1
Model 2: X ~ x
  Npar Df AdjDeviance Pr(>Chi)
1    2                        
2    3  1     0.67661   0.4108
>  # not significant
> 
> 
> 
> cleanEx()
> nameEx("anova.ppm")
> ### * anova.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anova.ppm
> ### Title: ANOVA for Fitted Point Process Models
> ### Aliases: anova.ppm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>  mod0 <- ppm(swedishpines ~1)
>  modx <- ppm(swedishpines ~x)
>  # Likelihood ratio test
>  anova(mod0, modx, test="Chi")
Analysis of Deviance Table

Model 1: ~1 	 Poisson
Model 2: ~x 	 Poisson
  Npar Df Deviance Pr(>Chi)
1    1                     
2    2  1    1.146   0.2844
>  # Score test
>  anova(mod0, modx, test="Rao")
Analysis of Deviance Table

Model 1: ~1 	 Poisson
Model 2: ~x 	 Poisson
  Npar Df Deviance    Rao Pr(>Chi)
1    1                            
2    2  1    1.146 1.1441   0.2848
> 
>  # Single argument
>  modxy <- ppm(swedishpines ~x + y)
>  anova(modxy, test="Chi")
Analysis of Deviance Table
Terms added sequentially (first to last)

     Df Deviance Npar Pr(>Chi)
NULL                1         
x     1  1.14601    2   0.2844
y     1  0.00283    3   0.9576
> 
>  # Adjusted composite likelihood ratio test
>  modP <- ppm(swedishpines ~1, rbord=9)
>  modS <- ppm(swedishpines ~1, Strauss(9))
>  anova(modP, modS, test="Chi")
Warning: anova.ppm now computes the *adjusted* deviances when the models are not Poisson processes.
Analysis of Deviance Table

Model 1: ~1 	 Poisson
Model 2: ~1 	 Strauss
  Npar Df AdjDeviance  Pr(>Chi)    
1    1                             
2    2  1      86.201 < 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> 
> 
> cleanEx()
> nameEx("anova.slrm")
> ### * anova.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anova.slrm
> ### Title: Analysis of Deviance for Spatial Logistic Regression Models
> ### Aliases: anova.slrm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>   X <- rpoispp(42)
>   fit0 <- slrm(X ~ 1)
>   fit1 <- slrm(X ~ x+y)
>   anova(fit0, fit1, test="Chi")
Analysis of Deviance Table

Model 1: X ~ 1 + offset(logpixelarea)
Model 2: X ~ x + y + offset(logpixelarea)
  Resid. Df Resid. Dev Df Deviance Pr(>Chi)
1     16383     524.81                     
2     16381     524.33  2  0.48006   0.7866
> 
> 
> 
> cleanEx()
> nameEx("anyNA.im")
> ### * anyNA.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anyNA.im
> ### Title: Check Whether Image Contains NA Values
> ### Aliases: anyNA.im
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   anyNA(as.im(letterR))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("anylist")
> ### * anylist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anylist
> ### Title: List of Objects
> ### Aliases: anylist as.anylist
> ### Keywords: list manip
> 
> ### ** Examples
> 
>   anylist(cells, intensity(cells), Kest(cells))
Component 1:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units

Component 2:
[1] 42

Component 3:
Function value object (class 'fv')
for the function r -> K(r)
..............................................................
       Math.label       Description                           
r      r                distance argument r                   
theo   K[pois](r)       theoretical Poisson K(r)              
border hat(K)[bord](r)  border-corrected estimate of K(r)     
trans  hat(K)[trans](r) translation-corrected estimate of K(r)
iso    hat(K)[iso](r)   isotropic-corrected estimate of K(r)  
..............................................................
Default plot formula:  .~r
where "." stands for 'iso', 'trans', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
>   anylist()
(Zero length list)
> 
> 
> 
> cleanEx()
> nameEx("append.psp")
> ### * append.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: append.psp
> ### Title: Combine Two Line Segment Patterns
> ### Aliases: append.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- psp(runif(20), runif(20), runif(20), runif(20),  window=owin())
>   Y <- psp(runif(5), runif(5), runif(5), runif(5),  window=owin())
>   append.psp(X,Y)
planar line segment pattern: 25 line segments
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("applynbd")
> ### * applynbd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: applynbd
> ### Title: Apply Function to Every Neighbourhood in a Point Pattern
> ### Aliases: applynbd
> ### Keywords: spatial programming iteration
> 
> ### ** Examples
> 
>   redwood
Planar point pattern: 62 points
window: rectangle = [0, 1] x [-1, 0] units
>   # count the number of points within radius 0.2 of each point of X
>   nneighbours <- applynbd(redwood, R=0.2, function(Y, ...){npoints(Y)-1})
>   # equivalent to:
>   nneighbours <- applynbd(redwood, R=0.2, function(Y, ...){npoints(Y)}, exclude=TRUE)
> 
>   # compute the distance to the second nearest neighbour of each point
>   secondnndist <- applynbd(redwood, N = 2,
+                            function(dists, ...){max(dists)},
+                            exclude=TRUE)
> 
>   # marked point pattern
>   trees <- longleaf
>   ## Don't show: 
> 	# smaller dataset
> 	trees <- trees[seq(1, npoints(trees), by=80)]
>   
> ## End(Don't show)
>   # compute the median of the marks of all neighbours of a point
>   # (see also 'markstat')
>   dbh.med <- applynbd(trees, R=90, exclude=TRUE,
+                  function(Y, ...) { median(marks(Y))})
> 
> 
>   # ANIMATION explaining the definition of the K function
>   # (arguments `fullpicture' and 'rad' are passed to FUN)
> 
>   if(interactive()) {
+   showoffK <- function(Y, current, dists, dranks, fullpicture,rad) { 
+ 	plot(fullpicture, main="")
+ 	points(Y, cex=2)
+         ux <- current[["x"]]
+         uy <- current[["y"]]
+ 	points(ux, uy, pch="+",cex=3)
+ 	theta <- seq(0,2*pi,length=100)
+ 	polygon(ux + rad * cos(theta), uy+rad*sin(theta))
+ 	text(ux + rad/3, uy + rad/2,npoints(Y),cex=3)
+ 	if(interactive()) Sys.sleep(if(runif(1) < 0.1) 1.5 else 0.3)
+ 	return(npoints(Y))
+   }
+   applynbd(redwood, R=0.2, showoffK, fullpicture=redwood, rad=0.2, exclude=TRUE)
+ 
+   # animation explaining the definition of the G function
+ 
+   showoffG <- function(Y, current, dists, dranks, fullpicture) { 
+ 	plot(fullpicture, main="")
+ 	points(Y, cex=2)
+         u <- current
+ 	points(u[1],u[2],pch="+",cex=3)
+ 	v <- c(Y$x[1],Y$y[1])
+ 	segments(u[1],u[2],v[1],v[2],lwd=2)
+ 	w <- (u + v)/2
+ 	nnd <- dists[1]
+ 	text(w[1],w[2],round(nnd,3),cex=2)
+ 	if(interactive()) Sys.sleep(if(runif(1) < 0.1) 1.5 else 0.3)
+ 	return(nnd)
+   }
+ 
+   applynbd(cells, N=1, showoffG, exclude=TRUE, fullpicture=cells)
+   }
> 
> 
> 
> cleanEx()
> nameEx("area.owin")
> ### * area.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: area.owin
> ### Title: Area of a Window
> ### Aliases: area area.owin area.default volume.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   w <- unit.square()
>   area(w)
[1] 1
>        # returns 1.00000
> 
>   k <- 6
>   theta <- 2 * pi * (0:(k-1))/k
>   co <- cos(theta)
>   si <- sin(theta)
>   mas <- owin(c(-1,1), c(-1,1), poly=list(x=co, y=si))
>   area(mas)
[1] 2.598076
>       # returns approx area of k-gon
>   
>   mas <- as.mask(square(2), eps=0.01)
>   X <- raster.x(mas)
>   Y <- raster.y(mas)
>   mas$m <- ((X - 1)^2 + (Y - 1)^2 <= 1)
>   area(mas)
[1] 3.1428
>        # returns 3.14 approx     
> 
> 
> 
> 
> cleanEx()
> nameEx("areaGain")
> ### * areaGain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: areaGain
> ### Title: Difference of Disc Areas
> ### Aliases: areaGain
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(cells)
>    u <- c(0.5,0.5)
>    areaGain(u, cells, 0.1)
            [,1]
[1,] 0.001780644
> 
> 
> 
> cleanEx()
> nameEx("areaLoss")
> ### * areaLoss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: areaLoss
> ### Title: Difference of Disc Areas
> ### Aliases: areaLoss
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(cells)
>    areaLoss(cells, 0.1)
             [,1]
 [1,] 0.010773142
 [2,] 0.010768182
 [3,] 0.014703949
 [4,] 0.005294811
 [5,] 0.012347945
 [6,] 0.024993490
 [7,] 0.019671399
 [8,] 0.006321533
 [9,] 0.015504991
[10,] 0.014550189
[11,] 0.018848038
[12,] 0.015452911
[13,] 0.008022816
[14,] 0.007940976
[15,] 0.012253705
[16,] 0.017945316
[17,] 0.014751070
[18,] 0.012568665
[19,] 0.003047926
[20,] 0.009867940
[21,] 0.008097216
[22,] 0.022396925
[23,] 0.018530597
[24,] 0.004741769
[25,] 0.011274103
[26,] 0.004015128
[27,] 0.005282411
[28,] 0.021757084
[29,] 0.017352595
[30,] 0.007772336
[31,] 0.008560977
[32,] 0.005952012
[33,] 0.017491475
[34,] 0.008923058
[35,] 0.009042098
[36,] 0.016487073
[37,] 0.018106516
[38,] 0.020437721
[39,] 0.023527807
[40,] 0.014515469
[41,] 0.016916114
[42,] 0.016266353
> 
> 
> 
> cleanEx()
> nameEx("as.box3")
> ### * as.box3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.box3
> ### Title: Convert Data to Three-Dimensional Box
> ### Aliases: as.box3
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>     X <- c(0,10,0,10,0,5)
>     as.box3(X)
Box: [0, 10] x [0, 10] x [0, 5] units
>     X <- pp3(runif(42),runif(42),runif(42), box3(c(0,1)))
>     as.box3(X)
Box: [0, 1] x [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("as.boxx")
> ### * as.boxx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.boxx
> ### Title: Convert Data to Multi-Dimensional Box
> ### Aliases: as.boxx
> 
> ### ** Examples
> 
>  # Convert unit square to two dimensional box.
>  W <- owin()
>  as.boxx(W)
2-dimensional box:
[0, 1] x [0, 1] units  
>  # Make three dimensional box [0,1]x[0,1]x[0,1] from numeric vector
>  as.boxx(c(0,1,0,1,0,1))
3-dimensional box:
[0, 1] x [0, 1] x [0, 1] units  
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.envelope")
> ### * as.data.frame.envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.envelope
> ### Title: Coerce Envelope to Data Frame
> ### Aliases: as.data.frame.envelope
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   E <- envelope(cells, nsim=5, savefuns=TRUE)
Generating 5 simulations of CSR  ...
1, 2, 3, 4,  5.

Done.
>   tail(as.data.frame(E))
            r       obs      theo        lo        hi
508 0.2475586 0.1682312 0.1925333 0.1655329 0.2154288
509 0.2480469 0.1682312 0.1932936 0.1655329 0.2167916
510 0.2485352 0.1695871 0.1940553 0.1655329 0.2167916
511 0.2490234 0.1727653 0.1948186 0.1670344 0.2186885
512 0.2495117 0.1727653 0.1955833 0.1670344 0.2196463
513 0.2500000 0.1727653 0.1963495 0.1670344 0.2196463
>   tail(as.data.frame(E, simfuns=TRUE))
            r       obs      theo        lo        hi      sim1      sim2
508 0.2475586 0.1682312 0.1925333 0.1655329 0.2154288 0.2154288 0.1979760
509 0.2480469 0.1682312 0.1932936 0.1655329 0.2167916 0.2167916 0.1979760
510 0.2485352 0.1695871 0.1940553 0.1655329 0.2167916 0.2167916 0.1979760
511 0.2490234 0.1727653 0.1948186 0.1670344 0.2186885 0.2186885 0.1999975
512 0.2495117 0.1727653 0.1955833 0.1670344 0.2196463 0.2186885 0.1999975
513 0.2500000 0.1727653 0.1963495 0.1670344 0.2196463 0.2186885 0.2015848
         sim3      sim4      sim5
508 0.2082383 0.1970088 0.1655329
509 0.2095203 0.2011685 0.1655329
510 0.2158267 0.2011685 0.1655329
511 0.2174411 0.2011685 0.1670344
512 0.2196463 0.2011685 0.1670344
513 0.2196463 0.2034387 0.1670344
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.hyperframe")
> ### * as.data.frame.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.hyperframe
> ### Title: Coerce Hyperframe to Data Frame
> ### Aliases: as.data.frame.hyperframe
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   h <- hyperframe(X=1:3, Y=letters[1:3], f=list(sin, cos, tan))
>   as.data.frame(h, discard=TRUE, warn=FALSE)
  X Y
1 1 a
2 2 b
3 3 c
>   as.data.frame(h, discard=FALSE)
  X Y          f
1 1 a (function)
2 2 b (function)
3 3 c (function)
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.im")
> ### * as.data.frame.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.im
> ### Title: Convert Pixel Image to Data Frame
> ### Aliases: as.data.frame.im
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    # artificial image
>    Z <- setcov(square(1))
> 
>    Y <- as.data.frame(Z)
> 
>    head(Y)
           x          y        value
1 -0.9961089 -0.9961089 1.484341e-17
2 -0.9961089 -0.9883268 1.744901e-17
3 -0.9961089 -0.9805447 2.598922e-17
4 -0.9961089 -0.9727626 3.125123e-17
5 -0.9961089 -0.9649805 4.164065e-17
6 -0.9961089 -0.9571984 1.687075e-17
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.lintess")
> ### * as.data.frame.lintess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.lintess
> ### Title: Convert Network Tessellation to Data Frame
> ### Aliases: as.data.frame.lintess
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   X <- lineardirichlet(runiflpp(3, simplenet))
>   marks(X) <- letters[1:3]
>   as.data.frame(X)
    seg        t0        t1 tile marks
1     3 0.0000000 0.5497798    1     a
2     3 0.5497798 1.0000000    2     b
2.1   6 0.0000000 0.3510218    2     b
3     6 0.3510218 1.0000000    3     c
1.1   1 0.0000000 1.0000000    1     a
1.2   2 0.0000000 1.0000000    1     a
1.3   4 0.0000000 1.0000000    1     a
1.4   5 0.0000000 1.0000000    1     a
2.2   7 0.0000000 1.0000000    2     b
1.5   8 0.0000000 1.0000000    1     a
1.6   9 0.0000000 1.0000000    1     a
3.1  10 0.0000000 0.8960024    3     c
1.7  10 0.8960024 1.0000000    1     a
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.owin")
> ### * as.data.frame.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.owin
> ### Title: Convert Window to Data Frame
> ### Aliases: as.data.frame.owin
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    as.data.frame(square(1))
  x y
1 0 0
2 1 0
3 1 1
4 0 1
> 
>    holey <- owin(poly=list(
+                         list(x=c(0,10,0), y=c(0,0,10)),
+                         list(x=c(2,2,4,4), y=c(2,4,4,2))))
>    as.data.frame(holey)
   x  y id sign
1  0 10  1    1
2  0  0  1    1
3 10  0  1    1
4  2  2  2   -1
5  2  4  2   -1
6  4  4  2   -1
7  4  2  2   -1
> 
>    M <- as.mask(holey, eps=0.5)
>    Mdf <- as.data.frame(M)
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.ppp")
> ### * as.data.frame.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.ppp
> ### Title: Coerce Point Pattern to a Data Frame
> ### Aliases: as.data.frame.ppp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(amacrine)
>   df <- as.data.frame(amacrine)
>   df[1:5,]
       x      y marks
1 0.0224 0.0243    on
2 0.0243 0.1028    on
3 0.1626 0.1477    on
4 0.1215 0.0729    on
5 0.2411 0.0486    on
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.psp")
> ### * as.data.frame.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.psp
> ### Title: Coerce Line Segment Pattern to a Data Frame
> ### Aliases: as.data.frame.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(copper)
>   df <- as.data.frame(copper$Lines)
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.tess")
> ### * as.data.frame.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.tess
> ### Title: Convert Tessellation to Data Frame
> ### Aliases: as.data.frame.tess
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   Z <- as.data.frame(dirichlet(cells))
>   head(Z, 10)
          x        y Tile
1  0.406778 0.081902    1
2  0.321668 0.112964    1
3  0.196708 0.000000    1
4  0.443843 0.000000    1
5  0.574437 0.118920    2
6  0.489959 0.178393    2
7  0.406778 0.081902    2
8  0.443843 0.000000    2
9  0.545103 0.000000    2
10 0.720037 0.114982    3
> 
> 
> 
> cleanEx()
> nameEx("as.function.fv")
> ### * as.function.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.function.fv
> ### Title: Convert Function Value Table to Function
> ### Aliases: as.function.fv as.function.rhohat
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   K <- Kest(cells)
>   f <- as.function(K)
>   f
function (r) 
`Returns interpolated value of K(r)`
>   f(0.1)
[1] 0.00116144
>   g <- as.function(K, value=c("iso", "trans"))
>   g
function (r, what = c("iso", "trans")) 
`Returns interpolated value of K(r)`
>   g(0.1, "trans")
[1] 0.001303854
> 
> 
> 
> cleanEx()
> nameEx("as.function.im")
> ### * as.function.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.function.im
> ### Title: Convert Pixel Image to Function of Coordinates
> ### Aliases: as.function.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   d <- density(cells)
>   f <- as.function(d)
>   f(0.1, 0.3)
[1] 38.75579
> 
> 
> 
> cleanEx()
> nameEx("as.function.leverage.ppm")
> ### * as.function.leverage.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.function.leverage.ppm
> ### Title: Convert Leverage Object to Function of Coordinates
> ### Aliases: as.function.leverage.ppm
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- rpoispp(function(x,y) { exp(3+3*x) })
>   fit <- ppm(X ~x+y)
>   lev <- leverage(fit)
>   f <- as.function(lev)
>   
>   f(0.2, 0.3)  # evaluate at (x,y) coordinates
[1] 1.824286
>   y <- f(X)    # evaluate at a point pattern
> 
> 
> 
> cleanEx()
> nameEx("as.function.owin")
> ### * as.function.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.function.owin
> ### Title: Convert Window to Indicator Function
> ### Aliases: as.function.owin
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   W <- Window(humberside)
>   f <- as.function(W)
>   f
function(x,y)
Indicator function (returns 1 inside window, 0 outside)
window: polygonal boundary
enclosing rectangle: [4690, 5411] x [4150, 4758] units (one unit = 100 metres)
>   f(5000, 4500)
[1] TRUE
>   f(123456, 78910)
[1] FALSE
>   X <- runifpoint(5, Frame(humberside))
>   f(X)
[1] FALSE FALSE  TRUE FALSE FALSE
>   plot(f)
> 
> 
> 
> cleanEx()
> nameEx("as.function.tess")
> ### * as.function.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.function.tess
> ### Title: Convert a Tessellation to a Function
> ### Aliases: as.function.tess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runifpoint(7)
>   V <- dirichlet(X)
>   f <- as.function(V)
>   f(0.1, 0.4)
[1] 5
Levels: 1 2 3 4 5 6 7
>   plot(f)
Interpreting pixel values as colours (valuesAreColours=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("as.fv")
> ### * as.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.fv
> ### Title: Convert Data To Class fv
> ### Aliases: as.fv as.fv.fv as.fv.fasp as.fv.data.frame as.fv.matrix
> ###   as.fv.minconfit as.fv.dppm as.fv.kppm as.fv.bw.optim
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   r <- seq(0, 1, length=101)
>   x <- data.frame(r=r, y=r^2)
>   as.fv(x)
Function value object (class 'fv')
........................
  Math.label Description
r r                     
y y                     
........................
Default plot formula:  y~r
where "." stands for 'y'
Recommended range of argument r: [0, 1]
Available range of argument r: [0, 1]
> 
> 
> 
> cleanEx()
> nameEx("as.hyperframe")
> ### * as.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.hyperframe
> ### Title: Convert Data to Hyperframe
> ### Aliases: as.hyperframe as.hyperframe.default as.hyperframe.data.frame
> ###   as.hyperframe.hyperframe as.hyperframe.listof as.hyperframe.anylist
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(4),y=letters[1:4])
>    as.hyperframe(df)
Hyperframe:
          x y
1 0.2655087 a
2 0.3721239 b
3 0.5728534 c
4 0.9082078 d
> 
>    sims <- list()
>    for(i in 1:3) sims[[i]] <- rpoispp(42)
>    as.hyperframe(as.listof(sims))
Hyperframe:
      x
1 (ppp)
2 (ppp)
3 (ppp)
>    as.hyperframe(as.solist(sims))
Hyperframe:
      x
1 (ppp)
2 (ppp)
3 (ppp)
> 
> 
> 
> cleanEx()
> nameEx("as.hyperframe.ppx")
> ### * as.hyperframe.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.hyperframe.ppx
> ### Title: Extract coordinates and marks of multidimensional point pattern
> ### Aliases: as.hyperframe.ppx as.data.frame.ppx as.matrix.ppx
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(4),y=runif(4),t=runif(4))
>    X <- ppx(data=df, coord.type=c("s","s","t"))
>    as.data.frame(X)
          x         y          t
1 0.2655087 0.2016819 0.62911404
2 0.3721239 0.8983897 0.06178627
3 0.5728534 0.9446753 0.20597457
4 0.9082078 0.6607978 0.17655675
>    val <- runif(4)
>    E <- lapply(val, function(s) { rpoispp(s) })
>    hf <- hyperframe(t=val, e=as.listof(E))
>    Z <- ppx(data=hf, domain=c(0,1))
>    as.hyperframe(Z)
Hyperframe:
          t     e
1 0.6870228 (ppp)
2 0.3841037 (ppp)
3 0.7698414 (ppp)
4 0.4976992 (ppp)
>    as.data.frame(Z)
Warning in as.data.frame.hyperframe(x$data, ...) :
  1 variable discarded in conversion to data frame
          t
1 0.6870228
2 0.3841037
3 0.7698414
4 0.4976992
> 
> 
> 
> cleanEx()
> nameEx("as.im")
> ### * as.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.im
> ### Title: Convert to Pixel Image
> ### Aliases: as.im as.im.im as.im.leverage.ppm as.im.owin as.im.matrix
> ###   as.im.tess as.im.function as.im.funxy as.im.expression as.im.distfun
> ###   as.im.nnfun as.im.densityfun as.im.Smoothfun as.im.data.frame
> ###   as.im.default
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(demopat)
>   # window object
>   W <- Window(demopat)
>   plot(W)
>   Z <- as.im(W)
>   image(Z)
>   # function
>   Z <- as.im(function(x,y) {x^2 + y^2}, unit.square())
>   image(Z)
>   # or as an expression
>   Z <- as.im(expression(x^2+y^2), square(1))
> 
>   # function with extra arguments
>   f <- function(x, y, x0, y0) {
+       sqrt((x - x0)^2 + (y-y0)^2)
+   }
>   Z <- as.im(f, unit.square(), x0=0.5, y0=0.5)
>   image(Z)
> 
>   # Revisit the Sixties
>   Z <- as.im(f, letterR, x0=2.5, y0=2)
>   image(Z)
>   # usual convention in R
>   stuff <- list(x=1:10, y=1:10, z=matrix(1:100, nrow=10))
>   Z <- as.im(stuff)
>   # convert to finer grid
>   Z <- as.im(Z, dimyx=256)
> 
>   #' distance functions
>   d <- distfun(redwood)
>   Zapprox <- as.im(d)
>   Zexact <- as.im(d, approx=FALSE)
>   plot(solist(approx=Zapprox, exact=Zexact), main="")
> 
>   # pixellate the Dirichlet tessellation
>   Di <- dirichlet(runifpoint(10))
>   plot(as.im(Di))
Interpreting pixel values as colours (valuesAreColours=TRUE)
>   plot(Di, add=TRUE)
> 
>   # as.im.data.frame is the reverse of as.data.frame.im
>   grad <- bei.extra$grad
>   slopedata <- as.data.frame(grad)
>   slope <- as.im(slopedata)
>   unitname(grad) <- unitname(slope) <- unitname(grad) # for compatibility
>   all.equal(slope, grad) # TRUE
[1] TRUE
> 
>   ## handling of character values
>   as.im("a", W=letterR, na.replace="b")
character-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
>   as.im("a", W=letterR, na.replace="b", stringsAsFactors=FALSE)
character-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
> 
> 
> 
> cleanEx()
> nameEx("as.interact")
> ### * as.interact
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.interact
> ### Title: Extract Interaction Structure
> ### Aliases: as.interact as.interact.fii as.interact.interact
> ###   as.interact.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    data(cells)
>    model <- ppm(cells, ~1, Strauss(0.07))
>    f <- as.interact(model)
>    f
Pairwise interaction family
Interaction:Strauss process
Interaction distance:	0.07
> 
> 
> 
> cleanEx()
> nameEx("as.layered")
> ### * as.layered
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.layered
> ### Title: Convert Data To Layered Object
> ### Aliases: as.layered as.layered.default as.layered.ppp
> ###   as.layered.splitppp as.layered.solist as.layered.listof
> ###   as.layered.msr
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    as.layered(cells)
Layered object

Layer 1:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
>    as.layered(amacrine)
Layered object

off:
Planar point pattern: 142 points
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)

on:
Planar point pattern: 152 points
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
> 
>    P <- rpoispp(100)
>    fit <- ppm(P ~ x+y)
>    rs <- residuals(fit, type="score")
>    as.layered(rs)
Layered object

(Intercept):
Scalar-valued measure
Approximated by 1121 quadrature points
window: rectangle = [0, 1] x [0, 1] units
93 atoms
Total mass:
discrete = 93   continuous = -93   total = -6.2984e-08

x:
Scalar-valued measure
Approximated by 1121 quadrature points
window: rectangle = [0, 1] x [0, 1] units
93 atoms
Total mass:
discrete = 48.293   continuous = -48.293   total = -2.6528e-08

y:
Scalar-valued measure
Approximated by 1121 quadrature points
window: rectangle = [0, 1] x [0, 1] units
93 atoms
Total mass:
discrete = 48.426   continuous = -48.426   total = -1.968e-08
> 
> 
> 
> cleanEx()
> nameEx("as.linfun")
> ### * as.linfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.linfun
> ### Title: Convert Data to a Function on a Linear Network
> ### Aliases: as.linfun as.linfun.linim as.linfun.lintess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    X <- runiflpp(2, simplenet)
>    Y <- runiflpp(5, simplenet)
> 
>    # image on network
>    D <- density(Y, 0.1)
> 
>    f <- as.linfun(D)
>    f
Function on linear network:
function (x, y, seg, tp) 
{
    values[nearestloc(x, y, seg, tp)]
}
<bytecode: 0x000000001d294a98>
<environment: 0x000000001d295240>
Function domain:
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>    f(X)
[1] 0.3742491 0.1048121
> 
>    # tessellation on network
>    Z <- lineardirichlet(Y)
>    g <- as.linfun(Z)
>    g(X)
[1] 3 1
Levels: 1 2 3 4 5
>    h <- as.linfun(Z, values = runif(5))
>    h(X)
[1] 0.2059746 0.6291140
> 
> 
> 
> cleanEx()
> nameEx("as.linim")
> ### * as.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.linim
> ### Title: Convert to Pixel Image on Linear Network
> ### Aliases: as.linim as.linim.linim as.linim.linfun as.linim.default
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   f <- function(x,y){ x + y }
>   plot(as.linim(f, simplenet))
> 
> 
> 
> cleanEx()
> nameEx("as.linnet.linim")
> ### * as.linnet.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.linnet.linim
> ### Title: Extract Linear Network from Data on a Linear Network
> ### Aliases: as.linnet.lpp as.linnet.linim as.linnet.linfun
> ###   as.linnet.lintess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # make some data
>   xcoord <- linfun(function(x,y,seg,tp) { x }, simplenet)
>   as.linnet(xcoord)
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   X <- as.linim(xcoord)
>   as.linnet(X)
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("as.linnet.psp")
> ### * as.linnet.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.linnet.psp
> ### Title: Convert Line Segment Pattern to Linear Network
> ### Aliases: as.linnet.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # make some data
>   A <- psp(0.09, 0.55, 0.79, 0.80, window=owin())
>   B <- superimpose(A, as.psp(simplenet))
> 
>   # convert to a linear network
>   L <- as.linnet(B)
> 
>   # check validity
>   L
Linear network with 15 vertices and 17 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   plot(L)
>   text(vertices(L), labels=vertexdegree(L))
> 
>   # show the pieces that came from original segment number 1
>   S <- as.psp(L)
>   (camefrom <- attr(L, "camefrom"))
 [1]  2  2  4  4  7  7  6  8  9 11 10  1  1  1  1  3  5
>   parts <- which(camefrom == 1)
>   plot(S[parts], add=TRUE, col="green", lwd=2)
> 
> 
> 
> cleanEx()
> nameEx("as.lpp")
> ### * as.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.lpp
> ### Title: Convert Data to a Point Pattern on a Linear Network
> ### Aliases: as.lpp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    A <- as.psp(simplenet)
>    X <- runifpointOnLines(10, A)
>    is.ppp(X)
[1] TRUE
>    Y <- as.lpp(X, L=simplenet)
> 
> 
> 
> cleanEx()
> nameEx("as.mask")
> ### * as.mask
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.mask
> ### Title: Pixel Image Approximation of a Window
> ### Aliases: as.mask
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   w <- owin(c(0,10),c(0,10), poly=list(x=c(1,2,3,2,1), y=c(2,3,4,6,7)))
>   ## Not run: plot(w)
>   m <- as.mask(w)
>   ## Not run: plot(m)
>   x <- 1:9
>   y <- seq(0.25, 9.75, by=0.5)
>   m <- as.mask(w, xy=list(x=x, y=y))
> 
> 
> 
> cleanEx()
> nameEx("as.mask.psp")
> ### * as.mask.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.mask.psp
> ### Title: Convert Line Segment Pattern to Binary Pixel Mask
> ### Aliases: as.mask.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(as.mask.psp(X))
>   plot(X, add=TRUE, col="red")
> 
> 
> 
> cleanEx()
> nameEx("as.matrix.im")
> ### * as.matrix.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.matrix.im
> ### Title: Convert Pixel Image to Matrix or Array
> ### Aliases: as.matrix.im as.array.im
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    # artificial image
>    Z <- setcov(square(1))
> 
>    M <- as.matrix(Z)
> 
>    median(M)
[1] 0.1845703
>    
>    ## Not run: 
> ##D    # plot the cumulative distribution function of pixel values
> ##D    plot(ecdf(as.matrix(Z)))
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("as.matrix.owin")
> ### * as.matrix.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.matrix.owin
> ### Title: Convert Pixel Image to Matrix
> ### Aliases: as.matrix.owin
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   m <- as.matrix(letterR)
> 
> 
> 
> cleanEx()
> nameEx("as.owin")
> ### * as.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.owin
> ### Title: Convert Data To Class owin
> ### Aliases: as.owin as.owin.owin as.owin.ppp as.owin.ppm as.owin.kppm
> ###   as.owin.dppm as.owin.lpp as.owin.lppm as.owin.msr as.owin.psp
> ###   as.owin.quad as.owin.quadratcount as.owin.quadrattest as.owin.tess
> ###   as.owin.im as.owin.layered as.owin.data.frame as.owin.distfun
> ###   as.owin.nnfun as.owin.funxy as.owin.boxx as.owin.rmhmodel
> ###   as.owin.leverage.ppm as.owin.influence.ppm as.owin.default
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  w <- as.owin(c(0,1,0,1))
>  w <- as.owin(list(xrange=c(0,5),yrange=c(0,10)))
>  # point pattern
>  data(demopat)
>  w <- as.owin(demopat)
>  # image
>  Z <- as.im(function(x,y) { x + 3}, unit.square())
>  w <- as.owin(Z)
> 
>  # Venables & Ripley 'spatial' package
>  spatialpath <- system.file(package="spatial")
>  if(nchar(spatialpath) > 0) {
+    require(spatial)
+    towns <- ppinit("towns.dat")
+    w <- as.owin(towns)
+    detach(package:spatial)
+  }
Loading required package: spatial

Attaching package: 'spatial'

The following object is masked from 'package:spatstat':

    Strauss

> 
> 
> 
> cleanEx()
> nameEx("as.polygonal")
> ### * as.polygonal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.polygonal
> ### Title: Convert a Window to a Polygonal Window
> ### Aliases: as.polygonal
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    data(letterR)
>    m <- as.mask(letterR, dimyx=32)
>    p <- as.polygonal(m)
>    if(interactive()) {
+       plot(m)
+       plot(p, add=TRUE, lwd=2)
+    }
> 
> 
> 
> cleanEx()
> nameEx("as.ppm")
> ### * as.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.ppm
> ### Title: Extract Fitted Point Process Model
> ### Aliases: as.ppm as.ppm.ppm as.ppm.profilepl as.ppm.kppm as.ppm.dppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    # fit a model by profile maximum pseudolikelihood
>    rvals <- data.frame(r=(1:10)/100)
>    pfit <- profilepl(rvals, Strauss, cells, ~1)
(computing rbord)
comparing 10 models...
1, 2, 3, 4, 5, 6, 7, 8, 9,  10.
fitting optimal model...
done.
>    # extract the fitted model
>    fit <- as.ppm(pfit)
> 
> 
> 
> cleanEx()
> nameEx("as.ppp")
> ### * as.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.ppp
> ### Title: Convert Data To Class ppp
> ### Aliases: as.ppp as.ppp.ppp as.ppp.psp as.ppp.quad as.ppp.matrix
> ###   as.ppp.data.frame as.ppp.influence.ppm as.ppp.default
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  xy <- matrix(runif(40), ncol=2)
>  pp <- as.ppp(xy, c(0,1,0,1))
> 
>  # Venables-Ripley format
>  # check for 'spatial' package
>  spatialpath <- system.file(package="spatial")
>  if(nchar(spatialpath) > 0) {
+    require(spatial)
+    towns <- ppinit("towns.dat")
+    pp <- as.ppp(towns) # converted to our format
+    detach(package:spatial)
+  }
Loading required package: spatial

Attaching package: 'spatial'

The following object is masked from 'package:spatstat':

    Strauss

> 
>  xyzt <- matrix(runif(40), ncol=4)
>  Z <- as.ppp(xyzt, square(1))
> 
> 
> 
> cleanEx()
> nameEx("as.psp")
> ### * as.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.psp
> ### Title: Convert Data To Class psp
> ### Aliases: as.psp as.psp.psp as.psp.data.frame as.psp.matrix
> ###   as.psp.default
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    mat <- matrix(runif(40), ncol=4)
>    mx <- data.frame(v1=sample(1:4,10,TRUE),
+                     v2=factor(sample(letters[1:4],10,TRUE),levels=letters[1:4]))
>    a <- as.psp(mat, window=owin(),marks=mx)
>    mat <- cbind(as.data.frame(mat),mx)
>    b <- as.psp(mat, window=owin()) # a and b are identical.
>    stuff <- list(xmid=runif(10),
+                  ymid=runif(10),
+                  length=rep(0.1, 10),
+                  angle=runif(10, 0, 2 * pi))
>    a <- as.psp(stuff, window=owin())
>    b <- as.psp(from=runifpoint(10), to=runifpoint(10))
> 
> 
> 
> cleanEx()
> nameEx("as.rectangle")
> ### * as.rectangle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.rectangle
> ### Title: Window Frame
> ### Aliases: as.rectangle
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   w <- owin(c(0,10),c(0,10), poly=list(x=c(1,2,3,2,1), y=c(2,3,4,6,7)))
>   r <- as.rectangle(w)
>   # returns a 10 x 10 rectangle
> 
>   data(lansing)
>   as.rectangle(lansing)
window: rectangle = [0, 1] x [0, 1] units (one unit = 924 feet)
> 
>   data(copper)
>   as.rectangle(copper$SouthLines)
window: rectangle = [-0.335, 35] x [0.19, 158.233] km
> 
> 
> 
> cleanEx()
> nameEx("as.solist")
> ### * as.solist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.solist
> ### Title: Convert List of Two-Dimensional Spatial Objects
> ### Aliases: as.solist
> ### Keywords: spatial list manip
> 
> ### ** Examples
> 
>   x <- list(cells, density(cells))
>   y <- as.solist(x)
> 
> 
> 
> cleanEx()
> nameEx("as.tess")
> ### * as.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.tess
> ### Title: Convert Data To Tessellation
> ### Aliases: as.tess as.tess.tess as.tess.im as.tess.owin
> ###   as.tess.quadratcount as.tess.quadrattest as.tess.list
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  # pixel image
>  v <- as.im(function(x,y){factor(round(5 * (x^2 + y^2)))}, W=owin())
>  levels(v) <- letters[seq(length(levels(v)))]
>  as.tess(v)
Tessellation
Tessellation is determined by a factor-valued image with 11 levels
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>  # quadrat counts
>  data(nztrees)
>  qNZ <- quadratcount(nztrees, nx=4, ny=3)
>  as.tess(qNZ)
Tessellation
Tiles are equal rectangles, of dimension 38.25 x 31.667 feet 
4 by 3 grid of tiles
window: rectangle = [0, 153] x [0, 95] feet
> 
> 
> 
> cleanEx()
> nameEx("auc")
> ### * auc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: auc
> ### Title: Area Under ROC Curve
> ### Aliases: auc auc.ppp auc.lpp auc.ppm auc.kppm auc.lppm
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   fit <- ppm(swedishpines ~ x+y)
>   auc(fit)
      obs      theo 
0.5357021 0.5367281 
>   auc(swedishpines, "x")
[1] 0.5369442
> 
> 
> 
> cleanEx()
> nameEx("bc.ppm")
> ### * bc.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bc.ppm
> ### Title: Bias Correction for Fitted Model
> ### Aliases: bc bc.ppm
> ### Keywords: spatial models math optimize
> 
> ### ** Examples
> 
>   fit <- ppm(cells ~ x, Strauss(0.07))
>   coef(fit)
(Intercept)           x Interaction 
  4.4488826   0.7026719 -19.3170429 
>   if(!interactive()) {
+     bc(fit, nfine=64)
+   } else {
+     bc(fit)
+   }
(Intercept)           x Interaction 
  4.5935580   0.7460471 -20.4704195 
> 
> 
> 
> cleanEx()
> nameEx("bdist.pixels")
> ### * bdist.pixels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bdist.pixels
> ### Title: Distance to Boundary of Window
> ### Aliases: bdist.pixels
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   u <- owin(c(0,1),c(0,1))
>   d <- bdist.pixels(u, eps=0.01)
>   image(d)
>   d <- bdist.pixels(u, eps=0.01, style="matrix")
>   mean(d >= 0.1)
[1] 0.64
>   # value is approx (1 - 2 * 0.1)^2 = 0.64
> 
> 
> 
> cleanEx()
> nameEx("bdist.points")
> ### * bdist.points
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bdist.points
> ### Title: Distance to Boundary of Window
> ### Aliases: bdist.points
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(cells)
>   d <- bdist.points(cells)
> 
> 
> 
> cleanEx()
> nameEx("bdist.tiles")
> ### * bdist.tiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bdist.tiles
> ### Title: Distance to Boundary of Window
> ### Aliases: bdist.tiles
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   P <- runifpoint(15)
>   X <- dirichlet(P)
>   plot(X, col="red")
>   B <- bdist.tiles(X)
>   # identify tiles that do not touch the boundary
>   plot(X[B > 0], add=TRUE, col="green", lwd=3)
> 
> 
> 
> cleanEx()
> nameEx("beachcolours")
> ### * beachcolours
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: beachcolours
> ### Title: Create Colour Scheme for a Range of Numbers
> ### Aliases: beachcolours beachcolourmap
> ### Keywords: spatial color
> 
> ### ** Examples
> 
>   plot(beachcolourmap(c(-2,2)))
> 
> 
> 
> cleanEx()
> nameEx("beginner")
> ### * beginner
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: beginner
> ### Title: Print Introduction For Beginners
> ### Aliases: beginner
> ### Keywords: documentation
> 
> ### ** Examples
> 
>   beginner
        -== Welcome to the 'spatstat' package! ==-

For a friendly introduction to spatstat, type the command
     vignette('getstart')
which displays the document "Getting Started with Spatstat".

For an overview of all capabilities, type 
    help(spatstat)

View the documentation for any command/function 'foo' by typing 
     help(foo)

Activate the graphical help interface by typing
     help.start()

To handle spatial data in the 'shapefile' format, see the document
"Handling shapefiles in the spatstat package", by typing
     vignette('shapefiles')

For a complete course on spatstat, see the book
   "Spatial Point Patterns: Methodology and Applications with R"
by Baddeley, Rubak and Turner, Chapman and Hall/CRC Press, December 2015.
For a summary of changes to spatstat since the book was finished, type
     vignette('updates')
Visit the website
        www.spatstat.org
for updates and free chapters.

For news about the very latest version of spatstat, type
     latest.news

[[[Press 'Q' to exit, on some computers]]]





> 
> 
> 
> cleanEx()
> nameEx("begins")
> ### * begins
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: begins
> ### Title: Check Start of Character String
> ### Aliases: begins
> ### Keywords: character
> 
> ### ** Examples
> 
>   begins(c("Hello", "Goodbye"), "Hell")
[1]  TRUE FALSE
>   begins("anything", "")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("berman.test")
> ### * berman.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: berman.test
> ### Title: Berman's Tests for Point Process Model
> ### Aliases: berman.test berman.test.ppm berman.test.ppp berman.test.lppm
> ###   berman.test.lpp
> ### Keywords: htest spatial
> 
> ### ** Examples
> 
>    # Berman's data
>    data(copper)
>    X <- copper$SouthPoints
>    L <- copper$SouthLines
>    D <- distmap(L, eps=1)
>    # test of CSR
>    berman.test(X, D)

	Berman Z1 test of CSR in two dimensions

data:  covariate 'D' evaluated at points of 'X'
Z1 = 0.46963, p-value = 0.6386
alternative hypothesis: two-sided

>    berman.test(X, D, "Z2")

	Berman Z2 test of CSR in two dimensions

data:  covariate 'D' evaluated at points of 'X' 
	 and transformed to uniform distribution under CSR
Z2 = 1.133, p-value = 0.2572
alternative hypothesis: two-sided

> 
> 
> 
> cleanEx()
> nameEx("bind.fv")
> ### * bind.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bind.fv
> ### Title: Combine Function Value Tables
> ### Aliases: bind.fv cbind.fv
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
>    data(cells)
>    K1 <- Kest(cells, correction="border")
>    K2 <- Kest(cells, correction="iso")
>    # remove column 'theo' to avoid duplication
>    K2 <- K2[, names(K2) != "theo"]
> 
>    cbind(K1, K2)
Function value object (class 'fv')
for the function r -> K(r)
...........................................................
       Math.label      Description                         
r      r               distance argument r                 
theo   K[pois](r)      theoretical Poisson K(r)            
border hat(K)[bord](r) border-corrected estimate of K(r)   
iso    hat(K)[iso](r)  isotropic-corrected estimate of K(r)
...........................................................
Default plot formula:  .~r
where "." stands for 'iso', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
>    bind.fv(K1, K2, preferred="iso")
Function value object (class 'fv')
for the function r -> K(r)
...........................................................
       Math.label      Description                         
r      r               distance argument r                 
theo   K[pois](r)      theoretical Poisson K(r)            
border hat(K)[bord](r) border-corrected estimate of K(r)   
iso    hat(K)[iso](r)  isotropic-corrected estimate of K(r)
...........................................................
Default plot formula:  .~r
where "." stands for 'iso', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
>    # constrain border estimate to be monotonically increasing
>    bm <- cumsum(c(0, pmax(0, diff(K1$border))))
>    bind.fv(K1, data.frame(bmono=bm),
+                "%s[bmo](r)",
+                "monotone border-corrected estimate of %s",
+                "bmono") 
Function value object (class 'fv')
for the function r -> K(r)
.................................................................
       Math.label      Description                               
r      r               distance argument r                       
theo   K[pois](r)      theoretical Poisson K(r)                  
border hat(K)[bord](r) border-corrected estimate of K(r)         
bmono  K[bmo](r)       monotone border-corrected estimate of K(r)
.................................................................
Default plot formula:  .~r
where "." stands for 'bmono', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
> 
> 
> cleanEx()
> nameEx("bits.envelope")
> ### * bits.envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bits.envelope
> ### Title: Global Envelopes for Balanced Independent Two-Stage Test
> ### Aliases: bits.envelope
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>   ns <- if(interactive()) 19 else 4
>   E <- bits.envelope(swedishpines, Lest, nsim=ns)
Applying first-stage test to original data... Done.
Repeating first-stage test... Done.
Running tests on 4 simulated patterns... 1, 2, 3,  4.
bits.rank = 4
bits.crit = 0.9375
>   E
Function value object (class 'fv')
for the function r -> L(r)
...........................................................
     Math.label     Description                            
r    r              distance argument r                    
obs  hat(L)[obs](r) observed value of L(r) for data pattern
theo L[theo](r)     theoretical value of L(r) for CSR      
hi   L[hi](r)       upper 20% critical boundary for L(r)   
lo   L[lo](r)       lower 20% critical boundary for L(r)   
...........................................................
Default plot formula:  .~.x
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 24]
Available range of argument r: [0, 24]
Unit of length: 0.1 metres
>   plot(E)
>   Eo <- bits.envelope(swedishpines, Lest, alternative="less", nsim=ns)
Applying first-stage test to original data... Done.
Repeating first-stage test... Done.
Running tests on 4 simulated patterns... 1, 2, 3,  4.
bits.rank = 1
bits.crit = 1.40625
>   Ei <- bits.envelope(swedishpines, Lest, interpolate=TRUE, nsim=ns)
Applying first-stage test to original data... Done.
Repeating first-stage test... Done.
Running tests on 4 simulated patterns... 1, 2, 3,  4.
> 
> 
> 
> cleanEx()
> nameEx("bits.test")
> ### * bits.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bits.test
> ### Title: Balanced Independent Two-Stage Monte Carlo Test
> ### Aliases: bits.test
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>  ns <- if(interactive()) 19 else 4
>  bits.test(cells, nsim=ns)
Applying first-stage test to original data... Repeating first-stage test... Done.
Running second-stage tests on 4 simulated patterns... 1, 2, 3,  4.

	Balanced Independent Two-stage Test
	based on Diggle-Cressie-Loosmore-Ford test of CSR
	First stage: Monte Carlo test based on 4 simulations
	Summary function: K(r)
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0, 0.25]
	Test statistic: Integral of squared absolute deviation
	Deviation = observed minus theoretical
	Second stage: 4 * 4 nested simulations independent of first stage

data:  X
p0 = 0.2, p-value = 0.4

>  bits.test(cells, alternative="less", nsim=ns)
Applying first-stage test to original data... Repeating first-stage test... Done.
Running second-stage tests on 4 simulated patterns... 1, 2, 3,  4.

	Balanced Independent Two-stage Test
	based on Diggle-Cressie-Loosmore-Ford test of CSR
	First stage: Monte Carlo test based on 4 simulations
	Summary function: K(r)
	Reference function: theoretical
	Alternative: less
	Interval of distance values: [0, 0.25]
	Test statistic: Integral of squared signed deviation
	Deviation = observed minus theoretical
	Second stage: 4 * 4 nested simulations independent of first stage

data:  X
p0 = 0.2, p-value = 0.8

>  bits.test(cells, nsim=ns, interpolate=TRUE)
Applying first-stage test to original data... Repeating first-stage test... Done.
Running second-stage tests on 4 simulated patterns... 1, 2, 3,  4.

	Balanced Independent Two-stage Test
	based on Diggle-Cressie-Loosmore-Ford test of CSR
	First stage: Interpolated Monte Carlo test based on 4 simulations
	Summary function: K(r)
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0, 0.25]
	Test statistic: Integral of squared absolute deviation
	Deviation = observed minus theoretical
	Second stage: 4 * 4 nested simulations independent of first stage

data:  X
p0 = 0.31209, p-value = 0.4

> 
> 
> 
> cleanEx()
> nameEx("blur")
> ### * blur
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blur
> ### Title: Apply Gaussian Blur to a Pixel Image
> ### Aliases: blur Smooth.im
> ### Keywords: spatial nonparametric manip
> 
> ### ** Examples
> 
>    Z <- as.im(function(x,y) { 4 * x^2 + 3 * y }, letterR)
>    par(mfrow=c(1,3))
>    plot(Z)
>    plot(letterR, add=TRUE)
>    plot(blur(Z, 0.3, bleed=TRUE))
>    plot(letterR, add=TRUE)
>    plot(blur(Z, 0.3, bleed=FALSE))
>    plot(letterR, add=TRUE)
>    par(mfrow=c(1,1))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("border")
> ### * border
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: border
> ### Title: Border Region of a Window
> ### Aliases: border
> ### Keywords: spatial math
> 
> ### ** Examples
> 
> # rectangle
>    u <- unit.square()
>    border(u, 0.1)
window: polygonal boundary
enclosing rectangle: [0, 1] x [0, 1] units
>    border(u, 0.1, outside=TRUE)
window: polygonal boundary
enclosing rectangle: [-0.1, 1.1] x [-0.1, 1.1] units
> # polygon
>    ## Don't show: 
> opa <- spatstat.options(npixel=32)
> ## End(Don't show)
>    data(letterR)
>    plot(letterR)
>    plot(border(letterR, 0.1), add=TRUE)
>    plot(border(letterR, 0.1, outside=TRUE), add=TRUE)
>    ## Don't show: 
> spatstat.options(opa)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("bounding.box.xy")
> ### * bounding.box.xy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bounding.box.xy
> ### Title: Convex Hull of Points
> ### Aliases: bounding.box.xy
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>   x <- runif(30)
>   y <- runif(30)
>   w <- bounding.box.xy(x,y)
>   plot(owin(), main="bounding.box.xy(x,y)")
>   plot(w, add=TRUE)
>   points(x,y)
> 
>   X <- rpoispp(30)
>   plot(X, main="bounding.box.xy(X)")
>   plot(bounding.box.xy(X), add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("boundingbox")
> ### * boundingbox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boundingbox
> ### Title: Bounding Box of a Window, Image, or Point Pattern
> ### Aliases: boundingbox boundingbox.default boundingbox.im
> ###   boundingbox.owin boundingbox.ppp boundingbox.psp boundingbox.lpp
> ###   boundingbox.linnet boundingbox.solist
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>   w <- owin(c(0,10),c(0,10), poly=list(x=c(1,2,3,2,1), y=c(2,3,4,6,7)))
>   r <- boundingbox(w)
>   # returns rectangle [1,3] x [2,7]
> 
>   w2 <- unit.square()
>   r <- boundingbox(w, w2)
>   # returns rectangle [0,3] x [0,7]
> 
> 
> 
> cleanEx()
> nameEx("boundingcircle")
> ### * boundingcircle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boundingcircle
> ### Title: Smallest Enclosing Circle
> ### Aliases: boundingradius boundingradius.owin boundingradius.ppp
> ###   boundingcentre boundingcircle boundingcentre.owin boundingcircle.owin
> ###   boundingcentre.ppp boundingcircle.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   boundingradius(letterR)
[1] 1.623404
> 
>   plot(grow.rectangle(Frame(letterR), 0.2), main="", type="n")
>   plot(letterR, add=TRUE, col="grey")
>   plot(boundingcircle(letterR), add=TRUE, border="green", lwd=2)
>   plot(boundingcentre(letterR), pch="+", cex=2, col="blue", add=TRUE)
> 
>   X <- runifpoint(5)
>   plot(X)
>   plot(boundingcircle(X), add=TRUE)
>   plot(boundingcentre(X), pch="+", cex=2, col="blue", add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("box3")
> ### * box3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: box3
> ### Title: Three-Dimensional Box
> ### Aliases: box3
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>     box3()
Box: [0, 1] x [0, 1] x [0, 1] units
>     box3(c(0,10),c(0,10),c(0,5), unitname=c("metre","metres"))
Box: [0, 10] x [0, 10] x [0, 5] metres
>     box3(c(-1,1))
Box: [-1, 1] x [-1, 1] x [-1, 1] units
> 
> 
> 
> cleanEx()
> nameEx("boxx")
> ### * boxx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boxx
> ### Title: Multi-Dimensional Box
> ### Aliases: boxx
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>     boxx(c(0,10),c(0,10),c(0,5),c(0,1), unitname=c("metre","metres"))
4-dimensional box:
[0, 10] x [0, 10] x [0, 5] x [0, 1] metres  
> 
> 
> 
> cleanEx()
> nameEx("branchlabelfun")
> ### * branchlabelfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: branchlabelfun
> ### Title: Tree Branch Membership Labelling Function
> ### Aliases: branchlabelfun
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # make a simple tree
>   m <- simplenet$m
>   m[8,10] <- m[10,8] <- FALSE
>   L <- linnet(vertices(simplenet), m)
>   # make function
>   f <- branchlabelfun(L, 1)
>   plot(f)
>   X <- runiflpp(5, L)
>   f(X)
[1] "b"  "c"  "cb" "a"  "cb"
> 
> 
> 
> cleanEx()
> nameEx("bugfixes")
> ### * bugfixes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bugfixes
> ### Title: List Recent Bug Fixes
> ### Aliases: bugfixes
> ### Keywords: documentation
> 
> ### ** Examples
> 
>    bugfixes

*** density.ppp ***

1.64-1 : density.ppp
   Crashed when se=TRUE if there were multiple columns of 'weights'.
   Fixed. 



*** rbind.hyperframe ***

1.64-1 : rbind.hyperframe
   Crashed unless all arguments had the same number of rows.
   (Spotted by Maximilian Vogtland).
   Fixed. 



*** vcov.ppm ***

1.64-1 : vcov.ppm
   Variances were sometimes overestimated for Gibbs models.
   That is, entries of the Fisher information matrix were underestimated,
   because some contributions due to interaction were omitted
   (due to a coding error).
   Fixed. 


>    ## show all bugs reported after publication of the spatstat book
>    if(interactive()) bugfixes(sinceversion="1.42-1")
>    ## equivalent to bugfixes(sinceversion="book")
> 
> 
> 
> cleanEx()
> nameEx("bw.CvL")
> ### * bw.CvL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.CvL
> ### Title: Cronie and van Lieshout's Criterion for Bandwidth Selection for
> ###   Kernel Density
> ### Aliases: bw.CvL
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   if(interactive()) {
+     b <- bw.CvL(redwood)
+     b
+     plot(b, main="Cronie and van Lieshout bandwidth criterion for redwoods")
+     plot(density(redwood, b))
+     plot(density(redwood, bw.CvL))
+   }
>   ## Don't show: 
>     b <- bw.CvL(redwood, srange=c(0.03, 0.07), ns=2)
Warning: Cronie and van Lieshout criterion was minimised at right-hand end of interval [0.03, 0.07]; use argument 'srange' to specify a wider interval for bandwidth 'sigma'
>   
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("bw.abram")
> ### * bw.abram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.abram
> ### Title: Abramson's Adaptive Bandwidths
> ### Aliases: bw.abram
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
> # 'ch' just 58 laryngeal cancer cases
> ch <- split(chorley)[[1]]
> 
> h <- bw.abram(ch,h0=1,hp=0.7)
> length(h)
[1] 58
> summary(h)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.7066  0.8343  0.9654  1.0274  1.2169  1.5417 
> if(interactive()) hist(h)
> 
> # calculate pilot based on all 1036 observations
> h.pool <- bw.abram(ch,h0=1,hp=0.7,pilot=chorley)
> length(h.pool)
[1] 58
> summary(h.pool)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.5864  0.7754  0.9802  1.1559  1.3720  3.6210 
> if(interactive()) hist(h.pool)
> 
> # get full image used for 'h' above
> him <- bw.abram(ch,h0=1,hp=0.7,at="pixels")
> plot(him);points(ch,col="grey")
> 
> # use Voronoi-Dirichlet pilot ('hp' is ignored)
> hvo <- bw.abram(ch, h0=1, smoother=densityVoronoi)
> 
> 
> 
> cleanEx()
> nameEx("bw.diggle")
> ### * bw.diggle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.diggle
> ### Title: Cross Validated Bandwidth Selection for Kernel Density
> ### Aliases: bw.diggle
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   data(lansing)
>   attach(split(lansing))
>   b <- bw.diggle(hickory)
>   plot(b, ylim=c(-2, 0), main="Cross validation for hickories")
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
> 
> 
> cleanEx()

detaching 'split(lansing)'

> nameEx("bw.frac")
> ### * bw.frac
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.frac
> ### Title: Bandwidth Selection Based on Window Geometry
> ### Aliases: bw.frac
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   h <- bw.frac(letterR)
>   h
[1] 0.7225374
>   plot(h, main="bw.frac(letterR)")
> 
> 
> 
> cleanEx()
> nameEx("bw.lppl")
> ### * bw.lppl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.lppl
> ### Title: Likelihood Cross Validation Bandwidth Selection for Kernel
> ###   Density on a Linear Network
> ### Aliases: bw.lppl
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   if(interactive()) {
+     b <- bw.lppl(spiders)
+     plot(b, main="Likelihood cross validation for spiders")
+     plot(density(spiders, b, distance="e"))
+   } else {
+     b1 <- bw.lppl(spiders, ns=2)
+     b2 <- bw.lppl(spiders, ns=2, shortcut=TRUE)
+   }
Warning: Likelihood Cross-Validation criterion was maximised at right-hand end of interval [15.8, 792]; use argument 'srange' to specify a wider interval for bandwidth 'sigma'
Warning: Likelihood Cross-Validation criterion was maximised at right-hand end of interval [15.8, 792]; use argument 'srange' to specify a wider interval for bandwidth 'sigma'
> 
> 
> 
> cleanEx()
> nameEx("bw.pcf")
> ### * bw.pcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.pcf
> ### Title: Cross Validated Bandwidth Selection for Pair Correlation
> ###   Function
> ### Aliases: bw.pcf
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   b <- bw.pcf(redwood)
>   plot(pcf(redwood, bw=b))
> 
> 
> 
> cleanEx()
> nameEx("bw.ppl")
> ### * bw.ppl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.ppl
> ### Title: Likelihood Cross Validation Bandwidth Selection for Kernel
> ###   Density
> ### Aliases: bw.ppl
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   if(interactive()) {
+     b <- bw.ppl(redwood)
+     plot(b, main="Likelihood cross validation for redwoods")
+     plot(density(redwood, b))
+   }
>   ## Don't show: 
>     b1 <- bw.ppl(redwood, srange=c(0.03, 0.07), ns=2)
Warning: Likelihood Cross-Validation criterion was minimised at right-hand end of interval [0.03, 0.07]; use argument 'srange' to specify a wider interval for bandwidth 'sigma'
>     b2 <- bw.ppl(redwood, srange=c(0.03, 0.07), ns=2, shortcut=TRUE)
Warning: Likelihood Cross-Validation criterion was minimised at right-hand end of interval [0.03, 0.07]; use argument 'srange' to specify a wider interval for bandwidth 'sigma'
>   
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("bw.relrisk")
> ### * bw.relrisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.relrisk
> ### Title: Cross Validated Bandwidth Selection for Relative Risk Estimation
> ### Aliases: bw.relrisk
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   data(urkiola)
>   ## Don't show: 
> op <- spatstat.options(n.bandwidth=8)
> ## End(Don't show)
>   b <- bw.relrisk(urkiola)
>   b
   sigma 
10.58851 
>   plot(b)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>   b <- bw.relrisk(urkiola, hmax=20)
Warning: Likelihood Cross-Validation criterion was minimised at right-hand end of interval [0.139, 20]; use arguments 'hmin', 'hmax' to specify a wider interval for bandwidth 'sigma'
>   plot(b)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>   ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("bw.relrisklpp")
> ### * bw.relrisklpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.relrisklpp
> ### Title: Cross Validated Bandwidth Selection for Relative Risk Estimation
> ###   on a Network
> ### Aliases: bw.relrisklpp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    set.seed(2020)
>    X <- superimpose(A=runiflpp(20, simplenet),
+                     B=runifpointOnLines(20, as.psp(simplenet)[1]))
>    plot(bw.relrisklpp(X, hmin=0.1, hmax=0.3, method="McSwiggan"))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>    plot(bw.relrisklpp(X, hmin=0.1, hmax=0.3, distance="euclidean"))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("bw.scott")
> ### * bw.scott
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.scott
> ### Title: Scott's Rule for Bandwidth Selection for Kernel Density
> ### Aliases: bw.scott bw.scott.iso
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   hickory <- split(lansing)[["hickory"]]
>   b <- bw.scott(hickory)
>   b
   sigma.x    sigma.y 
0.11030430 0.09009471 
>   bw.scott.iso(hickory)
     sigma 
0.09968868 
>   bw.scott(chicago)
 sigma.x  sigma.y 
125.2866 114.0770 
>   bw.scott(osteo$pts[[1]])
 sigma.x  sigma.y  sigma.z 
17.29770 17.51518 10.26458 
> 
> 
> 
> cleanEx()
> nameEx("bw.smoothppp")
> ### * bw.smoothppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.smoothppp
> ### Title: Cross Validated Bandwidth Selection for Spatial Smoothing
> ### Aliases: bw.smoothppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   data(longleaf)
>   ## Don't show: 
> op <- spatstat.options(n.bandwidth=8)
> ## End(Don't show)
>   b <- bw.smoothppp(longleaf)
>   b
   sigma 
6.341161 
>   plot(b)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>   ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("bw.stoyan")
> ### * bw.stoyan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.stoyan
> ### Title: Stoyan's Rule of Thumb for Bandwidth Selection
> ### Aliases: bw.stoyan
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   data(shapley)
>   bw.stoyan(shapley)
[1] 0.0153616
> 
> 
> 
> cleanEx()
> nameEx("bw.voronoi")
> ### * bw.voronoi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bw.voronoi
> ### Title: Cross Validated Bandwidth Selection for Voronoi Estimator of
> ###   Intensity on a Network
> ### Aliases: bw.voronoi
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    np <- if(interactive()) 10 else 3
>    nr <- if(interactive()) 100 else 2
>    b <- bw.voronoi(spiders, nprob=np, nrep=nr)
Performing 2 replicates... 1,  2.
Warning: Likelihood Cross-Validation criterion was minimised at right-hand end of interval [0.2, 0.8]; use arguments 'probrange', 'prob' to specify a wider interval for bandwidth 'prob'
>    b
prob 
 0.8 
>    plot(b)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("by.im")
> ### * by.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: by.im
> ### Title: Apply Function to Image Broken Down by Factor
> ### Aliases: by.im
> ### Keywords: spatial methods manip
> 
> ### ** Examples
> 
>   W <- square(1)
>   X <- as.im(function(x,y){sqrt(x^2+y^2)}, W)
>   Y <- dirichlet(runifpoint(12, W))
>   # mean pixel value in each subset
>   unlist(by(X, Y, mean))
        1         2         3         4         5         6         7         8 
0.7883141 0.5811844 0.8952859 1.0016830 0.8686980 1.2667109 0.8681533 1.0332748 
        9        10        11        12 
1.1074023 0.2948029 0.5864375 0.3021968 
>   # trimmed mean
>   unlist(by(X, Y, mean, trim=0.05))
        1         2         3         4         5         6         7         8 
0.7860357 0.5813797 0.8955700 1.0024582 0.8697973 1.2652378 0.8682722 1.0353468 
        9        10        11        12 
1.1060773 0.2984456 0.5869780 0.3024356 
> 
> 
> 
> cleanEx()
> nameEx("by.ppp")
> ### * by.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: by.ppp
> ### Title: Apply a Function to a Point Pattern Broken Down by Factor
> ### Aliases: by.ppp
> ### Keywords: spatial methods manip
> 
> ### ** Examples
> 
>   # multitype point pattern, broken down by type
>   data(amacrine)
>   by(amacrine, FUN=density)
List of pixel images

off:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1.6012] x [0, 1] units (one unit = 662 microns)

on:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1.6012] x [0, 1] units (one unit = 662 microns)
>   by(amacrine, FUN=function(x) { min(nndist(x)) } )
off:
[1] 0.02486202

on:
[1] 0.03218897
> 
>   # how to pass additional arguments to FUN
>   by(amacrine, FUN=clarkevans, correction=c("Donnelly","cdf"))
off:
Donnelly      cdf 
1.476458 1.465373 

on:
Donnelly      cdf 
1.406853 1.427163 
> 
>   # point pattern broken down by tessellation
>   data(swedishpines)
>   tes <- quadrats(swedishpines, 5, 5)
>   B <- by(swedishpines, tes, clarkevans, correction="Donnelly")
>   unlist(lapply(B, as.numeric))
Tile row 1, col 1 Tile row 1, col 2 Tile row 1, col 3 Tile row 1, col 4 
        1.4495413         1.3213391         1.5520414         1.1359342 
Tile row 1, col 5 Tile row 2, col 1 Tile row 2, col 2 Tile row 2, col 3 
        1.0438002         1.5127638         1.0540458         0.9783123 
Tile row 2, col 4 Tile row 2, col 5 Tile row 3, col 1 Tile row 3, col 2 
        1.5135551         0.8492228         1.4987215         1.1483401 
Tile row 3, col 3 Tile row 3, col 4 Tile row 3, col 5 Tile row 4, col 1 
        1.4151330         1.1382269         1.3917248               Inf 
Tile row 4, col 2 Tile row 4, col 3 Tile row 4, col 4 Tile row 4, col 5 
              Inf         1.2424247         1.2071383         1.1262265 
Tile row 5, col 1 Tile row 5, col 2 Tile row 5, col 3 Tile row 5, col 4 
              Inf         0.9765762         1.2542389         1.5416208 
Tile row 5, col 5 
        0.4277490 
> 
> 
> 
> cleanEx()
> nameEx("cauchy.estK")
> ### * cauchy.estK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cauchy.estK
> ### Title: Fit the Neyman-Scott cluster process with Cauchy kernel
> ### Aliases: cauchy.estK
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     u <- cauchy.estK(redwood)
>     u
Minimum contrast fit (object of class "minconfit")
Model: Cauchy process
Fitted by matching theoretical K function to Kest(redwood)

Internal parameters fitted by minimum contrast ($par):
      kappa        eta2 
12.44616145  0.00845286 

Fitted cluster parameters:
      kappa       scale 
12.44616145  0.04596972 

Converged successfully after 421 function evaluations

Starting values of parameters:
kappa  eta2 
    1     4 
Domain of integration: [ 0 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u)
> 
> 
> 
> cleanEx()
> nameEx("cauchy.estpcf")
> ### * cauchy.estpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cauchy.estpcf
> ### Title: Fit the Neyman-Scott cluster process with Cauchy kernel
> ### Aliases: cauchy.estpcf
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     u <- cauchy.estpcf(redwood)
>     u
Minimum contrast fit (object of class "minconfit")
Model: Cauchy process
Fitted by matching theoretical g function to pcf(redwood)

Internal parameters fitted by minimum contrast ($par):
       kappa         eta2 
16.202533101  0.004651048 

Fitted cluster parameters:
     kappa      scale 
16.2025331  0.0340993 

Converged successfully after 221 function evaluations

Starting values of parameters:
kappa  eta2 
    1     4 
Domain of integration: [ 0.0004883 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u, legendpos="topright")
> 
> 
> 
> cleanEx()
> nameEx("cbind.hyperframe")
> ### * cbind.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cbind.hyperframe
> ### Title: Combine Hyperframes by Rows or by Columns
> ### Aliases: cbind.hyperframe rbind.hyperframe
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   lambda <- runif(5, min=10, max=30)
>   X <- lapply(as.list(lambda), function(x) { rpoispp(x) })
>   h <- hyperframe(lambda=lambda, X=X)
>   g <- hyperframe(id=letters[1:5], Y=rev(X))
>   gh <- cbind(h, g)
>   hh <- rbind(h[1:2, ], h[3:5,])
> 
> 
> 
> cleanEx()
> nameEx("cdf.test")
> ### * cdf.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cdf.test
> ### Title: Spatial Distribution Test for Point Pattern or Point Process
> ###   Model
> ### Aliases: cdf.test cdf.test.ppm cdf.test.lppm cdf.test.lpp cdf.test.ppp
> ###   cdf.test.slrm
> ### Keywords: htest spatial
> 
> ### ** Examples
> 
>    op <- options(useFancyQuotes=FALSE)
> 
>    # test of CSR using x coordinate
>    cdf.test(nztrees, "x")

	Spatial Kolmogorov-Smirnov test of CSR in two dimensions

data:  covariate 'x' evaluated at points of 'nztrees' 
     and transformed to uniform distribution under CSR
D = 0.10779, p-value = 0.2518
alternative hypothesis: two-sided

>    cdf.test(nztrees, "x", "cvm")

	Spatial Cramer-Von Mises test of CSR in two dimensions

data:  covariate 'x' evaluated at points of 'nztrees' 
     and transformed to uniform distribution under CSR
omega2 = 0.21069, p-value = 0.2479

>    cdf.test(nztrees, "x", "ad")

	Spatial Anderson-Darling test of CSR in two dimensions

data:  covariate 'x' evaluated at points of 'nztrees' 
     and transformed to uniform distribution under CSR
An = 1.6783, p-value = 0.1392

> 
>    # test of CSR using a function of x and y
>    fun <- function(x,y){2* x + y}
>    cdf.test(nztrees, fun)

	Spatial Kolmogorov-Smirnov test of CSR in two dimensions

data:  covariate 'fun' evaluated at points of 'nztrees' 
     and transformed to uniform distribution under CSR
D = 0.093606, p-value = 0.413
alternative hypothesis: two-sided

> 
>    # test of CSR using an image covariate
>    funimage <- as.im(fun, W=Window(nztrees))
>    cdf.test(nztrees, funimage)

	Spatial Kolmogorov-Smirnov test of CSR in two dimensions

data:  covariate 'funimage' evaluated at points of 'nztrees' 
     and transformed to uniform distribution under CSR
D = 0.095655, p-value = 0.3865
alternative hypothesis: two-sided

> 
>    # fit inhomogeneous Poisson model and test
>    model <- ppm(nztrees ~x)
>    cdf.test(model, "x")

	Spatial Kolmogorov-Smirnov test of inhomogeneous Poisson process in
	two dimensions

data:  covariate 'x' evaluated at points of 'nztrees' 
     and transformed to uniform distribution under 'model'
D = 0.071977, p-value = 0.7369
alternative hypothesis: two-sided

> 
>    if(interactive()) {
+      # synthetic data: nonuniform Poisson process
+      X <- rpoispp(function(x,y) { 100 * exp(x) }, win=square(1))
+ 
+      # fit uniform Poisson process
+      fit0 <- ppm(X ~1)
+      # fit correct nonuniform Poisson process
+      fit1 <- ppm(X ~x)
+ 
+      # test wrong model
+      cdf.test(fit0, "x")
+      # test right model
+      cdf.test(fit1, "x")
+    }
> 
>    # multitype point pattern
>    cdf.test(amacrine, "x")

	Spatial Kolmogorov-Smirnov test of CSR in two dimensions

data:  covariate 'x' evaluated at points of 'amacrine' 
     and transformed to uniform distribution under CSRI
D = 0.026551, p-value = 0.9857
alternative hypothesis: two-sided

>    yimage <- as.im(function(x,y){y}, W=Window(amacrine))
>    cdf.test(ppm(amacrine ~marks+y), yimage)

	Spatial Kolmogorov-Smirnov test of inhomogeneous Poisson process in
	two dimensions

data:  covariate 'yimage' evaluated at points of 'amacrine' 
     and transformed to uniform distribution under 'ppm(amacrine ~ marks + y)'
D = 0.019891, p-value = 0.9998
alternative hypothesis: two-sided

> 
>    options(op)
> 
> 
> 
> cleanEx()
> nameEx("cdf.test.mppm")
> ### * cdf.test.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cdf.test.mppm
> ### Title: Spatial Distribution Test for Multiple Point Process Model
> ### Aliases: cdf.test.mppm
> ### Keywords: htest spatial
> 
> ### ** Examples
> 
>    # three i.i.d. realisations of nonuniform Poisson process
>    lambda <- as.im(function(x,y) { 300 * exp(x) }, square(1))
>    dat <- hyperframe(X=list(rpoispp(lambda), rpoispp(lambda), rpoispp(lambda)))
> 
>    # fit uniform Poisson process
>    fit0 <- mppm(X~1, dat)
>    # fit correct nonuniform Poisson process
>    fit1 <- mppm(X~x, dat)
> 
>    # test wrong model
>    cdf.test(fit0, "x")

	Spatial Kolmogorov-Smirnov test

data:  predicted cdf of covariate '"x"' evaluated at data points of 'fit0'
D = 0.15081, p-value < 2.2e-16
alternative hypothesis: two-sided

>    # test right model
>    cdf.test(fit1, "x")

	Spatial Kolmogorov-Smirnov test

data:  predicted cdf of covariate '"x"' evaluated at data points of 'fit1'
D = 0.027466, p-value = 0.1986
alternative hypothesis: two-sided

> 
>    # Gibbs model
>    fitGibbs <- update(fit0, interaction=Strauss(0.07))
>    ns <- if(interactive()) 19 else 3
>    cdf.test(fitGibbs, "x", nsim=ns)
Generating simulated realisations of 3 models..
1, 2,  3.
Processing ...1, 2,  3.

	Monte Carlo test of fitted Gibbs model
	based on 3 repetitions of
	spatial Kolmogorov-Smirnov test

data:  predicted cdf of covariate '"x"' evaluated at data points of 'fitGibbs'
D = 0.15081, p-value < 2.2e-16
alternative hypothesis: two-sided

> 
> 
> 
> cleanEx()
> nameEx("centroid.owin")
> ### * centroid.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centroid.owin
> ### Title: Centroid of a window
> ### Aliases: centroid.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   w <- owin(c(0,1),c(0,1))
>   centroid.owin(w)
$x
[1] 0.5

$y
[1] 0.5

>   # returns 0.5, 0.5
> 
>   data(demopat)
>   w <- Window(demopat)
>   # an irregular window
>   cent <- centroid.owin(w, as.ppp = TRUE)
>   ## Not run: 
> ##D   plot(cent)
> ##D   # plot the window and its centroid
> ##D   
> ## End(Not run)
> 
>   wapprox <- as.mask(w)
>   # pixel approximation of window
>   ## Not run: 
> ##D   points(centroid.owin(wapprox))
> ##D   # should be indistinguishable 
> ##D   
> ## End(Not run)
>   ## Don't show: 
>   centroid.owin(w)
$x
[1] 5733.019

$y
[1] 3634.136

>   centroid.owin(wapprox)
$x
[1] 5732.869

$y
[1] 3635.135

>   
> ## End(Don't show)	
> 
> 
> 
> cleanEx()
> nameEx("chop.linnet")
> ### * chop.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chop.linnet
> ### Title: Divide a Linear Network into Tiles Using Infinite Lines
> ### Aliases: chop.linnet
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    L <- infline(p=runif(3), theta=runif(3, max=pi/2))
>    Y <- chop.linnet(simplenet, L)
>    plot(Y, main="")
>    plot(L, col="red")
> 
> 
> 
> cleanEx()
> nameEx("chop.tess")
> ### * chop.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chop.tess
> ### Title: Subdivide a Window or Tessellation using a Set of Lines
> ### Aliases: chop.tess
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   L <- infline(p=1:3, theta=pi/4)
>   W <- square(4)
>   chop.tess(W, L)
Tessellation
Tiles are windows of general type
4 tiles (irregular windows)
window: rectangle = [0, 4] x [0, 4] units
> 
> 
> 
> cleanEx()
> nameEx("circdensity")
> ### * circdensity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: circdensity
> ### Title: Density Estimation for Circular Data
> ### Aliases: circdensity
> ### Keywords: nonparametric smooth
> 
> ### ** Examples
> 
>   ang <- runif(1000, max=360)
>   rose(circdensity(ang, 12))
> 
> 
> 
> cleanEx()
> nameEx("clarkevans")
> ### * clarkevans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clarkevans
> ### Title: Clark and Evans Aggregation Index
> ### Aliases: clarkevans
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   # Example of a clustered pattern
>   clarkevans(redwood)
    naive  Donnelly       cdf 
0.6186502 0.5849906 0.5835880 
> 
>   # Example of an ordered pattern
>   clarkevans(cells)
   naive Donnelly      cdf 
1.671680 1.560426 1.624456 
> 
>   # Random pattern
>   X <- rpoispp(100)
>   clarkevans(X)
   naive Donnelly      cdf 
1.151661 1.100821 1.075840 
> 
>   # How to specify a clipping region
>   clip1 <- owin(c(0.1,0.9),c(0.1,0.9))
>   clip2 <- erosion(Window(cells), 0.1)
>   clarkevans(cells, clipregion=clip1)
   naive Donnelly    guard      cdf 
1.671680 1.560426 1.640094 1.624456 
>   clarkevans(cells, clipregion=clip2)
   naive Donnelly    guard      cdf 
1.671680 1.560426 1.640094 1.624456 
> 
> 
> 
> cleanEx()
> nameEx("clarkevans.test")
> ### * clarkevans.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clarkevans.test
> ### Title: Clark and Evans Test
> ### Aliases: clarkevans.test
> ### Keywords: spatial nonparametric htest
> 
> ### ** Examples
> 
>   # Redwood data - clustered
>   clarkevans.test(redwood)

	Clark-Evans test
	No edge correction
	Z-test

data:  redwood
R = 0.61865, p-value = 9.223e-09
alternative hypothesis: two-sided

>   clarkevans.test(redwood, alternative="clustered")

	Clark-Evans test
	No edge correction
	Z-test

data:  redwood
R = 0.61865, p-value = 4.611e-09
alternative hypothesis: clustered (R < 1)

>   clarkevans.test(redwood, correction="cdf", nsim=39)

	Clark-Evans test
	CDF correction
	Monte Carlo test based on 39 simulations of CSR with fixed n

data:  redwood
R = 0.58359, p-value = 0.05
alternative hypothesis: two-sided

> 
> 
> 
> cleanEx()
> nameEx("clip.infline")
> ### * clip.infline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clip.infline
> ### Title: Intersect Infinite Straight Lines with a Window
> ### Aliases: clip.infline
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   L <- infline(p=1:3, theta=pi/4)
>   W <- square(4)
>   clip.infline(L, W)
marked planar line segment pattern: 3 line segments
multitype, with levels = 1	2	3
window: rectangle = [0, 4] x [0, 4] units
> 
> 
> 
> cleanEx()
> nameEx("closepairs")
> ### * closepairs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: closepairs
> ### Title: Close Pairs of Points
> ### Aliases: closepairs crosspairs closepairs.ppp crosspairs.ppp
> ###   closepaircounts crosspaircounts
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    a <- closepaircounts(cells, 0.1)
>    sum(a)
[1] 2
> 
>    Y <- split(amacrine)
>    b <- crosspaircounts(Y$on, Y$off, 0.1)
> 
>    d <- closepairs(cells, 0.1)
>    e <- crosspairs(Y$on, Y$off, 0.1)
> 
> 
> 
> cleanEx()
> nameEx("closepairs.pp3")
> ### * closepairs.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: closepairs.pp3
> ### Title: Close Pairs of Points in 3 Dimensions
> ### Aliases: closepairs.pp3 crosspairs.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- pp3(runif(10), runif(10), runif(10), box3(c(0,1)))
>    Y <- pp3(runif(10), runif(10), runif(10), box3(c(0,1)))
>    a <- closepairs(X, 0.1)
>    b <- crosspairs(X, Y, 0.1)
> 
> 
> 
> cleanEx()
> nameEx("closetriples")
> ### * closetriples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: closetriples
> ### Title: Close Triples of Points
> ### Aliases: closetriples
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    closetriples(redwoodfull, 0.02)
     i   j   k       diam
1  119 121 125 0.01698335
2  122 124 127 0.01706880
3  122 124 129 0.01898554
4  122 127 129 0.01898554
5  124 127 129 0.01706880
6  124 128 129 0.01755853
7  149 151 153 0.01657459
8  156 157 158 0.01698335
9  164 165 166 0.01649030
10 174 175 179 0.01701892
>    closetriples(redwoodfull, 0.005)
[1] i    j    k    diam
<0 rows> (or 0-length row.names)
> 
> 
> 
> cleanEx()
> nameEx("closing")
> ### * closing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: closing
> ### Title: Morphological Closing
> ### Aliases: closing closing.owin closing.ppp closing.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   v <- closing(letterR, 0.25)
>   plot(v, main="closing")
>   plot(letterR, add=TRUE)
> 
>   plot(closing(cells, 0.1))
>   points(cells)
> 
> 
> 
> cleanEx()
> nameEx("clusterfield")
> ### * clusterfield
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clusterfield
> ### Title: Field of clusters
> ### Aliases: clusterfield clusterfield.character clusterfield.function
> ###   clusterfield.kppm
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   # method for fitted model
>   fit <- kppm(redwood~1, "Thomas")
>   clusterfield(fit, eps = 0.01)
real-valued pixel image
100 x 100 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [-1, 0] units
> 
>   # method for functions
>   kernel <- function(x,y,scal) { 
+       r <- sqrt(x^2 + y^2)
+       ifelse(r > 0,
+              dgamma(r, shape=5, scale=scal)/(2 * pi * r),
+              0)               
+   }
>   X <- runifpoint(10)
>   clusterfield(kernel, X, scal=0.05)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("clusterfit")
> ### * clusterfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clusterfit
> ### Title: Fit Cluster or Cox Point Process Model via Minimum Contrast
> ### Aliases: clusterfit
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- clusterfit(redwood, "Thomas")
>   fit
Minimum contrast fit (object of class "minconfit")
Model: Thomas process
Fitted by matching theoretical K function to redwood

Internal parameters fitted by minimum contrast ($par):
       kappa       sigma2 
23.551144930  0.002213335 

Fitted cluster parameters:
     kappa      scale 
23.5511449  0.0470461 
Mean cluster size:  2.632568 points

Converged successfully after 95 function evaluations

Starting values of parameters:
       kappa       sigma2 
62.000000000  0.006173033 
Domain of integration: [ 0 , 0.25 ]
Exponents: p= 2, q= 0.25
>   if(interactive()){
+     plot(fit)
+   }
>   K <- Kest(redwood)
>   fit2 <- clusterfit(K, "MatClust")
> 
> 
> 
> cleanEx()
> nameEx("clusterkernel")
> ### * clusterkernel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clusterkernel
> ### Title: Extract Cluster Offspring Kernel
> ### Aliases: clusterkernel clusterkernel.character clusterkernel.kppm
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   fit <- kppm(redwood ~ x, "MatClust")
>   f <- clusterkernel(fit)
>   f(0.1, 0.2)
[1] 0
> 
> 
> 
> cleanEx()
> nameEx("clusterradius")
> ### * clusterradius
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clusterradius
> ### Title: Compute or Extract Effective Range of Cluster Kernel
> ### Aliases: clusterradius clusterradius.character clusterradius.kppm
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   fit <- kppm(redwood ~ x, "MatClust")
>   clusterradius(fit)
[1] 0.08525192
> 
>   clusterradius("Thomas", scale = .1)
[1] 0.4
>   clusterradius("Thomas", scale = .1, thresh = 0.001)
[1] 0.3716922
>   clusterradius("VarGamma", scale = .1, nu = 2, precision = TRUE)
[1] 1.152894
attr(,"prec")
0.999 with absolute error < 2.4e-06
> 
> 
> 
> cleanEx()
> nameEx("clusterset")
> ### * clusterset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clusterset
> ### Title: Allard-Fraley Estimator of Cluster Feature
> ### Aliases: clusterset
> ### Keywords: spatial classif
> 
> ### ** Examples
> 
>   opa <- par(mfrow=c(1,2))
>   W <- grow.rectangle(as.rectangle(letterR), 1)
>   X <- superimpose(runifpoint(300, letterR),
+                    runifpoint(50, W), W=W)
>   plot(W, main="clusterset(X, 'm')")
>   plot(clusterset(X, "marks", fast=TRUE), add=TRUE, chars=c(1, 3), cols=1:2)
Computing Dirichlet tessellation...done.
>   plot(letterR, add=TRUE)
>   plot(W, main="clusterset(X, 'd')")
>   plot(clusterset(X, "domain", exact=FALSE), add=TRUE)
Computing Dirichlet tessellation...done.
Computing cluster set...done.
>   plot(letterR, add=TRUE)
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("coef.mppm")
> ### * coef.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coef.mppm
> ### Title: Coefficients of Point Process Model Fitted to Multiple Point
> ###   Patterns
> ### Aliases: coef.mppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>     H <- hyperframe(X=waterstriders)
> 
>     fit.Poisson <- mppm(X ~ 1, H)
>     coef(fit.Poisson)
(Intercept) 
  -4.131233 
> 
>     # The single entry "(Intercept)" 
>     # is the log of the fitted intensity of the Poisson process
> 
>     fit.Strauss <- mppm(X~1, H, Strauss(7))
>     coef(fit.Strauss)
(Intercept) Interaction 
 -3.6409797  -0.2497379 
> 
>     # The two entries "(Intercept)" and "Interaction"
>     # are respectively log(beta) and log(gamma)
>     # in the usual notation for Strauss(beta, gamma, r)
> 
>     # Tweak data to exaggerate differences
>     H$X[[1]] <- rthin(H$X[[1]], 0.3)
>     # Model with random effects
>     fitran <- mppm(X ~ 1, H, random=~1|id)
iteration 1 
iteration 2 
iteration 3 
>     coef(fitran)
  (Intercept)
1   -4.880200
2   -4.258643
3   -4.185686
> 
> 
> 
> cleanEx()
> nameEx("coef.ppm")
> ### * coef.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coef.ppm
> ### Title: Coefficients of Fitted Point Process Model
> ### Aliases: coef.ppm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>     data(cells)
> 
>     poi <- ppm(cells, ~1, Poisson())
>     coef(poi)
log(lambda) 
    3.73767 
>     # This is the log of the fitted intensity of the Poisson process
> 
>     stra <- ppm(cells, ~1, Strauss(r=0.07))
>     coef(stra)
(Intercept) Interaction 
   4.794977  -19.289520 
> 
>     # The two entries "(Intercept)" and "Interaction"
>     # are respectively log(beta) and log(gamma)
>     # in the usual notation for Strauss(beta, gamma, r)
> 
> 
> 
> 
> cleanEx()
> nameEx("coef.slrm")
> ### * coef.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coef.slrm
> ### Title: Coefficients of Fitted Spatial Logistic Regression Model
> ### Aliases: coef.slrm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>   X <- rpoispp(42)
>   fit <- slrm(X ~ x+y)
>   coef(fit)
(Intercept)           x           y 
  3.3271106   0.2833402   0.2758334 
> 
> 
> 
> cleanEx()
> nameEx("collapse.fv")
> ### * collapse.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: collapse.fv
> ### Title: Collapse Several Function Tables into One
> ### Aliases: collapse.fv collapse.anylist
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # generate simulated data
>   X <- replicate(3, rpoispp(100), simplify=FALSE)
>   names(X) <- paste("Simulation", 1:3)
>   # compute K function estimates
>   Klist <- anylapply(X, Kest)
>   # collapse
>   K <- collapse(Klist, same="theo", different="iso")
>   K
Function value object (class 'fv')
for the function r -> K(r)
................................................................................
             Math.label                
r            r                         
theo         K[pois](r)                
Simulation 1 Simulation1~hat(K)[iso](r)
Simulation 2 Simulation2~hat(K)[iso](r)
Simulation 3 Simulation3~hat(K)[iso](r)
             Description                                      
r            distance argument r                              
theo         theoretical Poisson K(r)                         
Simulation 1 Simulation 1 isotropic-corrected estimate of K(r)
Simulation 2 Simulation 2 isotropic-corrected estimate of K(r)
Simulation 3 Simulation 3 isotropic-corrected estimate of K(r)
................................................................................
Default plot formula:  .~.x
where "." stands for 'theo', 'Simulation 1', 'Simulation 2', 'Simulation 3'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
> 
> 
> cleanEx()
> nameEx("colourmap")
> ### * colourmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colourmap
> ### Title: Colour Lookup Tables
> ### Aliases: colourmap
> ### Keywords: spatial color
> 
> ### ** Examples
> 
>   # colour map for real numbers, using breakpoints
>   cr <- colourmap(c("red", "blue", "green"), breaks=c(0,5,10,15))
>   cr
Colour map for the range [0, 15] 
  interval colour
1   [0, 5)    red
2  [5, 10)   blue
3 [10, 15]  green
>   cr(3.2)
[1] "red"
>   cr(c(3,5,7))
[1] "red"  "blue" "blue"
>   # a large colour map
>   co <- colourmap(rainbow(100), range=c(-1,1))
>   co(0.2)
[1] "#0066FF"
>   # colour map for discrete set of values
>   ct <- colourmap(c("red", "green"), inputs=c(FALSE, TRUE))
>   ct(TRUE)
[1] "green"
> 
> 
> 
> cleanEx()
> nameEx("colouroutputs")
> ### * colouroutputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colouroutputs
> ### Title: Extract or Assign Colour Values in a Colour Map
> ### Aliases: colouroutputs colouroutputs<-
> ### Keywords: spatial color
> 
> ### ** Examples
> 
>   m <- colourmap(rainbow(5), range=c(0,1))
>   m
Colour map for the range [0, 1] 
    interval  colour
1   [0, 0.2) #FF0000
2 [0.2, 0.4) #CCFF00
3 [0.4, 0.6) #00FF66
4 [0.6, 0.8) #0066FF
5   [0.8, 1] #CC00FF
>   # reverse order of colours
>   colouroutputs(m) <- rev(colouroutputs(m))
>   m
Colour map for the range [0, 1] 
    interval  colour
1   [0, 0.2) #CC00FF
2 [0.2, 0.4) #0066FF
3 [0.4, 0.6) #00FF66
4 [0.6, 0.8) #CCFF00
5   [0.8, 1] #FF0000
> 
> 
> 
> cleanEx()
> nameEx("colourtools")
> ### * colourtools
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colourtools
> ### Title: Convert and Compare Colours in Different Formats
> ### Aliases: colourtools paletteindex rgb2hex rgb2hsva col2hex paletteindex
> ###   samecolour complementarycolour interp.colours is.colour is.grey
> ###   to.grey to.opaque to.transparent to.saturated
> ### Keywords: color
> 
> ### ** Examples
> 
>   samecolour("grey", "gray")
[1] TRUE
>   paletteindex("grey")
[1] NA
>   col2hex("orange")
[1] "#FFA500"
>   to.grey("orange")
[1] "#ADADAD"
>   to.saturated("orange")
[1] "#FFA500"
>   complementarycolour("orange")
[1] "#005AFF"
>   is.grey("lightgrey")
[1] TRUE
>   is.grey(8)
[1] TRUE
>   to.transparent("orange", 0.5)
[1] "#FFA50080"
>   to.opaque("red")
[1] "#FF0000"
>   interp.colours(c("orange", "red", "violet"), 5)
[1] "#FF8500" "#FF4100" "#FF0000" "#F83682" "#F169D9"
> 
> 
> 
> cleanEx()
> nameEx("commonGrid")
> ### * commonGrid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: commonGrid
> ### Title: Determine A Common Spatial Domain And Pixel Resolution
> ### Aliases: commonGrid
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    A <- setcov(square(1))
>    G <- density(runifpoint(42), dimyx=16)
>    H <- commonGrid(A, letterR, G)
>    newR <- as.mask(letterR, xy=H)
>    newG <- as.im(G, W=H)
> 
> 
> 
> cleanEx()
> nameEx("compareFit")
> ### * compareFit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compareFit
> ### Title: Residual Diagnostics for Multiple Fitted Models
> ### Aliases: compareFit
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    nd <- 40
>    ## Don't show: 
>         nd <- 10
>    
> ## End(Don't show)
>    ilist <- list(Poisson(), Geyer(7, 2), Strauss(7))
>    iname <- c("Poisson", "Geyer", "Strauss")
>    ## Don't show: 
>       ilist <- ilist[c(1,3)]
>       iname <- iname[c(1,3)]
>    
> ## End(Don't show)
>    K <- compareFit(swedishpines, Kcom, interaction=ilist, rbord=9,
+             correction="translate",
+             same="trans", different="tcom", modelnames=iname, nd=nd)
>    K
Function value object (class 'fv')
for the function r -> K(r)
................................................................................
        Math.label                      
r       r                               
trans   hat(K)[trans](r)                
Poisson Poisson~bold(C)~hat(K)[trans](r)
Strauss Strauss~bold(C)~hat(K)[trans](r)
        Description                                                       
r       distance argument r                                               
trans   classical translation-corrected nonparametric estimate of K(r)    
Poisson Poisson model compensator of classical translation-corrected K(r) 
Strauss Strauss model compensator of reweighted translation-corrected K(r)
................................................................................
Default plot formula:  .~.x
where "." stands for 'trans', 'Poisson', 'Strauss'
Recommended range of argument r: [0, 24]
Available range of argument r: [0, 24]
Unit of length: 0.1 metres
> 
> 
> 
> cleanEx()
> nameEx("compileK")
> ### * compileK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compileK
> ### Title: Generic Calculation of K Function and Pair Correlation Function
> ### Aliases: compileK compilepcf
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- japanesepines
>   D <- pairdist(X)
>   Wt <- edge.Ripley(X, D)
>   lambda <- intensity(X)
>   a <- (npoints(X)-1) * lambda
>   r <- seq(0, 0.25, by=0.01)
>   K <- compileK(D=D, r=r, weights=Wt, denom=a)
>   g <- compilepcf(D=D, r=r, weights=Wt, denom= a * 2 * pi * r)
> 
> 
> 
> cleanEx()
> nameEx("complement.owin")
> ### * complement.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complement.owin
> ### Title: Take Complement of a Window
> ### Aliases: complement.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    # rectangular
>    a <- owin(c(0,1),c(0,1))
>    b <- owin(c(-1,2),c(-1,2))
>    bmina <- complement.owin(a, frame=b)
>    # polygonal
>    data(demopat)
>    w <- Window(demopat)
>    outside <- complement.owin(w)
>    # mask
>    w <- as.mask(Window(demopat))
>    outside <- complement.owin(w)
> 
> 
> 
> cleanEx()
> nameEx("concatxy")
> ### * concatxy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: concatxy
> ### Title: Concatenate x,y Coordinate Vectors
> ### Aliases: concatxy
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   dat <- runifrect(30)
>   xy <- list(x=runif(10),y=runif(10))
>   new <- concatxy(dat, xy)
> 
> 
> 
> cleanEx()
> nameEx("connected")
> ### * connected
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: connected
> ### Title: Connected components
> ### Aliases: connected connected.im connected.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   d <- distmap(cells, dimyx=256)
>   X <- levelset(d, 0.07)
>   plot(X)
>   Z <- connected(X)
>   plot(Z)
Interpreting pixel values as colours (valuesAreColours=TRUE)
>   # or equivalently
>   Z <- connected(d <= 0.07)
> 
>   # number of components
>   nc <- length(levels(Z))
>   # plot with randomised colour map
>   plot(Z, col=hsv(h=sample(seq(0,1,length=nc), nc)))
> 
>   # how to extract the components as a list of windows
>   W <- tiles(tess(image=Z))
> 
> 
> 
> cleanEx()
> nameEx("connected.linnet")
> ### * connected.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: connected.linnet
> ### Title: Connected Components of a Linear Network
> ### Aliases: connected.linnet
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    # remove some edges from a network to make it disconnected
>    plot(simplenet, col="grey", main="", lty=2)
>    A <- thinNetwork(simplenet, retainedges=-c(3,5))
>    plot(A, add=TRUE, lwd=2)
>    # find the connected components
>    connected(A)
 [1] 1 2 1 1 2 2 2 2 2 2
Levels: 1 2
>    cA <- connected(A, what="components")
>    plot(cA[[1]], add=TRUE, col="green", lwd=2)
>    plot(cA[[2]], add=TRUE, col="blue", lwd=2)
> 
> 
> 
> cleanEx()
> nameEx("connected.lpp")
> ### * connected.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: connected.lpp
> ### Title: Connected Components of a Point Pattern on a Linear Network
> ### Aliases: connected.lpp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    ## behaviour like connected.ppp
>    U <- runiflpp(20, simplenet)
>    plot(connected(U, 0.15, dismantle=FALSE))
> 
>    ## behaviour like connected.owin
>    ## remove some edges from a network to make it disconnected
>    plot(simplenet, col="grey", main="", lty=2)
>    A <- thinNetwork(simplenet, retainedges=-c(3,5))
>    plot(A, add=TRUE, lwd=2)
>    X <- runiflpp(10, A)
>    ## find the connected components
>    cX <- connected(X)
>    plot(cX[[1]], add=TRUE, col="blue", lwd=2)
> 
> 
> 
> cleanEx()
> nameEx("connected.ppp")
> ### * connected.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: connected.ppp
> ### Title: Connected Components of a Point Pattern
> ### Aliases: connected.ppp connected.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    Y <- connected(redwoodfull, 0.1)
>    if(interactive()) {
+     plot(Y, cols=1:length(levels(marks(Y))),
+          main="connected(redwoodfull, 0.1)")
+    }
>    X <- osteo$pts[[1]]
>    Z <- connected(X, 32)
>    if(interactive()) {
+     plot(Z, col=marks(Z), main="")
+    }
> 
> 
> 
> cleanEx()
> nameEx("connected.tess")
> ### * connected.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: connected.tess
> ### Title: Connected Components of Tiles of a Tessellation
> ### Aliases: connected.tess
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   BB <- grow.rectangle(Frame(letterR), 0.2)
>   H <- tess(tiles=list(IN=letterR, OUT=complement.owin(letterR, BB)))
>   opa <- par(mfrow=c(1,2))
>   plot(H, do.col=TRUE)
>   plot(connected(H), do.col=TRUE, col=2:4)
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("contour.im")
> ### * contour.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contour.im
> ### Title: Contour plot of pixel image
> ### Aliases: contour.im
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    # an image
>    Z <- setcov(owin())
>    contour(Z, axes=TRUE)
>    contour(Z)
> 
>    co <- colourmap(rainbow(100), range=c(0,1))
>    contour(Z, col=co, lwd=2)
> 
> 
> 
> cleanEx()
> nameEx("contour.imlist")
> ### * contour.imlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contour.imlist
> ### Title: Array of Contour Plots
> ### Aliases: contour.imlist contour.listof
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
> # Multitype point pattern
>  contour(D <- density(split(amacrine)))
> 
> 
> 
> cleanEx()
> nameEx("convexhull")
> ### * convexhull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convexhull
> ### Title: Convex Hull
> ### Aliases: convexhull
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>    data(demopat)
>    W <- Window(demopat)
>    plot(convexhull(W), col="lightblue", border=NA)
>    plot(W, add=TRUE, lwd=2)
> 
> 
> 
> cleanEx()
> nameEx("convexhull.xy")
> ### * convexhull.xy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convexhull.xy
> ### Title: Convex Hull of Points
> ### Aliases: convexhull.xy
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>   x <- runif(30)
>   y <- runif(30)
>   w <- convexhull.xy(x,y)
>   plot(owin(), main="convexhull.xy(x,y)", lty=2)
>   plot(w, add=TRUE)
>   points(x,y)
> 
>   X <- rpoispp(30)
>   plot(X, main="convexhull.xy(X)")
>   plot(convexhull.xy(X), add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("convexify")
> ### * convexify
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convexify
> ### Title: Weil's Convexifying Operation
> ### Aliases: convexify
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>   opa <- par(mfrow=c(1,2))
>   plot(letterR)
>   plot(convexify(letterR))
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("convolve.im")
> ### * convolve.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convolve.im
> ### Title: Convolution of Pixel Images
> ### Aliases: convolve.im
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- as.im(letterR)
>   Y <- as.im(square(1))
>   plot(convolve.im(X, Y))
>   plot(convolve.im(X, Y, reflectX=TRUE))
>   plot(convolve.im(X))
> 
> 
> 
> cleanEx()
> nameEx("coords")
> ### * coords
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coords
> ### Title: Extract or Change Coordinates of a Spatial or Spatiotemporal
> ###   Point Pattern
> ### Aliases: coords coords.ppp coords.ppx coords.quad coords<- coords<-.ppp
> ###   coords<-.ppx
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(4),y=runif(4),t=runif(4))
>    X <- ppx(data=df, coord.type=c("s","s","t"))
>    coords(X)
          x         y          t
1 0.2655087 0.2016819 0.62911404
2 0.3721239 0.8983897 0.06178627
3 0.5728534 0.9446753 0.20597457
4 0.9082078 0.6607978 0.17655675
>    coords(X, temporal=FALSE)
          x         y
1 0.2655087 0.2016819
2 0.3721239 0.8983897
3 0.5728534 0.9446753
4 0.9082078 0.6607978
>    coords(X) <- matrix(runif(12), ncol=3)
> 
> 
> 
> cleanEx()
> nameEx("corners")
> ### * corners
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: corners
> ### Title: Corners of a rectangle
> ### Aliases: corners
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>   w <- unit.square()
>   corners(w)
$x
[1] 0 1 0 1

$y
[1] 0 0 1 1

>        # returns list(x=c(0,1,0,1),y=c(0,0,1,1))
> 
> 
> 
> cleanEx()
> nameEx("covering")
> ### * covering
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: covering
> ### Title: Cover Region with Discs
> ### Aliases: covering
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   rr <- 0.5
>   X <- covering(letterR, rr)
>   plot(grow.rectangle(Frame(X), rr), type="n", main="")
>   plot(X, pch=16, add=TRUE, col="red")
>   plot(letterR, add=TRUE, lwd=3)
>   plot(X %mark% (2*rr), add=TRUE, markscale=1)
> 
> 
> 
> cleanEx()
> nameEx("crossdist.default")
> ### * crossdist.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossdist.default
> ### Title: Pairwise distances between two different sets of points
> ### Aliases: crossdist.default
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    d <- crossdist(runif(7), runif(7), runif(12), runif(12))
>    d <- crossdist(runif(7), runif(7), runif(12), runif(12), period=c(1,1))
> 
> 
> 
> cleanEx()
> nameEx("crossdist.lpp")
> ### * crossdist.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossdist.lpp
> ### Title: Pairwise distances between two point patterns on a linear
> ###   network
> ### Aliases: crossdist.lpp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    v <- split(chicago)
>    X <- v$cartheft
>    Y <- v$burglary
>    d <- crossdist(X, Y)
>    d[1:3,1:4]
         [,1]     [,2]     [,3]     [,4]
[1,] 321.3258  798.966 331.4800 330.1418
[2,] 459.1331 1009.243 490.4228 489.0846
[3,] 547.0757  813.956 241.0413 239.7031
> 
> 
> 
> cleanEx()
> nameEx("crossdist.pp3")
> ### * crossdist.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossdist.pp3
> ### Title: Pairwise distances between two different three-dimensional point
> ###   patterns
> ### Aliases: crossdist.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- runifpoint3(20)
>    Y <- runifpoint3(30)
>    d <- crossdist(X, Y)
>    d <- crossdist(X, Y, periodic=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("crossdist.ppp")
> ### * crossdist.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossdist.ppp
> ### Title: Pairwise distances between two different point patterns
> ### Aliases: crossdist.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(cells)
>    d <- crossdist(cells, runifpoint(6))
>    d <- crossdist(cells, runifpoint(6), periodic=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("crossdist.ppx")
> ### * crossdist.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossdist.ppx
> ### Title: Pairwise Distances Between Two Different Multi-Dimensional Point
> ###   Patterns
> ### Aliases: crossdist.ppx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(3),y=runif(3),z=runif(3),w=runif(3))
>    X <- ppx(data=df)
>    df <- data.frame(x=runif(5),y=runif(5),z=runif(5),w=runif(5))
>    Y <- ppx(data=df)
>    d <- crossdist(X, Y)
> 
> 
> 
> cleanEx()
> nameEx("crossdist.psp")
> ### * crossdist.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossdist.psp
> ### Title: Pairwise distances between two different line segment patterns
> ### Aliases: crossdist.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    L1 <- psp(runif(5), runif(5), runif(5), runif(5), owin())
>    L2 <- psp(runif(10), runif(10), runif(10), runif(10), owin())
>    D <- crossdist(L1, L2)
>    #result is a 5 x 10 matrix
>    S <- crossdist(L1, L2, type="sep")
> 
> 
> 
> cleanEx()
> nameEx("crossing.linnet")
> ### * crossing.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossing.linnet
> ### Title: Crossing Points between Linear Network and Other Lines
> ### Aliases: crossing.linnet
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    plot(simplenet, main="")
>    L <- infline(p=runif(3), theta=runif(3, max=pi/2))
>    plot(L, col="red")
>    Y <- crossing.linnet(simplenet, L)
>    plot(Y, add=TRUE, cols="blue")
> 
> 
> 
> cleanEx()
> nameEx("crossing.psp")
> ### * crossing.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossing.psp
> ### Title: Crossing Points of Two Line Segment Patterns
> ### Aliases: crossing.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   b <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(a, col="green", main="crossing.psp")
>   plot(b, add=TRUE, col="blue")
>   P <- crossing.psp(a,b)
>   plot(P, add=TRUE, col="red")
>   as.data.frame(crossing.psp(a,b,details=TRUE))
           x         y iA jB         tA         tB
1  0.8430726 0.4442732  1  1 0.86307068 0.24068746
2  0.8866187 0.3786451  4  1 0.02758455 0.71437656
3  0.6190915 0.8594869  8  2 0.14980182 0.07912905
4  0.6418905 0.3982870  9  3 0.05310767 0.43549429
5  0.4552143 0.2842457  1  4 0.28348273 0.44335232
6  0.4775841 0.2752247  4  4 0.55021043 0.34196717
7  0.4398650 0.2904356  8  4 0.79355234 0.51291903
8  0.6129334 0.3493194  1  5 0.51916694 0.68686096
9  0.6000531 0.3061898  4  5 0.39373114 0.58054446
10 0.6199487 0.3522139  1  6 0.52965004 0.31883117
11 0.6434436 0.3171607  4  6 0.33829084 0.27461292
12 0.4142660 0.6590823  6  6 0.94504546 0.70593341
13 0.3417843 0.7672213  7  6 0.64737537 0.84234644
14 0.5106717 0.5152497  8  6 0.53922697 0.52449433
15 0.2266872 0.5611079  2  7 0.90908494 0.44672619
16 0.3942926 0.7629012  7  7 0.59099273 0.81491650
17 0.2265185 0.5609047 10  7 0.59136477 0.44635541
18 0.7399440 0.4017231  1  8 0.70896257 0.90879123
19 0.5074957 0.5051657  8  8 0.55063472 0.10469608
20 0.6670144 0.4341777  9  8 0.15753955 0.65651011
21 0.5662026 0.6915625  8  9 0.33976958 0.25631792
22 0.7400906 0.5504684  6 10 0.30901156 0.25937405
23 0.7991495 0.7295916  7 10 0.15626346 0.58282511
24 0.7326750 0.5279771  9 10 0.43046932 0.21876044
> 
> 
> 
> cleanEx()
> nameEx("cut.im")
> ### * cut.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut.im
> ### Title: Convert Pixel Image from Numeric to Factor
> ### Aliases: cut.im
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   # artificial image data
>   Z <- setcov(square(1))
> 
>   Y <- cut(Z, 3)
>   Y <- cut(Z, breaks=seq(0,1,length=5))
> 
>   # cut at the quartiles
>   # (divides the image into 4 equal areas)
>   Y <- cut(Z, quantile(Z))
> 
> 
> 
> cleanEx()
> nameEx("cut.lpp")
> ### * cut.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut.lpp
> ### Title: Classify Points in a Point Pattern on a Network
> ### Aliases: cut.lpp
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   X <- runiflpp(20, simplenet)
>   f <- linfun(function(x,y,seg,tp) { x }, simplenet)
>   plot(cut(X, f, breaks=4))
>   plot(cut(X, "x", breaks=4))
>   plot(cut(X, "seg"))
> 
> 
> 
> cleanEx()
> nameEx("cut.ppp")
> ### * cut.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut.ppp
> ### Title: Classify Points in a Point Pattern
> ### Aliases: cut.ppp
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>  # (1) cutting based on numeric marks of point pattern
>  
>  trees <- longleaf
>  # Longleaf Pines data
>  # the marks are positive real numbers indicating tree diameters.
> 
>  ## Don't show: 
> 	# smaller dataset
> 	trees <- trees[seq(1, npoints(trees), by=80)]
>  
> ## End(Don't show)
>  ## Not run: 
> ##D  plot(trees)
> ##D  
> ## End(Not run)
> 
>  # cut the range of tree diameters into three intervals
>  long3 <- cut(trees, breaks=3)
>  ## Not run: 
> ##D  plot(long3)
> ##D  
> ## End(Not run)
> 
>  # adult trees defined to have diameter at least 30 cm
>  long2 <- cut(trees, breaks=c(0,30,100), labels=c("Sapling", "Adult"))
>  plot(long2)
>  plot(long2, cols=c("green","blue"))
> 
>  # (2) cutting based on another numeric vector
>  # Divide Swedish Pines data into 3 classes
>  # according to nearest neighbour distance
> 
>  swedishpines
Planar point pattern: 71 points
window: rectangle = [0, 96] x [0, 100] units (one unit = 0.1 metres)
>  plot(cut(swedishpines, nndist(swedishpines), breaks=3))
> 
>  # (3) cutting based on tessellation
>  # Divide Swedish Pines study region into a 4 x 4 grid of rectangles
>  # and classify points accordingly
> 
>  tes <- tess(xgrid=seq(0,96,length=5),ygrid=seq(0,100,length=5))
>  plot(cut(swedishpines, tes))
>  plot(tes, lty=2, add=TRUE)
> 
>  # (4) inside/outside a given region
>  with(murchison, cut(gold, greenstone))
Marked planar point pattern: 255 points
Multitype, with levels = FALSE, TRUE 
window: rectangle = [352782.9, 682589.6] x [6699742, 7101484] metres
> 
>  # (5) multivariate marks
>  finpines
Marked planar point pattern: 126 points
Mark variables: diameter, height 
window: rectangle = [-5, 5] x [-8, 2] metres
>  cut(finpines, "height", breaks=4)
Marked planar point pattern: 126 points
Multitype, with levels = (0.795,1.95], (1.95,3.1], (3.1,4.25], (4.25,5.4] 
window: rectangle = [-5, 5] x [-8, 2] metres
> 
> 
> 
> cleanEx()
> nameEx("data.lppm")
> ### * data.lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.lppm
> ### Title: Extract Original Data from a Fitted Point Process Model on a
> ###   Network
> ### Aliases: data.lppm
> ### Keywords: spatial manip models
> 
> ### ** Examples
> 
>  fit <- lppm(spiders ~ x)
>  X <- data.lppm(fit)
>  # 'X' is identical to 'spiders'
> 
> 
> 
> cleanEx()
> nameEx("data.ppm")
> ### * data.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.ppm
> ### Title: Extract Original Data from a Fitted Point Process Model
> ### Aliases: data.ppm
> ### Keywords: spatial manip models
> 
> ### ** Examples
> 
>  fit <- ppm(cells, ~1, Strauss(r=0.1))
>  X <- data.ppm(fit)
>  # 'X' is identical to 'cells'
> 
> 
> 
> cleanEx()
> nameEx("dclf.progress")
> ### * dclf.progress
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dclf.progress
> ### Title: Progress Plot of Test of Spatial Pattern
> ### Aliases: dclf.progress mad.progress mctest.progress
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   plot(dclf.progress(cells, nsim=19))
Generating 19 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,  19.

Done.
> 
> 
> 
> cleanEx()
> nameEx("dclf.sigtrace")
> ### * dclf.sigtrace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dclf.sigtrace
> ### Title: Significance Trace of Cressie-Loosmore-Ford or Maximum Absolute
> ###   Deviation Test
> ### Aliases: dclf.sigtrace mad.sigtrace mctest.sigtrace
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   plot(dclf.sigtrace(cells, Lest, nsim=19))
Generating 19 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,  19.

Done.
> 
> 
> 
> cleanEx()
> nameEx("dclf.test")
> ### * dclf.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dclf.test
> ### Title: Diggle-Cressie-Loosmore-Ford and Maximum Absolute Deviation
> ###   Tests
> ### Aliases: dclf.test mad.test
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   dclf.test(cells, Lest, nsim=39)
Generating 39 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  39.

Done.

	Diggle-Cressie-Loosmore-Ford test of CSR
	Monte Carlo test based on 39 simulations
	Summary function: L(r)
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0, 0.25]
	Test statistic: Integral of squared absolute deviation
	Deviation = observed minus theoretical

data:  cells
u = 0.00047199, rank = 1, p-value = 0.025

>   m <- mad.test(cells, Lest, verbose=FALSE, rinterval=c(0, 0.1), nsim=19)
>   m

	Maximum absolute deviation test of CSR
	Monte Carlo test based on 19 simulations
	Summary function: L(r)
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0, 0.1]
	Test statistic: Maximum absolute deviation
	Deviation = observed minus theoretical

data:  cells
mad = 0.083496, rank = 1, p-value = 0.05

>   # extract the p-value
>   m$p.value
[1] 0.05
>   # variance stabilised G function
>   dclf.test(cells, Gest, transform=expression(asin(sqrt(.))),
+                    verbose=FALSE, nsim=19)

	Diggle-Cressie-Loosmore-Ford test of CSR
	Monte Carlo test based on 19 simulations
	Summary function: asin(sqrt(G(r)))
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0, 0.295388283386184]
	Test statistic: Integral of squared absolute deviation
	Deviation = observed minus theoretical

data:  cells
u = 0.045317, rank = 1, p-value = 0.05

> 
>   ## one-sided test
>   ml <- mad.test(cells, Lest, verbose=FALSE, nsim=19, alternative="less")
> 
>   ## scaled
>   mad.test(cells, Kest, verbose=FALSE, nsim=19,
+            rinterval=c(0.05, 0.2),
+            scale=function(r) { r })

	Maximum absolute deviation test of CSR
	Monte Carlo test based on 19 simulations
	Summary function: K(r)
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0.05, 0.2]
	Scale function: function (r) { r }
	Test statistic: Maximum absolute deviation
	Deviation = observed minus theoretical

data:  cells
mad = 0.3235, rank = 1, p-value = 0.05

> 
> 
> 
> cleanEx()
> nameEx("default.dummy")
> ### * default.dummy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default.dummy
> ### Title: Generate a Default Pattern of Dummy Points
> ### Aliases: default.dummy
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   data(simdat)
>   P <- simdat
>   D <- default.dummy(P, 100)
>   ## Not run: plot(D)
>   Q <- quadscheme(P, D, "grid")
>   ## Not run: plot(union.quad(Q))
> 
> 
> 
> cleanEx()
> nameEx("default.expand")
> ### * default.expand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default.expand
> ### Title: Default Expansion Rule for Simulation of Model
> ### Aliases: default.expand
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   data(cells)
>   fit <- ppm(cells, ~1, Strauss(0.07))
>   default.expand(fit)
Expand the simulation window? Yes:
window: rectangle = [-0.14, 1.14] x [-0.14, 1.14] units
>   mod <- rmhmodel(cif="strauss", par=list(beta=100, gamma=0.5, r=0.07))
>   default.expand(fit)
Expand the simulation window? Yes:
window: rectangle = [-0.14, 1.14] x [-0.14, 1.14] units
> 
> 
> 
> cleanEx()
> nameEx("default.rmhcontrol")
> ### * default.rmhcontrol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default.rmhcontrol
> ### Title: Set Default Control Parameters for Metropolis-Hastings
> ###   Algorithm.
> ### Aliases: default.rmhcontrol
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   fit <- ppm(cells, ~1, Strauss(0.1))
>   default.rmhcontrol(fit)
Metropolis-Hastings algorithm control parameters
Probability of shift proposal: p = 0.9
Conditional probability of death proposal: q = 0.9
Number of M-H iterations: nrep = 500000
Generate random proposal points: before each block of  iterations.
Track proposal type and acceptance/rejection? no 
No progress reports (nverb = 0).
Expand the simulation window? Yes:
	 Expansion buffer distance 0.2 
Periodic edge correction? Not yet determined.
>   default.rmhcontrol(fit, w=square(2))
Metropolis-Hastings algorithm control parameters
Probability of shift proposal: p = 0.9
Conditional probability of death proposal: q = 0.9
Number of M-H iterations: nrep = 500000
Generate random proposal points: before each block of  iterations.
Track proposal type and acceptance/rejection? no 
No progress reports (nverb = 0).
Expand the simulation window? Yes:
window: rectangle = [-0.2, 2.2] x [-0.2, 2.2] units
Periodic edge correction? Not yet determined.
> 
> 
> 
> cleanEx()
> nameEx("delaunay")
> ### * delaunay
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delaunay
> ### Title: Delaunay Triangulation of Point Pattern
> ### Aliases: delaunay
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runifpoint(42)
>   plot(delaunay(X))
>   plot(X, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("delaunayDistance")
> ### * delaunayDistance
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delaunayDistance
> ### Title: Distance on Delaunay Triangulation
> ### Aliases: delaunayDistance
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runifpoint(20)
>   M <- delaunayDistance(X)
>   plot(delaunay(X), lty=3)
>   text(X, labels=M[1, ], cex=2)
> 
> 
> 
> cleanEx()
> nameEx("delaunayNetwork")
> ### * delaunayNetwork
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delaunayNetwork
> ### Title: Linear Network of Delaunay Triangulation or Dirichlet
> ###   Tessellation
> ### Aliases: delaunayNetwork dirichletNetwork
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   LE <- delaunayNetwork(cells)
>   LI <- dirichletNetwork(cells)
> 
> 
> 
> cleanEx()
> nameEx("deletebranch")
> ### * deletebranch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deletebranch
> ### Title: Delete or Extract a Branch of a Tree
> ### Aliases: deletebranch deletebranch.linnet deletebranch.lpp
> ###   extractbranch extractbranch.linnet extractbranch.lpp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # make a simple tree
>   m <- simplenet$m
>   m[8,10] <- m[10,8] <- FALSE
>   L <- linnet(vertices(simplenet), m)
>   plot(L, main="")
>   # compute branch labels 
>   tb <- treebranchlabels(L, 1)
>   tbc <- paste0("[", tb, "]")
>   text(vertices(L), labels=tbc, cex=2)
> 
>   # delete branch B
>   LminusB <- deletebranch(L, "b", tb)
>   plot(LminusB, add=TRUE, col="green")
> 
>   # extract branch B
>   LB <- extractbranch(L, "b", tb)
>   plot(LB, add=TRUE, col="red")
> 
> 
> 
> cleanEx()
> nameEx("deltametric")
> ### * deltametric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deltametric
> ### Title: Delta Metric
> ### Aliases: deltametric
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- runifpoint(20)
>   Y <- runifpoint(10)
>   deltametric(X, Y, p=1,c=0.1)
[1] 0.01917125
> 
> 
> 
> cleanEx()
> nameEx("density.lpp")
> ### * density.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: density.lpp
> ### Title: Kernel Estimate of Intensity on a Linear Network
> ### Aliases: density.lpp density.splitppx
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   X <- runiflpp(3, simplenet)
>   D <- density(X, 0.2, verbose=FALSE)
>   plot(D, style="w", main="", adjust=2)
>   Dq <- density(X, 0.2, distance="euclidean")
>   plot(Dq, style="w", main="", adjust=2)
>   Dw <- density(X, 0.2, weights=c(1,2,-1), verbose=FALSE)
>   De <- density(X, 0.2, kernel="epanechnikov", verbose=FALSE)
  seg  from   distance    weight generation
1   3  TRUE 0.63737914 0.6666667          2
2   6 FALSE 0.06299400 1.0000000          1
3   3  TRUE 0.37569343 1.0000000          1
4   3 FALSE 0.02599962 1.0000000          1
5   3  TRUE 0.06599198 1.0000000          1
6   3 FALSE 0.33570106 1.0000000          1
  seg  from   distance     weight generation
1   6 FALSE 0.53436620 -0.3333333          2
2   3  TRUE 0.63737914  0.6666667          2
3   6 FALSE 0.06299400  1.0000000          1
4   3  TRUE 0.37569343  1.0000000          1
5   3 FALSE 0.02599962  1.0000000          1
6   3  TRUE 0.06599198  1.0000000          1
7   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   7 FALSE 0.46846950  0.6666667          2
2   6 FALSE 0.53436620 -0.3333333          2
3   3  TRUE 0.63737914  0.6666667          2
4   6 FALSE 0.06299400  1.0000000          1
5   3  TRUE 0.37569343  1.0000000          1
6   3 FALSE 0.02599962  1.0000000          1
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance weight generation
1   6  TRUE 0.36167410      0          2
5   3  TRUE 0.37569343      1          1
6   3 FALSE 0.02599962      1          1
7   3  TRUE 0.06599198      1          1
8   3 FALSE 0.33570106      1          1
   seg  from   distance weight generation
1   10 FALSE 0.54365491      1          2
11   6  TRUE 0.36167410      0          2
5    3  TRUE 0.37569343      1          1
6    3 FALSE 0.02599962      1          1
7    3  TRUE 0.06599198      1          1
8    3 FALSE 0.33570106      1          1
  seg  from   distance weight generation
1   1  TRUE 0.77634660    0.5          2
6   3 FALSE 0.02599962    1.0          1
7   3  TRUE 0.06599198    1.0          1
8   3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    5 FALSE 0.52583999    0.5          2
13   3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
  seg  from   distance     weight generation
1   3  TRUE 0.42769266 -0.3333333          2
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7 FALSE 0.25878302  0.6666667          2
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7  TRUE 0.49156642  0.6666667          3
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1   10 FALSE 0.80534062  0.6666667          3
12   6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   1  TRUE 0.82834584 -0.1666667          3
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    5 FALSE 0.57783922 -0.1666667          3
13   3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from  distance weight generation
1   1  TRUE 0.4666452    0.5          2
8   3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    5 FALSE 0.2161385    0.5          2
13   3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance    weight generation
1    4  TRUE 0.3873956 0.3333333          3
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
   seg  from  distance     weight generation
1    5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8 FALSE 0.4436797  0.3333333          3
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1   10  TRUE 0.9243406  0.2222222          4
15   9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance      weight generation
1    1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    5 FALSE 0.5164317  0.08333333          4
15   3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance    weight generation
1    4 FALSE 0.5586526 0.3333333          4
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
  seg  from  distance weight generation
1   2 FALSE 0.6752282    0.5          3
8   3 FALSE 0.3357011    1.0          1
  seg from  distance     weight generation
1   3 TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   6 FALSE 0.6343812  0.6666667          2
2   3  TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   7 FALSE 0.5684845  0.6666667          2
2   6 FALSE 0.6343812  0.6666667          2
3   3  TRUE 0.7373941 -0.3333333          2
>   Ded <- density(X, 0.2, kernel="epanechnikov", continuous=FALSE, verbose=FALSE)
  seg  from   distance    weight generation
1   3  TRUE 0.63737914 0.6666667          2
2   6 FALSE 0.06299400 1.0000000          1
3   3  TRUE 0.37569343 1.0000000          1
4   3 FALSE 0.02599962 1.0000000          1
5   3  TRUE 0.06599198 1.0000000          1
6   3 FALSE 0.33570106 1.0000000          1
  seg  from   distance     weight generation
1   6 FALSE 0.53436620 -0.3333333          2
2   3  TRUE 0.63737914  0.6666667          2
3   6 FALSE 0.06299400  1.0000000          1
4   3  TRUE 0.37569343  1.0000000          1
5   3 FALSE 0.02599962  1.0000000          1
6   3  TRUE 0.06599198  1.0000000          1
7   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   7 FALSE 0.46846950  0.6666667          2
2   6 FALSE 0.53436620 -0.3333333          2
3   3  TRUE 0.63737914  0.6666667          2
4   6 FALSE 0.06299400  1.0000000          1
5   3  TRUE 0.37569343  1.0000000          1
6   3 FALSE 0.02599962  1.0000000          1
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance weight generation
1   6  TRUE 0.36167410      0          2
5   3  TRUE 0.37569343      1          1
6   3 FALSE 0.02599962      1          1
7   3  TRUE 0.06599198      1          1
8   3 FALSE 0.33570106      1          1
   seg  from   distance weight generation
1   10 FALSE 0.54365491      1          2
11   6  TRUE 0.36167410      0          2
5    3  TRUE 0.37569343      1          1
6    3 FALSE 0.02599962      1          1
7    3  TRUE 0.06599198      1          1
8    3 FALSE 0.33570106      1          1
  seg  from   distance weight generation
1   1  TRUE 0.77634660    0.5          2
6   3 FALSE 0.02599962    1.0          1
7   3  TRUE 0.06599198    1.0          1
8   3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    5 FALSE 0.52583999    0.5          2
13   3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
  seg  from   distance     weight generation
1   3  TRUE 0.42769266 -0.3333333          2
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7 FALSE 0.25878302  0.6666667          2
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7  TRUE 0.49156642  0.6666667          3
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1   10 FALSE 0.80534062  0.6666667          3
12   6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   1  TRUE 0.82834584 -0.1666667          3
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    5 FALSE 0.57783922 -0.1666667          3
13   3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from  distance weight generation
1   1  TRUE 0.4666452    0.5          2
8   3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    5 FALSE 0.2161385    0.5          2
13   3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance    weight generation
1    4  TRUE 0.3873956 0.3333333          3
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
   seg  from  distance     weight generation
1    5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8 FALSE 0.4436797  0.3333333          3
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1   10  TRUE 0.9243406  0.2222222          4
15   9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance      weight generation
1    1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    5 FALSE 0.5164317  0.08333333          4
15   3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance    weight generation
1    4 FALSE 0.5586526 0.3333333          4
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
  seg  from  distance weight generation
1   2 FALSE 0.6752282    0.5          3
8   3 FALSE 0.3357011    1.0          1
  seg from  distance     weight generation
1   3 TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   6 FALSE 0.6343812  0.6666667          2
2   3  TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   7 FALSE 0.5684845  0.6666667          2
2   6 FALSE 0.6343812  0.6666667          2
3   3  TRUE 0.7373941 -0.3333333          2
> 
> 
> 
> cleanEx()
> nameEx("density.ppp")
> ### * density.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: density.ppp
> ### Title: Kernel Smoothed Intensity of Point Pattern
> ### Aliases: density.ppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   if(interactive()) {
+     opa <- par(mfrow=c(1,2))
+     plot(density(cells, 0.05))
+     plot(density(cells, 0.05, diggle=TRUE))
+     par(opa)
+     v <- diag(c(0.05, 0.07)^2)
+     plot(density(cells, varcov=v))
+   }
>   # automatic bandwidth selection
>   plot(density(cells, sigma=bw.diggle(cells)))
>   # equivalent:
>   plot(density(cells, bw.diggle))
>   # evaluate intensity at points
>   density(cells, 0.05, at="points")
 [1]  2.6230115  6.6612002  2.3346718  9.3678806  6.8726363  0.7214982
 [7]  1.4306543  8.4519784  2.2675716  2.6218196  1.1731435  3.9791376
[13]  7.1944496  6.8086060  4.7354784  2.2482630  3.8053247  4.5214383
[19] 12.4922086  4.2571137  7.2928882  1.1176274  2.3007513 22.4488997
[25]  5.0504982 10.9080134 10.0143852  0.8987745  2.1162928 10.1260816
[31]  7.5433476 19.7851133  2.5440620  8.1479922  8.6637017  2.9296855
[37]  2.3009078  2.0798390  1.4667999  3.2263980  3.4377503  1.9701207
attr(,"sigma")
[1] 0.05
> 
>   plot(density(cells, sigma=0.4, kernel="epanechnikov"))
> 
>   # relative risk calculation by hand (see relrisk.ppp)
>   lung <- split(chorley)$lung
>   larynx <- split(chorley)$larynx
>   D <- density(lung, sigma=2)
>   plot(density(larynx, sigma=2, weights=1/D))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("density.psp")
> ### * density.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: density.psp
> ### Title: Kernel Smoothing of Line Segment Pattern or Linear Network
> ### Aliases: density.psp density.linnet
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   L <- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
>   D <- density(L, sigma=0.03)
>   plot(D, main="density(L)")
>   plot(L, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("density.splitppp")
> ### * density.splitppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: density.splitppp
> ### Title: Kernel Smoothed Intensity of Split Point Pattern
> ### Aliases: density.splitppp density.ppplist
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   Z <- density(split(amacrine), 0.05)
>   plot(Z)
> 
> 
> 
> cleanEx()
> nameEx("densityAdaptiveKernel")
> ### * densityAdaptiveKernel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityAdaptiveKernel
> ### Title: Adaptive Kernel Estimate of Intensity of Point Pattern
> ### Aliases: densityAdaptiveKernel densityAdaptiveKernel.ppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   Z <- densityAdaptiveKernel(redwood, h0=0.1)
>   plot(Z, main="Adaptive kernel estimate")
>   points(redwood, col="white")
> 
> 
> 
> cleanEx()
> nameEx("densityEqualSplit")
> ### * densityEqualSplit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityEqualSplit
> ### Title: Equal-Split Algorithm for Kernel Density on a Network
> ### Aliases: densityEqualSplit
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   X <- runiflpp(3, simplenet)
>   De <- density(X, 0.2, kernel="epanechnikov", verbose=FALSE)
  seg  from   distance    weight generation
1   3  TRUE 0.63737914 0.6666667          2
2   6 FALSE 0.06299400 1.0000000          1
3   3  TRUE 0.37569343 1.0000000          1
4   3 FALSE 0.02599962 1.0000000          1
5   3  TRUE 0.06599198 1.0000000          1
6   3 FALSE 0.33570106 1.0000000          1
  seg  from   distance     weight generation
1   6 FALSE 0.53436620 -0.3333333          2
2   3  TRUE 0.63737914  0.6666667          2
3   6 FALSE 0.06299400  1.0000000          1
4   3  TRUE 0.37569343  1.0000000          1
5   3 FALSE 0.02599962  1.0000000          1
6   3  TRUE 0.06599198  1.0000000          1
7   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   7 FALSE 0.46846950  0.6666667          2
2   6 FALSE 0.53436620 -0.3333333          2
3   3  TRUE 0.63737914  0.6666667          2
4   6 FALSE 0.06299400  1.0000000          1
5   3  TRUE 0.37569343  1.0000000          1
6   3 FALSE 0.02599962  1.0000000          1
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance weight generation
1   6  TRUE 0.36167410      0          2
5   3  TRUE 0.37569343      1          1
6   3 FALSE 0.02599962      1          1
7   3  TRUE 0.06599198      1          1
8   3 FALSE 0.33570106      1          1
   seg  from   distance weight generation
1   10 FALSE 0.54365491      1          2
11   6  TRUE 0.36167410      0          2
5    3  TRUE 0.37569343      1          1
6    3 FALSE 0.02599962      1          1
7    3  TRUE 0.06599198      1          1
8    3 FALSE 0.33570106      1          1
  seg  from   distance weight generation
1   1  TRUE 0.77634660    0.5          2
6   3 FALSE 0.02599962    1.0          1
7   3  TRUE 0.06599198    1.0          1
8   3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    5 FALSE 0.52583999    0.5          2
13   3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
  seg  from   distance     weight generation
1   3  TRUE 0.42769266 -0.3333333          2
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7 FALSE 0.25878302  0.6666667          2
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7  TRUE 0.49156642  0.6666667          3
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1   10 FALSE 0.80534062  0.6666667          3
12   6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   1  TRUE 0.82834584 -0.1666667          3
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    5 FALSE 0.57783922 -0.1666667          3
13   3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from  distance weight generation
1   1  TRUE 0.4666452    0.5          2
8   3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    5 FALSE 0.2161385    0.5          2
13   3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance    weight generation
1    4  TRUE 0.3873956 0.3333333          3
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
   seg  from  distance     weight generation
1    5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8 FALSE 0.4436797  0.3333333          3
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1   10  TRUE 0.9243406  0.2222222          4
15   9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance      weight generation
1    1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    5 FALSE 0.5164317  0.08333333          4
15   3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance    weight generation
1    4 FALSE 0.5586526 0.3333333          4
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
  seg  from  distance weight generation
1   2 FALSE 0.6752282    0.5          3
8   3 FALSE 0.3357011    1.0          1
  seg from  distance     weight generation
1   3 TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   6 FALSE 0.6343812  0.6666667          2
2   3  TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   7 FALSE 0.5684845  0.6666667          2
2   6 FALSE 0.6343812  0.6666667          2
3   3  TRUE 0.7373941 -0.3333333          2
>   Ded <- density(X, 0.2, kernel="epanechnikov", continuous=FALSE, verbose=FALSE)
  seg  from   distance    weight generation
1   3  TRUE 0.63737914 0.6666667          2
2   6 FALSE 0.06299400 1.0000000          1
3   3  TRUE 0.37569343 1.0000000          1
4   3 FALSE 0.02599962 1.0000000          1
5   3  TRUE 0.06599198 1.0000000          1
6   3 FALSE 0.33570106 1.0000000          1
  seg  from   distance     weight generation
1   6 FALSE 0.53436620 -0.3333333          2
2   3  TRUE 0.63737914  0.6666667          2
3   6 FALSE 0.06299400  1.0000000          1
4   3  TRUE 0.37569343  1.0000000          1
5   3 FALSE 0.02599962  1.0000000          1
6   3  TRUE 0.06599198  1.0000000          1
7   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   7 FALSE 0.46846950  0.6666667          2
2   6 FALSE 0.53436620 -0.3333333          2
3   3  TRUE 0.63737914  0.6666667          2
4   6 FALSE 0.06299400  1.0000000          1
5   3  TRUE 0.37569343  1.0000000          1
6   3 FALSE 0.02599962  1.0000000          1
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
  seg  from   distance weight generation
1   6  TRUE 0.36167410      0          2
5   3  TRUE 0.37569343      1          1
6   3 FALSE 0.02599962      1          1
7   3  TRUE 0.06599198      1          1
8   3 FALSE 0.33570106      1          1
   seg  from   distance weight generation
1   10 FALSE 0.54365491      1          2
11   6  TRUE 0.36167410      0          2
5    3  TRUE 0.37569343      1          1
6    3 FALSE 0.02599962      1          1
7    3  TRUE 0.06599198      1          1
8    3 FALSE 0.33570106      1          1
  seg  from   distance weight generation
1   1  TRUE 0.77634660    0.5          2
6   3 FALSE 0.02599962    1.0          1
7   3  TRUE 0.06599198    1.0          1
8   3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
   seg  from   distance weight generation
1    5 FALSE 0.52583999    0.5          2
13   3 FALSE 0.77738647   -0.5          2
12   2  TRUE 0.68031154    0.5          2
11   1  TRUE 0.77634660    0.5          2
6    3 FALSE 0.02599962    1.0          1
7    3  TRUE 0.06599198    1.0          1
8    3 FALSE 0.33570106    1.0          1
  seg  from   distance     weight generation
1   3  TRUE 0.42769266 -0.3333333          2
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7 FALSE 0.25878302  0.6666667          2
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    7  TRUE 0.49156642  0.6666667          3
12   6 FALSE 0.32467972  0.6666667          2
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1   10 FALSE 0.80534062  0.6666667          3
12   6  TRUE 0.62335981  0.0000000          3
11   3  TRUE 0.42769266 -0.3333333          2
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from   distance     weight generation
1   1  TRUE 0.82834584 -0.1666667          3
7   3  TRUE 0.06599198  1.0000000          1
8   3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
   seg  from   distance     weight generation
1    5 FALSE 0.57783922 -0.1666667          3
13   3 FALSE 0.82938570  0.1666667          3
12   2  TRUE 0.73231077 -0.1666667          3
11   1  TRUE 0.82834584 -0.1666667          3
7    3  TRUE 0.06599198  1.0000000          1
8    3 FALSE 0.33570106  1.0000000          1
  seg  from  distance weight generation
1   1  TRUE 0.4666452    0.5          2
8   3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance weight generation
1    5 FALSE 0.2161385    0.5          2
13   3 FALSE 0.4676850   -0.5          2
12   2  TRUE 0.3706101    0.5          2
11   1  TRUE 0.4666452    0.5          2
8    3 FALSE 0.3357011    1.0          1
   seg  from  distance    weight generation
1    4  TRUE 0.3873956 0.3333333          3
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
   seg  from  distance     weight generation
1    5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8 FALSE 0.4436797  0.3333333          3
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1    9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance     weight generation
1   10  TRUE 0.9243406  0.2222222          4
15   9  TRUE 0.6804978  0.2222222          4
14   8  TRUE 0.6712209 -0.1111111          4
13   5  TRUE 0.3662851 -0.1666667          3
11   4  TRUE 0.3873956  0.3333333          3
12   2  TRUE 0.3706101  0.5000000          2
8    3 FALSE 0.3357011  1.0000000          1
   seg  from  distance      weight generation
1    1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance      weight generation
1    5 FALSE 0.5164317  0.08333333          4
15   3 FALSE 0.7679782 -0.08333333          4
14   2  TRUE 0.6709032 -0.08333333          4
13   1  TRUE 0.7669383 -0.08333333          4
11   4  TRUE 0.3873956  0.33333333          3
12   2  TRUE 0.3706101  0.50000000          2
8    3 FALSE 0.3357011  1.00000000          1
   seg  from  distance    weight generation
1    4 FALSE 0.5586526 0.3333333          4
12   2  TRUE 0.3706101 0.5000000          2
8    3 FALSE 0.3357011 1.0000000          1
  seg  from  distance weight generation
1   2 FALSE 0.6752282    0.5          3
8   3 FALSE 0.3357011    1.0          1
  seg from  distance     weight generation
1   3 TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   6 FALSE 0.6343812  0.6666667          2
2   3  TRUE 0.7373941 -0.3333333          2
  seg  from  distance     weight generation
1   7 FALSE 0.5684845  0.6666667          2
2   6 FALSE 0.6343812  0.6666667          2
3   3  TRUE 0.7373941 -0.3333333          2
> 
> 
> 
> cleanEx()
> nameEx("densityHeat")
> ### * densityHeat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityHeat
> ### Title: Kernel Density on a Network using Heat Equation
> ### Aliases: densityHeat
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   X <- runiflpp(3, simplenet)
>   D <- densityHeat(X, 0.2)
>   plot(D, style="w", main="", adjust=2)
>   densityHeat(X, 0.2, at="points")
[1] 0.4431461 1.0188141 0.6091251
attr(,"sigma")
[1] 0.2
>   Dw <- densityHeat(X, 0.2, weights=c(1,2,-1))
> 
> 
> 
> cleanEx()
> nameEx("densityQuick.lpp")
> ### * densityQuick.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityQuick.lpp
> ### Title: Kernel Estimation of Intensity on a Network using a 2D Kernel
> ### Aliases: densityQuick.lpp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    X <- unmark(chicago)
>    plot(densityQuick.lpp(X, 500))
>    plot(densityQuick.lpp(X, 500, diggle=TRUE))
>    plot(densityQuick.lpp(X, bw.scott.iso))
>    plot(densityQuick.lpp(X, 500, what="se"))
> 
> 
> 
> cleanEx()
> nameEx("densityVoronoi")
> ### * densityVoronoi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityVoronoi
> ### Title: Intensity Estimate of Point Pattern Using Voronoi-Dirichlet
> ###   Tessellation
> ### Aliases: densityVoronoi densityVoronoi.ppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   plot(densityVoronoi(nztrees, 1, f=1), main="Voronoi estimate")
>   nr <- if(interactive()) 100 else 5
>   plot(densityVoronoi(nztrees, f=0.5, nrep=nr), main="smoothed Voronoi estimate")
Computing 5 intensity estimates...1, 2, 3, 4,  5.
Done.
> 
> 
> 
> cleanEx()
> nameEx("densityVoronoi.lpp")
> ### * densityVoronoi.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityVoronoi.lpp
> ### Title: Intensity Estimate of Point Pattern on Linear Network Using
> ###   Voronoi-Dirichlet Tessellation
> ### Aliases: densityVoronoi.lpp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    nr <- if(interactive()) 100 else 3
>    plot(densityVoronoi(spiders, 0.1, nrep=nr))
> 
> 
> 
> cleanEx()
> nameEx("densityfun")
> ### * densityfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityfun.ppp
> ### Title: Kernel Estimate of Intensity as a Spatial Function
> ### Aliases: densityfun densityfun.ppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   f <- densityfun(swedishpines)
>   f
function(x,y) which returns kernel estimate of intensity for
Planar point pattern: 71 points
window: rectangle = [0, 96] x [0, 100] units (one unit = 0.1 metres)
>   f(42, 60)
[1] 0.008458976
attr(,"sigma")
[1] 5.706458
>   plot(f)
> 
> 
> 
> cleanEx()
> nameEx("densityfun.lpp")
> ### * densityfun.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: densityfun.lpp
> ### Title: Kernel Estimate of Intensity on a Linear Network as a Spatial
> ###   Function
> ### Aliases: densityfun.lpp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- unmark(chicago)
>   # single bandwidth
>   g <- densityfun(X, 30)
>   plot(g)
>   Y <- X[1:5]
>   g(Y)
[1] 0.007704222 0.026735953 0.011351091 0.015450324 0.020902553
>   # weighted
>   gw <- densityfun(X, 30, weights=runif(npoints(X)))
>   # sequence of bandwidths 
>   g10 <- densityfun(X, 30, nsigma=10)
>   g10(Y, k=10)
[1] 0.007691882 0.026641404 0.011309821 0.015436365 0.020800415
>   g10(Y)
           [,1]       [,2]       [,3]       [,4]        [,5]       [,6]
[1,] 0.02100925 0.01482557 0.01211192 0.01054371 0.009541176 0.00886923
[2,] 0.05392527 0.04560660 0.04044141 0.03687060 0.034228925 0.03215778
[3,] 0.04185014 0.02888498 0.02259792 0.01878663 0.016294586 0.01458927
[4,] 0.02907723 0.02121184 0.01875254 0.01759458 0.016897124 0.01642181
[5,] 0.06094063 0.04804094 0.03998342 0.03451254 0.030582505 0.02763680
            [,7]        [,8]       [,9]       [,10]
[1,] 0.008406707 0.008083078 0.00785436 0.007691882
[2,] 0.030458224 0.029014823 0.02775740 0.026641404
[3,] 0.013379812 0.012494476 0.01182707 0.011309821
[4,] 0.016076127 0.015813490 0.01560621 0.015436365
[5,] 0.025352289 0.023529749 0.02204095 0.020800415
>   plot(as.linim(g10, k=5))
> 
> 
> 
> cleanEx()
> nameEx("deriv.fv")
> ### * deriv.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deriv.fv
> ### Title: Calculate Derivative of Function Values
> ### Aliases: deriv.fv
> ### Keywords: spatial math nonparametric
> 
> ### ** Examples
> 
>    G <- Gest(cells)
>    plot(deriv(G, which=".", spar=0.5))
>    A <- pairorient(redwood, 0.05, 0.15)
>    DA <- deriv(A, spar=0.6, Dperiodic=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("detpointprocfamilyfun")
> ### * detpointprocfamilyfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: detpointprocfamilyfun
> ### Title: Construct a New Determinantal Point Process Model Family
> ###   Function
> ### Aliases: detpointprocfamilyfun
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   ## Example of how to define the Gauss family
> exGauss <- detpointprocfamilyfun(
+     name="Gaussian",
+     kernel=function(x, lambda, alpha, d){
+         lambda*exp(-(x/alpha)^2)
+     },
+     specden=function(x, lambda, alpha, d){
+         lambda * (sqrt(pi)*alpha)^d * exp(-(x*alpha*pi)^2)
+     },
+     convkernel=function(x, k, lambda, alpha, d){
+         logres <- k*log(lambda*pi*alpha^2) - log(pi*k*alpha^2) - x^2/(k*alpha^2)
+         return(exp(logres))
+     },
+     Kfun = function(x, lambda, alpha, d){
+         pi*x^2 - pi*alpha^2/2*(1-exp(-2*x^2/alpha^2))
+     },
+     valid=function(lambda, alpha, d){
+         lambda>0 && alpha>0 && d>=1 && lambda <= (sqrt(pi)*alpha)^(-d)
+     },
+     isotropic=TRUE,
+     intensity="lambda",
+     dim="d",
+     range=function(alpha, bound = .99){
+         if(missing(alpha))
+             stop("The parameter alpha is missing.")
+         if(!(is.numeric(bound)&&bound>0&&bound<1))
+             stop("Argument bound must be a numeric between 0 and 1.")
+         return(alpha*sqrt(-log(sqrt(1-bound))))
+     },
+     parbounds=function(name, lambda, alpha, d){
+         switch(name,
+                lambda = c(0, (sqrt(pi)*alpha)^(-d)),
+                alpha = c(0, lambda^(-1/d)/sqrt(pi)),
+                stop("Parameter name misspecified")
+                )
+     },
+     startpar=function(model, X){
+         rslt <- NULL
+         if("lambda" %in% model$freepar){
+             lambda <- intensity(X)
+             rslt <- c(rslt, "lambda" = lambda)
+             model <- update(model, lambda=lambda)
+         }
+         if("alpha" %in% model$freepar){
+             alpha <- .8*dppparbounds(model, "alpha")[2]
+             rslt <- c(rslt, "alpha" = alpha)
+         }
+         return(rslt)
+     }
+     )
>   exGauss
Gaussian determinantal point process model family
The parameters of the family are:
lambda, alpha, d
>   m <- exGauss(lambda=100, alpha=.05, d=2)
>   m
Gaussian determinantal point process model
The parameters are: lambda = 100, alpha = 0.05, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.
> 
> 
> 
> cleanEx()
> nameEx("dfbetas.ppm")
> ### * dfbetas.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dfbetas.ppm
> ### Title: Parameter Influence Measure
> ### Aliases: dfbetas.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    ## Don't show: 
> op <- spatstat.options(npixel=32)
> ## End(Don't show)
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X ~x+y)
>    ## Don't show: 
> fit <- ppm(X ~x+y, nd=16)
> ## End(Don't show)
>    plot(dfbetas(fit))
>    plot(Smooth(dfbetas(fit)))
>    ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("dffit.ppm")
> ### * dffit.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dffit.ppm
> ### Title: Case Deletion Effect Measure of Fitted Model
> ### Aliases: dffit dffit.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    ## Don't show: 
> op <- spatstat.options(npixel=32)
> ## End(Don't show)
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X ~x+y)
>    ## Don't show: 
> fit <- ppm(X ~x+y, nd=16)
> ## End(Don't show)
>    plot(dffit(fit))
>    plot(dffit(fit, collapse=TRUE))
>    ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
>    
> 
> 
> 
> cleanEx()
> nameEx("dg.envelope")
> ### * dg.envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dg.envelope
> ### Title: Global Envelopes for Dao-Genton Test
> ### Aliases: dg.envelope
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>   ns <- if(interactive()) 19 else 4
>   E <- dg.envelope(swedishpines, Lest, nsim=ns)
Applying first-stage test to original data... Done.
Done.
Running tests on 4 simulated patterns... 1, 2, 3,  4.
bits.rank = 1
bits.crit = 1.707744
>   E
Function value object (class 'fv')
for the function r -> L(r)
...........................................................
     Math.label     Description                            
r    r              distance argument r                    
obs  hat(L)[obs](r) observed value of L(r) for data pattern
theo L[theo](r)     theoretical value of L(r) for CSR      
hi   L[hi](r)       upper 20% critical boundary for L(r)   
lo   L[lo](r)       lower 20% critical boundary for L(r)   
...........................................................
Default plot formula:  .~.x
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 24]
Available range of argument r: [0, 24]
Unit of length: 0.1 metres
>   plot(E)
>   Eo <- dg.envelope(swedishpines, Lest, alternative="less", nsim=ns)
Applying first-stage test to original data... Done.
Done.
Running tests on 4 simulated patterns... 1, 2, 3,  4.
bits.rank = 2
bits.crit = 1.21875
>   Ei <- dg.envelope(swedishpines, Lest, interpolate=TRUE, nsim=ns)
Applying first-stage test to original data... Done.
Done.
Running tests on 4 simulated patterns... 1, 2, 3,  4.
> 
> 
> 
> cleanEx()
> nameEx("dg.progress")
> ### * dg.progress
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dg.progress
> ### Title: Progress Plot of Dao-Genton Test of Spatial Pattern
> ### Aliases: dg.progress
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>    ns <- if(interactive()) 19 else 5
>    plot(dg.progress(cells, nsim=ns))
Computing first-level test data...Done.
Computing second-level data... 1, 2, 3, 4,  5.
Done.
> 
> 
> 
> cleanEx()
> nameEx("dg.sigtrace")
> ### * dg.sigtrace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dg.sigtrace
> ### Title: Significance Trace of Dao-Genton Test
> ### Aliases: dg.sigtrace
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   ns <- if(interactive()) 19 else 5
>   plot(dg.sigtrace(cells, nsim=ns))
> 
> 
> 
> cleanEx()
> nameEx("dg.test")
> ### * dg.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dg.test
> ### Title: Dao-Genton Adjusted Goodness-Of-Fit Test
> ### Aliases: dg.test
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>  ns <- if(interactive()) 19 else 4
>  dg.test(cells, nsim=ns)
Applying first-stage test to original data... Done.
Running second-stage tests on 4 simulated patterns... 1, 2, 3,  4.

	Dao-Genton adjusted goodness-of-fit test
	based on Diggle-Cressie-Loosmore-Ford test of CSR
	First stage: Monte Carlo test based on 4 simulations
	Summary function: K(r)
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0, 0.25]
	Test statistic: Integral of squared absolute deviation
	Deviation = observed minus theoretical
	Second stage: nested, 3 simulations for each first-stage simulation

data:  X
p0 = 0.2, p-value = 0.2

>  dg.test(cells, alternative="less", nsim=ns)
Applying first-stage test to original data... Done.
Running second-stage tests on 4 simulated patterns... 1, 2, 3,  4.

	Dao-Genton adjusted goodness-of-fit test
	based on Diggle-Cressie-Loosmore-Ford test of CSR
	First stage: Monte Carlo test based on 4 simulations
	Summary function: K(r)
	Reference function: theoretical
	Alternative: less
	Interval of distance values: [0, 0.25]
	Test statistic: Integral of squared signed deviation
	Deviation = observed minus theoretical
	Second stage: nested, 3 simulations for each first-stage simulation

data:  X
p0 = 0.2, p-value = 0.2

>  dg.test(cells, nsim=ns, interpolate=TRUE)
Applying first-stage test to original data... Done.
Running second-stage tests on 4 simulated patterns... 1, 2, 3,  4.

	Dao-Genton adjusted goodness-of-fit test
	based on Diggle-Cressie-Loosmore-Ford test of CSR
	First stage: Interpolated Monte Carlo test based on 4 simulations
	Summary function: K(r)
	Reference function: theoretical
	Alternative: two.sided
	Interval of distance values: [0, 0.25]
	Test statistic: Integral of squared absolute deviation
	Deviation = observed minus theoretical
	Second stage: nested, 3 simulations for each first-stage simulation

data:  X
p0 = 0.28161, p-value = 0.6

> 
> 
> 
> cleanEx()
> nameEx("diagnose.ppm")
> ### * diagnose.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diagnose.ppm
> ### Title: Diagnostic Plots for Fitted Point Process Model
> ### Aliases: diagnose.ppm plot.diagppm
> ### Keywords: spatial models hplot
> 
> ### ** Examples
> 
>     fit <- ppm(cells ~x, Strauss(r=0.15))
>     diagnose.ppm(fit)
Model diagnostics (raw residuals)
Diagnostics available:
	four-panel plot
	mark plot 
	smoothed residual field
	x cumulative residuals
	y cumulative residuals
	sum of all residuals
sum of raw residuals in clipped window = -9.021e-12
area of clipped window = 0.49
quadrature area = 0.4741
range of smoothed field =  [-49.8, 37.33]
>     ## Not run: 
> ##D     diagnose.ppm(fit, type="pearson")
> ##D     
> ## End(Not run)
> 
>     diagnose.ppm(fit, which="marks")
Model diagnostics (raw residuals)
Diagnostics available:
	mark plot 
> 
>     diagnose.ppm(fit, type="raw", plot.neg="discrete")
Model diagnostics (raw residuals)
Diagnostics available:
	four-panel plot
	mark plot (discrete representation only)
	smoothed residual field
	x cumulative residuals
	y cumulative residuals
	sum of all residuals
sum of raw residuals in clipped window = -9.021e-12
area of clipped window = 0.49
quadrature area = 0.4741
range of smoothed field =  [-49.8, 37.33]
> 
>     diagnose.ppm(fit, type="pearson", which="smooth")
Model diagnostics (Pearson residuals)
Diagnostics available:
	smoothed residual field
range of smoothed field =  [-5.16, 17.27]
Null standard deviation of smoothed Pearson residual field: 2.85
> 
>     # save the diagnostics and plot them later
>     u <- diagnose.ppm(fit, rbord=0.15, plot.it=FALSE)
>     ## Not run: 
> ##D     plot(u)
> ##D     plot(u, which="marks")
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("diameter.box3")
> ### * diameter.box3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diameter.box3
> ### Title: Geometrical Calculations for Three-Dimensional Box
> ### Aliases: diameter.box3 volume.box3 shortside.box3 sidelengths.box3
> ###   eroded.volumes.box3 shortside sidelengths eroded.volumes
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>     X <- box3(c(0,10),c(0,10),c(0,5))
>     diameter(X) 
[1] 15
>     volume(X)
[1] 500
>     sidelengths(X)
[1] 10 10  5
>     shortside(X)
[1] 5
>     hd <- shortside(X)/2
>     eroded.volumes(X, seq(0,hd, length=10))
 [1] 500.00000 396.43347 307.27023 231.48148 168.03841 115.91221  74.07407
 [8]  41.49520  17.14678   0.00000
> 
> 
> 
> cleanEx()
> nameEx("diameter.boxx")
> ### * diameter.boxx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diameter.boxx
> ### Title: Geometrical Calculations for Multi-Dimensional Box
> ### Aliases: diameter.boxx volume.boxx shortside.boxx sidelengths.boxx
> ###   eroded.volumes.boxx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>     X <- boxx(c(0,10),c(0,10),c(0,5),c(0,2))
>     diameter(X) 
[1] 15.13275
>     volume(X)
[1] 1000
>     shortside(X)
[1] 2
>     sidelengths(X)
x1 x2 x3 x4 
10 10  5  2 
>     hd <- shortside(X)/2
>     eroded.volumes(X, seq(0,hd, length=10))
 [1] 1000.00000  812.05182  647.05136  503.30864  379.19220  273.12910
 [7]  183.60494  109.16385   48.40847    0.00000
> 
> 
> 
> cleanEx()
> nameEx("diameter.linnet")
> ### * diameter.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diameter.linnet
> ### Title: Diameter and Bounding Radius of a Linear Network
> ### Aliases: boundingradius.linnet diameter.linnet
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    diameter(simplenet)
[1] 1.248943
>    boundingradius(simplenet)
[1] 0.7793609
> 
> 
> 
> cleanEx()
> nameEx("diameter.owin")
> ### * diameter.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diameter.owin
> ### Title: Diameter of a Window
> ### Aliases: diameter.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   w <- owin(c(0,1),c(0,1))
>   diameter(w) 
[1] 1.414214
>   # returns sqrt(2)
>   data(letterR)
>   diameter(letterR)
[1] 3.245781
> 
> 
> 
> cleanEx()
> nameEx("dilated.areas")
> ### * dilated.areas
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dilated.areas
> ### Title: Areas of Morphological Dilations
> ### Aliases: dilated.areas
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- runifpoint(10)
>   a <- dilated.areas(X, c(0.1,0.2), W=square(1), exact=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("dilation")
> ### * dilation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dilation
> ### Title: Morphological Dilation
> ### Aliases: dilation dilation.owin dilation.ppp dilation.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   plot(dilation(redwood, 0.05))
>   points(redwood)
> 
>   plot(dilation(letterR, 0.2))
>   plot(letterR, add=TRUE, lwd=2, border="red")
> 
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(dilation(X, 0.1))
>   plot(X, add=TRUE, col="red")
> 
> 
> 
> 
> cleanEx()
> nameEx("dirichlet")
> ### * dirichlet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dirichlet
> ### Title: Dirichlet Tessellation of Point Pattern
> ### Aliases: dirichlet
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runifpoint(42)
>   plot(dirichlet(X))
>   plot(X, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("dirichletAreas")
> ### * dirichletAreas
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dirichletAreas
> ### Title: Compute Areas of Tiles in Dirichlet Tessellation
> ### Aliases: dirichletAreas
> ### Keywords: spatial math manip
> 
> ### ** Examples
> 
>  aa <- dirichletAreas(cells)
> 
> 
> 
> cleanEx()
> nameEx("dirichletVertices")
> ### * dirichletVertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dirichletVertices
> ### Title: Vertices and Edges of Dirichlet Tessellation
> ### Aliases: dirichletVertices dirichletEdges
> ### Keywords: spatial math manip
> 
> ### ** Examples
> 
>   plot(dirichlet(cells))
> 
>   plot(dirichletVertices(cells), add=TRUE)
> 
>   ed <- dirichletEdges(cells)
> 
> 
> 
> cleanEx()
> nameEx("dirichletWeights")
> ### * dirichletWeights
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dirichletWeights
> ### Title: Compute Quadrature Weights Based on Dirichlet Tessellation
> ### Aliases: dirichletWeights
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>   Q <- quadscheme(runifpoispp(10))
>   X <- as.ppp(Q) # data and dummy points together
>   w <- dirichletWeights(X, exact=FALSE)
> 
> 
> 
> cleanEx()
> nameEx("disc")
> ### * disc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: disc
> ### Title: Circular Window
> ### Aliases: disc
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # unit disc
>  W <- disc()
>  # disc of radius 3 centred at x=10, y=5
>  W <- disc(3, c(10,5))
>  #
>  plot(disc())
>  plot(disc(mask=TRUE))
>  # nice smooth circle
>  plot(disc(npoly=256))
>  # how to control the resolution of the mask
>  plot(disc(mask=TRUE, dimyx=256))
>  # check accuracy of approximation
>  area(disc())/pi
[1] 0.9995985
>  area(disc(mask=TRUE))/pi
[1] 1.001868
> 
> 
> 
> cleanEx()
> nameEx("discpartarea")
> ### * discpartarea
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: discpartarea
> ### Title: Area of Part of Disc
> ### Aliases: discpartarea
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(letterR)
>   X <- runifpoint(3, letterR)
>   discpartarea(X, 0.2)
           [,1]
[1,] 0.12566371
[2,] 0.12566371
[3,] 0.07410285
> 
> 
> 
> cleanEx()
> nameEx("discretise")
> ### * discretise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: discretise
> ### Title: Safely Convert Point Pattern Window to Binary Mask
> ### Aliases: discretise
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(demopat)
>   X <- demopat
>   plot(X, main="original pattern")
>   Y <- discretise(X, dimyx=50)
>   plot(Y, main="discretise(X)")
>   stopifnot(npoints(X) == npoints(Y))
> 
>   # what happens if we just convert the window to a mask?
>   W <- Window(X)
>   M <- as.mask(W, dimyx=50)
>   plot(M, main="window of X converted to mask")
>   plot(X, add=TRUE, pch=16)
>   plot(X[M], add=TRUE, pch=1, cex=1.5)
>   XM <- X[M]
>   cat(paste(npoints(X) - npoints(XM), "points of X lie outside M\n"))
3 points of X lie outside M
> 
> 
> 
> cleanEx()
> nameEx("discs")
> ### * discs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: discs
> ### Title: Union of Discs
> ### Aliases: discs
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   plot(discs(anemones, mask=TRUE, eps=0.5))
> 
> 
> 
> cleanEx()
> nameEx("distcdf")
> ### * distcdf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distcdf
> ### Title: Distribution Function of Interpoint Distance
> ### Aliases: distcdf
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>  # The unit disc
>  B <- disc()
>  plot(distcdf(B))
> 
> 
> 
> cleanEx()
> nameEx("distfun")
> ### * distfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distfun
> ### Title: Distance Map as a Function
> ### Aliases: distfun distfun.ppp distfun.psp distfun.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(letterR)
>    f <- distfun(letterR)
>    f
Distance function for window
window: polygonal boundary
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
>    plot(f)
>    f(0.2, 0.3)
[1] 1.850972
> 
>    plot(distfun(letterR, invert=TRUE), eps=0.1)
> 
>    d <- distfun(cells)
>    d2 <- distfun(cells, k=2)
>    d(0.5, 0.5)
[1] 0.08407735
>    d2(0.5, 0.5)
[1] 0.09730879
>    domain(d)
window: rectangle = [0, 1] x [0, 1] units
>    summary(d)
Distance function for point pattern
defined in the rectangle [0, 1] x [0, 1] units

Distance function values:
	range = [0.0006200506, 0.2462214]
	mean = 0.06654729
> 
>    z <- d(japanesepines)
> 
> 
> 
> cleanEx()
> nameEx("distfun.lpp")
> ### * distfun.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distfun.lpp
> ### Title: Distance Map on Linear Network
> ### Aliases: distfun.lpp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(letterR)
>    X <- runiflpp(3, simplenet)
>    f <- distfun(X)
>    f
Distance function for lpp object
Point pattern on linear network
3 points
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>    plot(f)
> 
>    # using a distfun as a covariate in a point process model:
>    Y <- runiflpp(4, simplenet)
>    fit <- lppm(Y ~D, covariates=list(D=f))
> 
>    f(Y)
[1] 0.1854072 0.2484920 0.3829448 0.2184711
> 
> 
> 
> cleanEx()
> nameEx("distmap")
> ### * distmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distmap
> ### Title: Distance Map
> ### Aliases: distmap
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(cells)
>   U <- distmap(cells)
>   data(letterR)
>   V <- distmap(letterR)
>   ## Not run: 
> ##D   plot(U)
> ##D   plot(V)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("distmap.owin")
> ### * distmap.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distmap.owin
> ### Title: Distance Map of Window
> ### Aliases: distmap.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(letterR)
>   U <- distmap(letterR)
>   ## Not run: 
> ##D   plot(U)
> ##D   plot(attr(U, "bdry"))
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("distmap.ppp")
> ### * distmap.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distmap.ppp
> ### Title: Distance Map of Point Pattern
> ### Aliases: distmap.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(cells)
>   U <- distmap(cells)
>   ## Not run: 
> ##D   plot(U)
> ##D   plot(attr(U, "bdry"))
> ##D   plot(attr(U, "index"))
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("distmap.psp")
> ### * distmap.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distmap.psp
> ### Title: Distance Map of Line Segment Pattern
> ### Aliases: distmap.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>     a <- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
>     Z <- distmap(a)
>     plot(Z)
>     plot(a, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("divide.linnet")
> ### * divide.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: divide.linnet
> ### Title: Divide Linear Network at Cut Points
> ### Aliases: divide.linnet
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runiflpp(5, simplenet)
>   plot(divide.linnet(X))
>   plot(X, add=TRUE, pch=16, show.network=FALSE)
> 
> 
> 
> cleanEx()
> nameEx("dkernel")
> ### * dkernel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dkernel
> ### Title: Kernel distributions and random generation
> ### Aliases: dkernel pkernel qkernel rkernel
> ### Keywords: methods nonparametric smooth
> 
> ### ** Examples
> 
>   x <- seq(-3,3,length=100)
>   plot(x, dkernel(x, "epa"), type="l",
+            main=c("Epanechnikov kernel", "probability density"))
>   plot(x, pkernel(x, "opt"), type="l",
+            main=c("OptCosine kernel", "cumulative distribution function"))
>   p <- seq(0,1, length=256)
>   plot(p, qkernel(p, "biw"), type="l",
+            main=c("Biweight kernel", "cumulative distribution function"))
>   y <- rkernel(100, "tri")
>   hist(y, main="Random variates from triangular density")
>   rug(y)
> 
> 
> 
> cleanEx()
> nameEx("dmixpois")
> ### * dmixpois
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dmixpois
> ### Title: Mixed Poisson Distribution
> ### Aliases: dmixpois pmixpois qmixpois rmixpois
> ### Keywords: distribution
> 
> ### ** Examples
> 
>   dmixpois(7, 10, 1, invlink = I)
[1] 0.09060176
>   dpois(7, 10)
[1] 0.09007923
> 
>   pmixpois(7, log(10), 0.2)
[1] 0.2501509
>   ppois(7, 10)
[1] 0.2202206
> 
>   qmixpois(0.95, log(10), 0.2)
[1] 16
>   qpois(0.95, 10)
[1] 15
> 
>   x <- rmixpois(100, log(10), log(1.2))
>   mean(x)
[1] 9.67
>   var(x)
[1] 10.99101
> 
> 
> 
> cleanEx()
> nameEx("domain")
> ### * domain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: domain
> ### Title: Extract the Domain of any Spatial Object
> ### Aliases: domain domain.ppp domain.psp domain.im domain.ppx domain.pp3
> ###   domain.lpp domain.ppm domain.kppm domain.dppm domain.lpp domain.lppm
> ###   domain.msr domain.quad domain.quadratcount domain.quadrattest
> ###   domain.tess domain.linfun domain.lintess domain.im domain.layered
> ###   domain.distfun domain.nnfun domain.funxy domain.rmhmodel
> ###   domain.leverage.ppm domain.influence.ppm
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   domain(cells)
window: rectangle = [0, 1] x [0, 1] units
>   domain(bei.extra$elev)
window: binary image mask
101 x 201 pixel array (ny, nx)
enclosing rectangle: [-2.5, 1002.5] x [-2.5, 502.5] metres
>   domain(chicago)
Linear network with 338 vertices and 503 lines
Enclosing window: rectangle = [0.3894, 1281.9863] x [153.1035, 1276.5602] feet
> 
> 
> 
> cleanEx()
> nameEx("dppBessel")
> ### * dppBessel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppBessel
> ### Title: Bessel Type Determinantal Point Process Model
> ### Aliases: dppBessel
> 
> ### ** Examples
> 
> m <- dppBessel(lambda=100, alpha=.05, sigma=0, d=2)
> 
> 
> 
> cleanEx()
> nameEx("dppCauchy")
> ### * dppCauchy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppCauchy
> ### Title: Generalized Cauchy Determinantal Point Process Model
> ### Aliases: dppCauchy
> 
> ### ** Examples
> 
> m <- dppCauchy(lambda=100, alpha=.05, nu=1, d=2)
> 
> 
> 
> cleanEx()
> nameEx("dppGauss")
> ### * dppGauss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppGauss
> ### Title: Gaussian Determinantal Point Process Model
> ### Aliases: dppGauss
> 
> ### ** Examples
> 
> m <- dppGauss(lambda=100, alpha=.05, d=2)
> 
> 
> 
> cleanEx()
> nameEx("dppMatern")
> ### * dppMatern
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppMatern
> ### Title: Whittle-Matern Determinantal Point Process Model
> ### Aliases: dppMatern
> 
> ### ** Examples
> 
> m <- dppMatern(lambda=100, alpha=.02, nu=1, d=2)
> 
> 
> 
> cleanEx()
> nameEx("dppPowerExp")
> ### * dppPowerExp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppPowerExp
> ### Title: Power Exponential Spectral Determinantal Point Process Model
> ### Aliases: dppPowerExp
> 
> ### ** Examples
> 
> m <- dppPowerExp(lambda=100, alpha=.01, nu=1, d=2)
> 
> 
> 
> cleanEx()
> nameEx("dppapproxpcf")
> ### * dppapproxpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppapproxpcf
> ### Title: Approximate Pair Correlation Function of Determinantal Point
> ###   Process Model
> ### Aliases: dppapproxpcf
> 
> ### ** Examples
> 
> f <- dppapproxpcf(dppMatern(lambda = 100, alpha=.028, nu=1, d=2))
> plot(f, xlim = c(0,0.1))
> 
> 
> 
> cleanEx()
> nameEx("dppkernel")
> ### * dppkernel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppkernel
> ### Title: Extract Kernel from Determinantal Point Process Model Object
> ### Aliases: dppkernel
> ### Keywords: spatial models
> 
> ### ** Examples
> 
> kernelMatern <- dppkernel(dppMatern(lambda = 100, alpha=.01, nu=1, d=2))
> plot(kernelMatern, xlim = c(0,0.1))
> 
> 
> 
> cleanEx()
> nameEx("dppm")
> ### * dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppm
> ### Title: Fit Determinantal Point Process Model
> ### Aliases: dppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   jpines <- residualspaper$Fig1
>   ## Don't show: 
>      # smaller dataset for testing
>     jpines <- jpines[c(TRUE,FALSE)]
>   
> ## End(Don't show)
> 
>   dppm(jpines ~ 1, dppGauss)
Stationary determinantal point process model
Fitted to point pattern dataset 'jpines'
Fitted by minimum contrast
	Summary statistic: K-function

Uniform intensity:	1.02

Fitted DPP model:
Gaussian determinantal point process model
The parameters are: lambda = 1.02, alpha = 0.1814, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.
> 
>   dppm(jpines ~ 1, dppGauss, method="c")
Stationary determinantal point process model
Fitted to point pattern dataset 'jpines'
Fitted by maximum second order composite likelihood
	rmax = 2.5
	weight function: Indicator(distance <= 1.25)

Uniform intensity:	1.02

Fitted DPP model:
Gaussian determinantal point process model
The parameters are: lambda = 1.02, alpha = 0.2984, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.
>   dppm(jpines ~ 1, dppGauss, method="p")
Stationary determinantal point process model
Fitted to point pattern dataset 'jpines'
Fitted by maximum Palm likelihood
	rmax = 2.5
	weight function: Indicator(distance <= 1.25)

Uniform intensity:	1.02

Fitted DPP model:
Gaussian determinantal point process model
The parameters are: lambda = 1.02, alpha = 0.2815, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.
> 
>   # Fixing the intensity to lambda=2 rather than the Poisson MLE 2.04:
>   dppm(jpines ~ 1, dppGauss(lambda=2))
Stationary determinantal point process model
Fitted to point pattern dataset 'jpines'
Fitted by minimum contrast
	Summary statistic: K-function

Log intensity:  ~offset(log(lambda)) - 1

[No trend coefficients]

Fitted DPP model:
Gaussian determinantal point process model
The parameters are: lambda = 2, alpha = 0.1814, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.
> 
>   if(interactive()) {
+    # The following is quite slow (using K-function)
+    dppm(jpines ~ x, dppMatern)
+   }
> 
>    # much faster using pair correlation function
>   dppm(jpines ~ x, dppMatern, statistic="pcf", statargs=list(stoyan=0.2))
Warning: Some values of the empirical function 'pcf' were infinite or NA. Range of r values was reset to [0.0048828125, 2.5]
Inhomogeneous determinantal point process model
Fitted to point pattern dataset 'jpines'
Fitted by minimum contrast
	Summary statistic: inhomogeneous pair correlation function

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
-0.06524895  0.01677481 

Fitted DPP model:
Whittle-Matern determinantal point process model
The parameters are: lambda = an image, nu = 0.3405, alpha = 0.3569, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.
> 
>   # Fixing the Matern shape parameter to nu=2 rather than estimating it:
>   dppm(jpines ~ x, dppMatern(nu=2))
Inhomogeneous determinantal point process model
Fitted to point pattern dataset 'jpines'
Fitted by minimum contrast
	Summary statistic: inhomogeneous K-function

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
-0.06524895  0.01677481 

Fitted DPP model:
Whittle-Matern determinantal point process model
The parameters are: lambda = an image, alpha = 0.07294, nu = 2, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.
> 
> 
> 
> cleanEx()
> nameEx("dppparbounds")
> ### * dppparbounds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppparbounds
> ### Title: Parameter Bound for a Determinantal Point Process Model
> ### Aliases: dppparbounds
> ### Keywords: spatial models
> 
> ### ** Examples
> 
> model <- dppMatern(lambda=100, alpha=.01, nu=1, d=2)
> dppparbounds(model, "lambda")
       lower    upper
lambda     0 795.7747
> 
> 
> 
> cleanEx()
> nameEx("dppspecden")
> ### * dppspecden
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppspecden
> ### Title: Extract Spectral Density from Determinantal Point Process Model
> ###   Object
> ### Aliases: dppspecden
> ### Keywords: spatial models
> 
> ### ** Examples
> 
> model <- dppMatern(lambda = 100, alpha=.01, nu=1, d=2)
> dppspecden(model)
function (x, ...) 
{
    allargs <- c(list(x), model$fixedpar, list(...))
    do.call(fun, allargs)
}
<bytecode: 0x000000001b16de90>
<environment: 0x00000000227cdea0>
> 
> 
> 
> cleanEx()
> nameEx("dppspecdenrange")
> ### * dppspecdenrange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dppspecdenrange
> ### Title: Range of Spectral Density of a Determinantal Point Process Model
> ### Aliases: dppspecdenrange
> ### Keywords: spatial models
> 
> ### ** Examples
> 
> m <- dppBessel(lambda=100, alpha=0.05, sigma=1, d=2)
> dppspecdenrange(m)
[1] 7.796968
> 
> 
> 
> cleanEx()
> nameEx("dummify")
> ### * dummify
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dummify
> ### Title: Convert Data to Numeric Values by Constructing Dummy Variables
> ### Aliases: dummify
> ### Keywords: math
> 
> ### ** Examples
> 
>    chara <- sample(letters[1:3], 8, replace=TRUE)
>    logi <- (runif(8) < 0.3)
>    comp <- round(4*runif(8) + 3*runif(8) * 1i, 1)
>    nume <- 8:1 + 0.1
>    df <- data.frame(nume, chara, logi, comp)
>    df
  nume chara  logi     comp
1  8.1     a  TRUE 4.0+1.2i
2  7.1     c  TRUE 1.5+0.0i
3  6.1     a  TRUE 3.1+1.1i
4  5.1     b FALSE 3.7+2.6i
5  4.1     a FALSE 0.8+1.0i
6  3.1     c FALSE 2.6+1.4i
7  2.1     c FALSE 0.5+1.8i
8  1.1     b FALSE 1.1+1.5i
>    dummify(df)
     nume chara.a chara.b chara.c logi.FALSE logi.TRUE comp.Re comp.Im
[1,]  8.1       1       0       0          0         1     4.0     1.2
[2,]  7.1       0       0       1          0         1     1.5     0.0
[3,]  6.1       1       0       0          0         1     3.1     1.1
[4,]  5.1       0       1       0          1         0     3.7     2.6
[5,]  4.1       1       0       0          1         0     0.8     1.0
[6,]  3.1       0       0       1          1         0     2.6     1.4
[7,]  2.1       0       0       1          1         0     0.5     1.8
[8,]  1.1       0       1       0          1         0     1.1     1.5
> 
> 
> 
> cleanEx()
> nameEx("dummy.ppm")
> ### * dummy.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dummy.ppm
> ### Title: Extract Dummy Points Used to Fit a Point Process Model
> ### Aliases: dummy.ppm
> ### Keywords: spatial utilities models
> 
> ### ** Examples
> 
>  data(cells)
>  fit <- ppm(cells, ~1, Strauss(r=0.1))
>  X <- dummy.ppm(fit)
>  npoints(X)
[1] 1028
>  # this is the number of dummy points in the quadrature scheme
> 
> 
> 
> cleanEx()
> nameEx("duplicated.ppp")
> ### * duplicated.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: duplicated.ppp
> ### Title: Determine Duplicated Points in a Spatial Point Pattern
> ### Aliases: duplicated.ppp duplicated.ppx anyDuplicated.ppp
> ###   anyDuplicated.ppx
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    X <- ppp(c(1,1,0.5), c(2,2,1), window=square(3))
Warning: data contain duplicated points
>    duplicated(X)
[1] FALSE  TRUE FALSE
>    duplicated(X, rule="deldir")
[1] FALSE  TRUE FALSE
> 
> 
> 
> cleanEx()
> nameEx("edge.Ripley")
> ### * edge.Ripley
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edge.Ripley
> ### Title: Ripley's Isotropic Edge Correction
> ### Aliases: edge.Ripley rmax.Ripley
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   v <- edge.Ripley(cells, pairdist(cells))
> 
>   rmax.Ripley(Window(cells))
[1] 0.7126311
> 
> 
> 
> cleanEx()
> nameEx("edge.Trans")
> ### * edge.Trans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edge.Trans
> ### Title: Translation Edge Correction
> ### Aliases: edge.Trans rmax.Trans
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   v <- edge.Trans(cells)
>   rmax.Trans(Window(cells))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("edges")
> ### * edges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edges
> ### Title: Extract Boundary Edges of a Window.
> ### Aliases: edges
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   edges(square(1))
planar line segment pattern: 4 line segments
window: rectangle = [0, 1] x [0, 1] units
>   edges(letterR)
planar line segment pattern: 34 line segments
window: rectangle = [2.017, 3.93] x [0.645, 3.278] units
> 
> 
> 
> cleanEx()
> nameEx("edges2triangles")
> ### * edges2triangles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edges2triangles
> ### Title: List Triangles in a Graph
> ### Aliases: edges2triangles
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  i <- c(1, 2, 5, 5, 1, 4, 2)
>  j <- c(2, 3, 3, 1, 3, 2, 5)
>  edges2triangles(i, j)
     i j k
[1,] 1 2 3
[2,] 1 2 5
[3,] 1 3 5
[4,] 2 3 5
> 
> 
> 
> cleanEx()
> nameEx("edges2vees")
> ### * edges2vees
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edges2vees
> ### Title: List Dihedral Triples in a Graph
> ### Aliases: edges2vees
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  i <- c(1, 2, 5, 5, 1, 4, 2)
>  j <- c(2, 3, 3, 1, 3, 2, 5)
>  edges2vees(i, j)
   i j k
1  1 2 5
2  1 2 3
3  1 5 3
4  2 1 3
5  2 1 4
6  2 1 5
7  2 3 4
8  2 3 5
9  2 4 5
10 3 2 5
11 3 2 1
12 3 5 1
13 5 3 1
14 5 3 2
15 5 1 2
> 
> 
> 
> cleanEx()
> nameEx("edit.hyperframe")
> ### * edit.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edit.hyperframe
> ### Title: Invoke Text Editor on Hyperframe
> ### Aliases: edit.hyperframe
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   if(interactive()) Z <- edit(flu)
> 
> 
> 
> cleanEx()
> nameEx("edit.ppp")
> ### * edit.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edit.ppp
> ### Title: Invoke Text Editor on Spatial Data
> ### Aliases: edit.ppp edit.psp edit.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   if(interactive()) Z <- edit(cells)
> 
> 
> 
> cleanEx()
> nameEx("eem")
> ### * eem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eem
> ### Title: Exponential Energy Marks
> ### Aliases: eem
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(cells)
>     fit <- ppm(cells, ~x, Strauss(r=0.15))
>     ee <- eem(fit)
>     sum(ee)/area(Window(cells)) # should be about 1 if model is correct
[1] 0.9741042
>     Y <- setmarks(cells, ee)
>     plot(Y, main="Cells data\n Exponential energy marks")
> 
> 
> 
> cleanEx()
> nameEx("effectfun")
> ### * effectfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: effectfun
> ### Title: Compute Fitted Effect of a Spatial Covariate in a Point Process
> ###   Model
> ### Aliases: effectfun
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <- copper$SouthPoints
>   D <- distfun(copper$SouthLines)
>   fit <- ppm(X ~ polynom(D, 5))
>   effectfun(fit)
Function value object (class 'fv')
for the function D -> lambda(D)
Warning in sprintf(desc, ylab) : argument not used by format
..........................................
       Math.label     Description         
D      D              value of covariate D
lambda hat(lambda)(D) fitted intensity    
..........................................
Default plot formula:  lambda~D
where "." stands for 'lambda'
Recommended range of argument D: [0.00018776, 10.251]
Available range of argument D: [0.00018776, 10.251]
>   plot(effectfun(fit, se.fit=TRUE))
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
>   fitx <- ppm(X ~ x + polynom(D, 5))
>   plot(effectfun(fitx, "D", x=20))
> 
> 
> 
> cleanEx()
> nameEx("ellipse")
> ### * ellipse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ellipse
> ### Title: Elliptical Window.
> ### Aliases: ellipse
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   W <- ellipse(a=5,b=2,centre=c(5,1),phi=pi/6)
>   plot(W,lwd=2,border="red")
>   WM <- ellipse(a=5,b=2,centre=c(5,1),phi=pi/6,mask=TRUE,dimyx=512)
>   plot(WM,add=TRUE,box=FALSE)
> 
> 
> 
> cleanEx()
> nameEx("emend.ppm")
> ### * emend.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: emend.ppm
> ### Title: Force Point Process Model to be Valid
> ### Aliases: emend.ppm project.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit <- ppm(redwood ~1, Strauss(0.1))
>    coef(fit)
(Intercept) Interaction 
  3.0149180   0.3620901 
>    fit2 <- emend(fit)
>    coef(fit2)
(Intercept) 
   4.270122 
> 
> 
> 
> cleanEx()
> nameEx("endpoints.psp")
> ### * endpoints.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: endpoints.psp
> ### Title: Endpoints of Line Segment Pattern
> ### Aliases: endpoints.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(a)
>   b <- endpoints.psp(a, "left")
>   plot(b, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("envelope")
> ### * envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: envelope
> ### Title: Simulation Envelopes of Summary Function
> ### Aliases: envelope envelope.ppp envelope.ppm envelope.kppm
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>  X <- simdat
> 
>  # Envelope of K function under CSR
>  ## Not run: 
> ##D  plot(envelope(X))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   plot(envelope(X, nsim=3))
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>  
> ## End(Don't show)
> 
>  # Translation edge correction (this is also FASTER):
>  ## Not run: 
> ##D  plot(envelope(X, correction="translate"))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   E <- envelope(X, nsim=3, correction="translate")
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>  
> ## End(Don't show)
> 
> # Global envelopes
>  ## Not run: 
> ##D  plot(envelope(X, Lest, global=TRUE))
> ##D  plot(envelope(X, Kest,  global=TRUE, scale=function(r) { r }))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   E <- envelope(X, Lest, nsim=3, global=TRUE)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>   E <- envelope(X, Kest, nsim=3, global=TRUE, scale=function(r) { r })
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>   E
Simultaneous critical envelopes for K(r)
and observed value for 'X'
Edge correction: "iso"
Obtained from 3 simulations of CSR
Envelope based on maximum deviation of K(r) from null value for CSR (known 
exactly)
Alternative: two.sided
Significance level of simultaneous Monte Carlo test: 1/4 = 0.25
...........................................................
     Math.label     Description                            
r    r              distance argument r                    
obs  hat(K)[obs](r) observed value of K(r) for data pattern
theo K[theo](r)     theoretical value of K(r) for CSR      
lo   hat(K)[lo](r)  lower critical boundary for K(r)       
hi   hat(K)[hi](r)  upper critical boundary for K(r)       
...........................................................
Default plot formula:  .~r
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 2.5]
Available range of argument r: [0, 2.5]
>   summary(E)
Simultaneous critical envelopes for K(r)
and observed value for 'X'
Obtained from 3 simulations of CSR
Alternative: two.sided
Envelopes computed as theoretical curve plus/minus maximum simulated value of 
maximum absolute deviation
Significance level of Monte Carlo test: 1/4 = 0.25
Data: X
>  
> ## End(Don't show)
> 
>  # Envelope of K function for simulations from Gibbs model 
>  ## Not run: 
> ##D  fit <- ppm(cells ~1, Strauss(0.05))
> ##D  plot(envelope(fit))
> ##D  plot(envelope(fit), global=TRUE)
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   fit <- ppm(cells ~1, Strauss(0.05), nd=20)
>   E <- envelope(fit, nsim=3, correction="border", nrep=100)
Generating 3 simulated realisations of fitted Gibbs model  ...
1, 2,  3.

Done.
>   E <- envelope(fit, nsim=3, correction="border", global=TRUE, nrep=100)
Generating 6 simulated realisations of fitted Gibbs model (3 to estimate the 
mean and 3 to calculate envelopes) ...
1, 2, 3, 4, 5,  6.

Done.
>  
> ## End(Don't show)
> 
>  # Envelope of K function for simulations from cluster model 
>  fit <- kppm(redwood ~1, "Thomas")
>  ## Not run: 
> ##D  plot(envelope(fit, Gest))
> ##D  plot(envelope(fit, Gest, global=TRUE))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   E <- envelope(fit, Gest, correction="rs", nsim=3, global=TRUE, nrep=100)
Generating 6 simulated realisations of fitted cluster model (3 to estimate the 
mean and 3 to calculate envelopes) ...
1, 2, 3, 4, 5,  6.

Done.
>  
> ## End(Don't show)
> 
>  # Envelope of G function under CSR
>  ## Not run: 
> ##D  plot(envelope(X, Gest))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   E <- envelope(X, Gest, correction="rs", nsim=3)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>  
> ## End(Don't show)
> 
>  # Envelope of L function under CSR
>  #  L(r) = sqrt(K(r)/pi)
>  ## Not run: 
> ##D   E <- envelope(X, Kest)
> ##D   plot(E, sqrt(./pi) ~ r)
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   E <- envelope(X, Kest, correction="border", nsim=3)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>   plot(E, sqrt(./pi) ~ r)
>  
> ## End(Don't show)
> 
>  # Simultaneous critical envelope for L function
>  # (alternatively, use Lest)
>  ## Not run: 
> ##D   plot(envelope(X, Kest, transform=expression(sqrt(./pi)), global=TRUE))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   E <- envelope(X, Kest, nsim=3, correction="border",
+                transform=expression(sqrt(./pi)), global=TRUE)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>  
> ## End(Don't show)
> 
>  ## One-sided envelope
>  ## Not run: 
> ##D   plot(envelope(X, Lest, alternative="less"))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   E <- envelope(X, Lest, nsim=3, alternative="less")
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>  
> ## End(Don't show)
>  
>  # How to pass arguments needed to compute the summary functions:
>  # We want envelopes for Jcross(X, "A", "B") 
>  # where "A" and "B" are types of points in the dataset 'demopat'
> 
>  ## Not run: 
> ##D  plot(envelope(demopat, Jcross, i="A", j="B"))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>  plot(envelope(demopat, Jcross, correction="rs", i="A", j="B", nsim=3))
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>  
> ## End(Don't show)
>  
>  # Use of `simulate' expression
>  ## Not run: 
> ##D  plot(envelope(cells, Gest, simulate=expression(runifpoint(42))))
> ##D  plot(envelope(cells, Gest, simulate=expression(rMaternI(100,0.02))))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   plot(envelope(cells, Gest, correction="rs", simulate=expression(runifpoint(42)), nsim=3))
Generating 3 simulations by evaluating expression  ...
1, 2,  3.

Done.
>     plot(envelope(cells, Gest, correction="rs", simulate=expression(rMaternI(100, 0.02)),
+ nsim=3, global=TRUE))
Generating 6 simulations by evaluating expression (3 to estimate the mean and 3 
to calculate envelopes) ...
1, 2, 3, 4, 5,  6.

Done.
>  
> ## End(Don't show)
> 
>  # Use of `simulate' function
>  ## Not run: 
> ##D    plot(envelope(amacrine, Kcross, simulate=rlabel))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>    plot(envelope(amacrine, Kcross, simulate=rlabel, nsim=3))
Generating 3 simulations by evaluating function  ...
1, 2,  3.

Done.
>  
> ## End(Don't show)
> 
>  # Envelope under random toroidal shifts
>  ## Not run: 
> ##D  plot(envelope(amacrine, Kcross, i="on", j="off",
> ##D                simulate=expression(rshift(amacrine, radius=0.25)))) 
> ##D  
> ## End(Not run)
> 
>  # Envelope under random shifts with erosion
>  ## Not run: 
> ##D  plot(envelope(amacrine, Kcross, i="on", j="off",
> ##D               simulate=expression(rshift(amacrine, radius=0.1, edge="erode"))))
> ##D  
> ## End(Not run)
>   
>  # Envelope of INHOMOGENEOUS K-function with fitted trend
> 
>  # The following is valid.
>  # Setting lambda=fit means that the fitted model is re-fitted to
>  # each simulated pattern to obtain the intensity estimates for Kinhom.
>  # (lambda=NULL would also be valid)
> 
>  fit <- kppm(redwood ~1, clusters="MatClust")
>  ## Not run: 
> ##D     plot(envelope(fit, Kinhom, lambda=fit, nsim=19))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>     envelope(fit, Kinhom, lambda=fit, nsim=3)
Warning: The behaviour of Kinhom when lambda is a ppm object has changed (in spatstat 1.37-0 and later). See help(Kinhom)
Generating 3 simulated realisations of fitted cluster model  ...
1, 2,  3.

Done.
Pointwise critical envelopes for K[inhom](r)
and observed value for 'fit'
Edge correction: "iso"
Obtained from 3 simulations of fitted cluster model
Alternative: two.sided
Significance level of pointwise Monte Carlo test: 2/4 = 0.5
................................................................................
      Math.label              
r     r                       
obs   {hat(K)[inhom]^{obs}}(r)
mmean {bar(K)[inhom]}(r)      
lo    {hat(K)[inhom]^{lo}}(r) 
hi    {hat(K)[inhom]^{hi}}(r) 
      Description                                             
r     distance argument r                                     
obs   observed value of K[inhom](r) for data pattern          
mmean sample mean of K[inhom](r) from simulations             
lo    lower pointwise envelope of K[inhom](r) from simulations
hi    upper pointwise envelope of K[inhom](r) from simulations
................................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'mmean', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
>  
> ## End(Don't show)
> 
>  # Note that the principle of symmetry, essential to the validity of
>  # simulation envelopes, requires that both the observed and
>  # simulated patterns be subjected to the same method of intensity
>  # estimation. In the following example it would be incorrect to set the
>  # argument 'lambda=red.dens' in the envelope command, because this
>  # would mean that the inhomogeneous K functions of the simulated
>  # patterns would be computed using the intensity function estimated
>  # from the original redwood data, violating the symmetry.  There is
>  # still a concern about the fact that the simulations are generated
>  # from a model that was fitted to the data; this is only a problem in
>  # small datasets.
> 
> ## Not run: 
> ##D  red.dens <- density(redwood, sigma=bw.diggle)
> ##D  plot(envelope(redwood, Kinhom, sigma=bw.diggle,
> ##D          simulate=expression(rpoispp(red.dens))))
> ##D  
> ## End(Not run)
> 
>  # Precomputed list of point patterns
> ## Not run: 
> ##D  nX <- npoints(X)
> ##D  PatList <- list()
> ##D  for(i in 1:19) PatList[[i]] <- runifpoint(nX)
> ##D  E <- envelope(X, Kest, nsim=19, simulate=PatList)
> ## End(Not run)
> ## Don't show: 
>  PatList <- list()
>  for(i in 1:3) PatList[[i]] <- runifpoint(10)
>  E <- envelope(X, Kest, nsim=3, simulate=PatList)
Extracting 3 point patterns from list  ...
1, 2,  3.

Done.
> ## End(Don't show)
> 
> # re-using the same point patterns
> ## Not run: 
> ##D  EK <- envelope(X, Kest, savepatterns=TRUE)
> ##D  EG <- envelope(X, Gest, simulate=EK)
> ## End(Not run)
> ## Don't show: 
>  EK <- envelope(X, Kest, nsim=3, savepatterns=TRUE)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
>  EG <- envelope(X, Gest, nsim=3, simulate=EK)
Extracting 3 point patterns from list  ...
1, 2,  3.

Done.
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("envelope.envelope")
> ### * envelope.envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: envelope.envelope
> ### Title: Recompute Envelopes
> ### Aliases: envelope.envelope
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>   E <- envelope(cells, Kest, nsim=19, savefuns=TRUE, savepatterns=TRUE)
Generating 19 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,  19.

Done.
>   E2 <- envelope(E, nrank=2)
>   Eg <- envelope(E, global=TRUE)
>   EG <- envelope(E, Gest)
Extracting 19 point patterns from list  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,  19.

Done.
>   EL <- envelope(E, transform=expression(sqrt(./pi)))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("envelope.lpp")
> ### * envelope.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: envelope.lpp
> ### Title: Envelope for Point Patterns on Linear Network
> ### Aliases: envelope.lpp envelope.lppm
> ### Keywords: spatial
> 
> ### ** Examples
> 
>    if(interactive()) {
+      ns <- 39
+      np <- 40
+    } else { ns <- np <- 3 }
>    X <- runiflpp(np, simplenet)
> 
>    # uniform Poisson: random numbers of points
>    envelope(X, nsim=ns)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
Pointwise critical envelopes for K[L](r)
and observed value for 'X'
Edge correction: "est"
Obtained from 3 simulations of CSR
Alternative: two.sided
Significance level of pointwise Monte Carlo test: 2/4 = 0.5
..............................................................................
     Math.label           Description                                         
r    r                    distance argument r                                 
obs  {hat(K)[L]^{obs}}(r) observed value of K[L](r) for data pattern          
theo {K[L]^{theo}}(r)     theoretical value of K[L](r) for CSR                
lo   {hat(K)[L]^{lo}}(r)  lower pointwise envelope of K[L](r) from simulations
hi   {hat(K)[L]^{hi}}(r)  upper pointwise envelope of K[L](r) from simulations
..............................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
> 
>    # uniform Poisson: conditional on observed number of points
>    envelope(X, fix.n=TRUE, nsim=ns)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
Pointwise critical envelopes for K[L](r)
and observed value for 'X'
Edge correction: "est"
Obtained from 3 simulations of CSR
Alternative: two.sided
Significance level of pointwise Monte Carlo test: 2/4 = 0.5
..............................................................................
     Math.label           Description                                         
r    r                    distance argument r                                 
obs  {hat(K)[L]^{obs}}(r) observed value of K[L](r) for data pattern          
theo {K[L]^{theo}}(r)     theoretical value of K[L](r) for CSR                
lo   {hat(K)[L]^{lo}}(r)  lower pointwise envelope of K[L](r) from simulations
hi   {hat(K)[L]^{hi}}(r)  upper pointwise envelope of K[L](r) from simulations
..............................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
> 
>    # nonuniform Poisson
>    fit <- lppm(X ~x)
>    envelope(fit, nsim=ns)
Generating 3 simulated patterns  ...
1, 2,  3.

Done.
Pointwise critical envelopes for K[L](r)
and observed value for 'fit'
Edge correction: "est"
Obtained from 3
Alternative: two.sided
Significance level of pointwise Monte Carlo test: 2/4 = 0.5
...............................................................................
      Math.label           Description                                         
r     r                    distance argument r                                 
obs   {hat(K)[L]^{obs}}(r) observed value of K[L](r) for data pattern          
mmean {bar(K)[L]}(r)       sample mean of K[L](r) from simulations             
lo    {hat(K)[L]^{lo}}(r)  lower pointwise envelope of K[L](r) from simulations
hi    {hat(K)[L]^{hi}}(r)  upper pointwise envelope of K[L](r) from simulations
...............................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'mmean', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
> 
>    #multitype
>    marks(X) <- sample(letters[1:2], np, replace=TRUE)
>    envelope(X, nsim=ns)
Generating 3 simulations of CSR  ...
1, 2,  3.

Done.
Pointwise critical envelopes for K[L](r)
and observed value for 'X'
Edge correction: "est"
Obtained from 3 simulations of CSR
Alternative: two.sided
Significance level of pointwise Monte Carlo test: 2/4 = 0.5
..............................................................................
     Math.label           Description                                         
r    r                    distance argument r                                 
obs  {hat(K)[L]^{obs}}(r) observed value of K[L](r) for data pattern          
theo {K[L]^{theo}}(r)     theoretical value of K[L](r) for CSR                
lo   {hat(K)[L]^{lo}}(r)  lower pointwise envelope of K[L](r) from simulations
hi   {hat(K)[L]^{hi}}(r)  upper pointwise envelope of K[L](r) from simulations
..............................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
> 
> 
> 
> cleanEx()
> nameEx("envelope.pp3")
> ### * envelope.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: envelope.pp3
> ### Title: Simulation Envelopes of Summary Function for 3D Point Pattern
> ### Aliases: envelope.pp3
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>    X <- rpoispp3(20, box3())
>  ## Not run: 
> ##D  plot(envelope(X, nsim=39))
> ##D  
> ## End(Not run)
>  ## Don't show: 
>   plot(envelope(X, nsim=4))
Generating 4 simulations of CSR  ...
1, 2, 3,  4.

Done.
>  
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("envelopeArray")
> ### * envelopeArray
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: envelopeArray
> ### Title: Array of Simulation Envelopes of Summary Function
> ### Aliases: envelopeArray
> ### Keywords: spatial nonparametric iteration
> 
> ### ** Examples
> 
>   A <- envelopeArray(finpines, markcrosscorr, nsim=9)
>   plot(A)
> 
> 
> 
> cleanEx()
> nameEx("eroded.areas")
> ### * eroded.areas
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eroded.areas
> ### Title: Areas of Morphological Erosions
> ### Aliases: eroded.areas
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   w <- owin(c(0,1),c(0,1))
>   a <- eroded.areas(w, seq(0.01,0.49,by=0.01))
> 
> 
> 
> cleanEx()
> nameEx("erosion")
> ### * erosion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: erosion
> ### Title: Morphological Erosion by a Disc
> ### Aliases: erosion erosion.owin erosion.ppp erosion.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   plot(letterR, main="erosion(letterR, 0.2)")
>   plot(erosion(letterR, 0.2), add=TRUE, col="red")
> 
> 
> 
> cleanEx()
> nameEx("erosionAny")
> ### * erosionAny
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: erosionAny
> ### Title: Morphological Erosion of Windows
> ### Aliases: erosionAny %(-)%
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   B <- square(c(-0.1, 0.1))
>   RminusB <- letterR %(-)% B
>   FR <- grow.rectangle(Frame(letterR), 0.3)
>   plot(FR, main="", type="n")
>   plot(letterR, add=TRUE, lwd=2, hatch=TRUE, box=FALSE)
>   plot(RminusB, add=TRUE, col="blue", box=FALSE)
>   plot(shift(B, vec=c(3.49, 2.98)),
+        add=TRUE, border="red", lwd=2)
> 
> 
> 
> cleanEx()
> nameEx("eval.fasp")
> ### * eval.fasp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eval.fasp
> ### Title: Evaluate Expression Involving Function Arrays
> ### Aliases: eval.fasp
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   # manipulating the K function
>   K <- alltypes(amacrine, "K")
> 
>   # expressions involving a fasp object
>   eval.fasp(K + 3)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Function array (class 'fasp' )
Dimensions:  2 x 2 
Title: Result of eval.fasp(K + 3) 
>   L <- eval.fasp(sqrt(K/pi))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
>   # expression involving two fasp objects
>   D <- eval.fasp(K - L)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
>   # subtracting the unmarked K function from the cross-type K functions
>   K0 <- Kest(unmark(amacrine))
>   DK <- eval.fasp(K - K0)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
>   ## Use of 'envir'
>   S <- eval.fasp(1-G, list(G=alltypes(amacrine, "G")))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("eval.fv")
> ### * eval.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eval.fv
> ### Title: Evaluate Expression Involving Functions
> ### Aliases: eval.fv
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   # manipulating the K function
>   X <- rpoispp(42)
>   Ks <- Kest(X)
> 
>   eval.fv(Ks + 3)
Function value object (class 'fv')
Warning in (function (fmt, ...)  : argument not used by format
for the function r -> K(r)+3
Warning in (function (fmt, ...)  : argument not used by format
..................................................................
       Math.label         Description                             
r      r                  distance argument r                     
theo   K[pois](r)+3       theoretical Poisson K(r)+3              
border hat(K)[bord](r)+3  border-corrected estimate of K(r)+3     
trans  hat(K)[trans](r)+3 translation-corrected estimate of K(r)+3
iso    hat(K)[iso](r)+3   isotropic-corrected estimate of K(r)+3  
..................................................................
Default plot formula:  .~.x
where "." stands for 'iso', 'trans', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
>   Ls <- eval.fv(sqrt(Ks/pi))
> 
>   # manipulating two K functions
>   Y <- rpoispp(20)
>   Kr <- Kest(Y)
>   
>   Kdif <- eval.fv(Ks - Kr)
>   Z <- eval.fv(sqrt(Ks/pi) - sqrt(Kr/pi))
> 
>   ## Use of 'envir'
>   U <- eval.fv(sqrt(K), list(K=Kest(cells)))
> 
>   ## Use of 'equiv'
>   Fc <- Fest(cells)
>   Gc <- Gest(cells)
>   # Hanisch and Chiu-Stoyan estimators are cognate
>   Dc <- eval.fv(Fc - Gc, equiv=list(cs="han"))
Warning in eval.fv(Fc - Gc, equiv = list(cs = "han")) :
   the functions 'Fc' and 'Gc' were not compatible: enforcing compatibility
> 
> 
> 
> cleanEx()
> nameEx("eval.im")
> ### * eval.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eval.im
> ### Title: Evaluate Expression Involving Pixel Images
> ### Aliases: eval.im
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   # test images
>   X <- as.im(function(x,y) { x^2 - y^2 }, unit.square())
>   Y <- as.im(function(x,y) { 3 * x + y }, unit.square())
> 
>   eval.im(X + 3)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   eval.im(X - Y)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   eval.im(abs(X - Y))
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   Z <- eval.im(sin(X * pi) + Y)
> 
>   ## Use of 'envir'
>   W <- eval.im(sin(U), list(U=density(cells)))
> 
> 
> 
> cleanEx()
> nameEx("eval.linim")
> ### * eval.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eval.linim
> ### Title: Evaluate Expression Involving Pixel Images on Linear Network
> ### Aliases: eval.linim
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   M <- as.mask.psp(as.psp(simplenet))
>   Z <- as.im(function(x,y) {x-y}, W=M)
>   X <- linim(simplenet, Z)
>   X
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
> 
>   Y <- linfun(function(x,y,seg,tp){y^2+x}, simplenet)
>   Y <- as.linim(Y)
>   
>   eval.linim(X + 3)
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
>   eval.linim(X - Y)
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
>   eval.linim(abs(X - Y))
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
>   Z <- eval.linim(sin(X * pi) + Y)
> 
> 
> 
> cleanEx()
> nameEx("ewcdf")
> ### * ewcdf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ewcdf
> ### Title: Weighted Empirical Cumulative Distribution Function
> ### Aliases: ewcdf
> ### Keywords: nonparametric univar
> 
> ### ** Examples
> 
>    x <- rnorm(100)
>    w <- runif(100)
>    plot(e <- ewcdf(x,w))
>    e
Weighted empirical CDF 
Call: ewcdf(x, w)
 x[1:100] = -2.2147, -1.9894, -1.805,  ..., 2.1726, 2.4016
 weights[1:100] = 0.94797, 0.51013, 0.064458,  ..., 0.16958, 0.52399
> 
> 
> 
> cleanEx()
> nameEx("exactMPLEstrauss")
> ### * exactMPLEstrauss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: exactMPLEstrauss
> ### Title: Exact Maximum Pseudolikelihood Estimate for Stationary Strauss
> ###   Process
> ### Aliases: exactMPLEstrauss
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>  if(interactive()) {
+    rc <- 0.09
+    exactMPLEstrauss(cells, rc, plotit=TRUE)
+    coef(ppm(cells ~1, Strauss(rc)))
+    coef(ppm(cells ~1, Strauss(rc), nd=128))
+    rr <- 0.04
+    exactMPLEstrauss(redwood, rr)
+    exactMPLEstrauss(redwood, rr, project=FALSE)
+    coef(ppm(redwood ~1, Strauss(rr)))
+  } else {
+    rc <- 0.09
+    exactMPLEstrauss(cells, rc, ngrid=64, plotit=TRUE)
+    exactMPLEstrauss(cells, rc, ngrid=64, project=FALSE)
+  }
(Intercept) Interaction 
   6.469838   -5.004345 
> 
> 
> 
> cleanEx()
> nameEx("expand.owin")
> ### * expand.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expand.owin
> ### Title: Apply Expansion Rule
> ### Aliases: expand.owin
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    expand.owin(square(1), 9)
window: rectangle = [-1, 2] x [-1, 2] units
>    expand.owin(square(1), distance=0.5)
window: rectangle = [-0.5, 1.5] x [-0.5, 1.5] units
>    expand.owin(letterR, length=2)
window: rectangle = [1.0605, 4.8865] x [-0.6715, 4.5945] units
>    expand.owin(letterR, distance=0.1)
window: polygonal boundary
enclosing rectangle: [1.917, 4.029452] x [0.545026, 3.378] units
> 
> 
> 
> cleanEx()
> nameEx("extrapolate.psp")
> ### * extrapolate.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extrapolate.psp
> ### Title: Extrapolate Line Segments to Obtain Infinite Lines
> ### Aliases: extrapolate.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- psp(runif(4), runif(4), runif(4), runif(4), window=owin())
>    Y <- extrapolate.psp(X)
>    plot(X, col=3, lwd=4)
>    plot(Y, lty=3)
>    Y
4 infinite lines
           a         b  h  v           p    theta
1 -0.1527194 1.3348012 NA NA -0.09156709 2.498620
2  0.2817126 1.6571821 NA NA  0.14554851 2.598652
3  0.6716855 0.4765439 NA NA  0.60635510 2.015504
4  0.4583415 0.2229185 NA NA  0.44736096 1.790129
> 
> 
> 
> cleanEx()
> nameEx("fardist")
> ### * fardist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fardist
> ### Title: Farthest Distance to Boundary of Window
> ### Aliases: fardist fardist.ppp fardist.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   fardist(cells)
 [1] 1.1718042 1.0472526 1.1437959 1.2454919 1.2026013 1.2225130 1.1422211
 [8] 1.0306522 0.9754840 1.0608195 1.1344109 1.0298121 0.9818320 0.9004826
[15] 0.9107931 1.1638917 0.8538226 0.7874446 0.7972609 1.0078537 1.1134828
[22] 0.9861541 0.8845903 0.8040330 0.8875635 1.0092913 1.1118961 1.2009763
[29] 1.0502976 1.0010340 0.9230081 0.8355387 1.0075406 1.0718269 1.0961469
[36] 1.0320431 1.1502717 1.1876974 1.2297841 1.1610099 1.0485438 1.1371565
> 
>   plot(FR <- fardist(letterR))
> 
> 
> 
> cleanEx()
> nameEx("fasp.object")
> ### * fasp.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fasp.object
> ### Title: Function Arrays for Spatial Patterns
> ### Aliases: fasp.object
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
>   # multitype point pattern
>   data(amacrine)
>   GG <- alltypes(amacrine, "G")
>   plot(GG)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
>   # select the row corresponding to cells of type "on"
>   Gon <- GG["on", ]
>   plot(Gon)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
>   # extract the G function for i = "on", j = "off"
>   Gonoff <- GG["on", "off", drop=TRUE]
> 
>   # Fisher variance stabilising transformation
>   GGfish <- eval.fasp(asin(sqrt(GG)))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>   plot(GGfish)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("fitin")
> ### * fitin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitin.ppm
> ### Title: Extract the Interaction from a Fitted Point Process Model
> ### Aliases: fitin fitin.ppm fitin.profilepl
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    # unmarked 
>    model <- ppm(swedishpines ~1, PairPiece(seq(3,19,by=4)))
>    f <- fitin(model)
>    f
Piecewise constant pairwise interaction process
Interaction thresholds:	c(3, 7, 11, 15, 19)
Fitted interaction parameters gamma_i
    [0,3)     [3,7)    [7,11)   [11,15)   [15,19) 
0.2230159 0.1951625 0.6884220 1.0267194 0.8053309 
>    plot(f)
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
> # extract fitted interaction coefficients
>    coef(f)
(Intercept)  Interact.1  Interact.2  Interact.3  Interact.4  Interact.5 
-2.19026609 -1.50051214 -1.63392291 -0.37335332  0.02636867 -0.21650198 
> 
>    # multitype
>    # fit the stationary multitype Strauss process to `amacrine'
>    r <- 0.02 * matrix(c(1,2,2,1), nrow=2,ncol=2)
>    model <- ppm(amacrine ~1, MultiStrauss(r))
>    f <- fitin(model)
>    f
Multitype Strauss process
2 types of points
Possible types:
[1] off on 
Interaction radii:
     off   on
off 0.02 0.04
on  0.04 0.02
Fitted interaction parameters gamma_ij
          off        on
off 0.0000001 0.8968929
on  0.8968929 0.0000001
>    plot(f)
Warning in sprintf(legdesc, ylab) : argument not used by format
Warning in sprintf(legdesc, ylab) : argument not used by format
Warning in sprintf(legdesc, ylab) : argument not used by format
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("fitted.lppm")
> ### * fitted.lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted.lppm
> ### Title: Fitted Intensity for Point Process on Linear Network
> ### Aliases: fitted.lppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>    fit <- lppm(spiders~x+y)
>    a <- fitted(fit)
>    b <- fitted(fit, dataonly=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("fitted.mppm")
> ### * fitted.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted.mppm
> ### Title: Fitted Conditional Intensity for Multiple Point Process Model
> ### Aliases: fitted.mppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    model <- mppm(Bugs ~ x, data=hyperframe(Bugs=waterstriders),
+                            interaction=Strauss(7))
>    cifs <- fitted(model)
> 
> 
> 
> cleanEx()
> nameEx("fitted.ppm")
> ### * fitted.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted.ppm
> ### Title: Fitted Conditional Intensity for Point Process Model
> ### Aliases: fitted.ppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>     str <- ppm(cells ~x, Strauss(r=0.1))
>     lambda <- fitted(str)
> 
>     # extract quadrature points in corresponding order
>     quadpoints <- union.quad(quad.ppm(str))
> 
>     # plot conditional intensity values
>     # as circles centred on the quadrature points 
>     quadmarked <- setmarks(quadpoints, lambda)
>     plot(quadmarked)
> 
>     if(!interactive()) str <- ppm(cells ~ x)
> 
>     lambdaX <- fitted(str, leaveoneout=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("fitted.slrm")
> ### * fitted.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted.slrm
> ### Title: Fitted Probabilities for Spatial Logistic Regression
> ### Aliases: fitted.slrm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>   X <- rpoispp(42)
>   fit <- slrm(X ~ x+y)
>   plot(fitted(fit))
> 
> 
> 
> cleanEx()
> nameEx("fixef.mppm")
> ### * fixef.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fixef.mppm
> ### Title: Extract Fixed Effects from Point Process Model
> ### Aliases: fixef.mppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>  H <- hyperframe(Y = waterstriders)
>  # Tweak data to exaggerate differences
>  H$Y[[1]] <- rthin(H$Y[[1]], 0.3)
>  m1 <- mppm(Y ~ id,  data=H, Strauss(7))
>  fixef(m1)
(Intercept)         id2         id3 Interaction 
 -5.1643100   1.2762098   1.3979179  -0.1523316 
>  m2 <- mppm(Y ~ 1,  random=~1|id, data=H, Strauss(7))
iteration 1 
iteration 2 
iteration 3 
>  fixef(m2)
(Intercept) Interaction 
  -4.283330   -0.102682 
> 
> 
> 
> cleanEx()
> nameEx("flipxy")
> ### * flipxy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: flipxy
> ### Title: Exchange X and Y Coordinates
> ### Aliases: flipxy flipxy.owin flipxy.ppp flipxy.psp flipxy.im
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(cells)
>   X <- flipxy(cells)
> 
> 
> 
> cleanEx()
> nameEx("foo")
> ### * foo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: foo
> ### Title: Foo is Not a Real Name
> ### Aliases: foo plot.foo
> ### Keywords: documentation
> 
> ### ** Examples
> 
>   foo
Error: object 'foo' not found.

'foo' is not a defined variable or function.
It is a placeholder name, which serves only to demonstrate a concept. It 
represents the name of any desired object or function. Other placeholder names 
popular with computer scientists are 'bar', 'foobar', 'qux' and 'mork'.
> 
> 
> 
> cleanEx()
> nameEx("formula.fv")
> ### * formula.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formula.fv
> ### Title: Extract or Change the Plot Formula for a Function Value Table
> ### Aliases: formula.fv formula<- formula<-.fv
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    K <- Kest(cells)
>    formula(K)
[1] ".~r"
>    formula(K) <- (iso ~ r)
> 
> 
> 
> cleanEx()
> nameEx("formula.ppm")
> ### * formula.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: formula.ppm
> ### Title: Model Formulae for Gibbs Point Process Models
> ### Aliases: formula.ppm terms.ppm
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   data(cells)
>   fit <- ppm(cells, ~x)
>   formula(fit)
~x
>   terms(fit)  
~x
attr(,"variables")
list(x)
attr(,"factors")
  x
x 1
attr(,"term.labels")
[1] "x"
attr(,"order")
[1] 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 0
attr(,".Environment")
<environment: R_GlobalEnv>
> 
> 
> 
> cleanEx()
> nameEx("fourierbasis")
> ### * fourierbasis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fourierbasis
> ### Title: Fourier Basis Functions
> ### Aliases: fourierbasis fourierbasisraw
> 
> ### ** Examples
> 
> ## 27 rows of three dimensional Fourier frequencies:
> k <- expand.grid(-1:1,-1:1, -1:1)
> ## Two random points in the three dimensional unit box:
> x <- rbind(runif(3),runif(3))
> ## 27 by 2 resulting matrix:
> v <- fourierbasis(x, k)
> head(v)
                      [,1]                 [,2]
[1,]  0.2457315-0.9693379i 0.9986472-0.0519976i
[2,]  0.9408324+0.3388723i 0.8087524-0.5881492i
[3,] -0.4287980+0.9034004i 0.3572112-0.9340237i
[4,]  0.5271090+0.8497977i 0.3481645+0.9374334i
[5,] -0.8970486+0.4419319i 0.8030285+0.5959406i
[6,] -0.3525619-0.9357885i 0.9980978+0.0616499i
> 
> 
> 
> cleanEx()
> nameEx("fryplot")
> ### * fryplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fryplot
> ### Title: Fry Plot of Point Pattern
> ### Aliases: fryplot frypoints
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
> ## unmarked data
> fryplot(cells)
> Y <- frypoints(cells)
> 
> ## numerical marks
> fryplot(longleaf, width=4, axes=TRUE)
> 
> ## multitype points
> fryplot(amacrine, width=0.2,
+                   from=(marks(amacrine) == "on"),
+                   chars=c(3,16), cols=2:3,
+                   main="Fry plot centred at an On-cell")
> points(0,0)
> 
> 
> 
> cleanEx()
> nameEx("funxy")
> ### * funxy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: funxy
> ### Title: Spatial Function Class
> ### Aliases: funxy
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    f <- function(x,y) { x^2 + y^2 - 1} 
>    g <- funxy(f, square(2))
>    g
function(x,y) of class 'funxy'
window: rectangle = [0, 2] x [0, 2] units

Original function definition:
function (x, y) 
{
    x^2 + y^2 - 1
}
>    ## evaluate function at any x, y coordinates
>    g(0.2, 0.3)
[1] -0.87
>    ## evaluate function at the points of a point pattern
>    g(cells[1:4])
[1] -0.876875 -0.755262 -0.591731 -0.398750
> 
> 
> 
> cleanEx()
> nameEx("fv")
> ### * fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fv
> ### Title: Create a Function Value Table
> ### Aliases: fv
> ### Keywords: spatial classes
> 
> ### ** Examples
> 
>   df <- data.frame(r=seq(0,5,by=0.1))
>   df <- transform(df, a=pi*r^2, b=3*r^2)
>   X <- fv(df, "r", quote(A(r)),
+               "a", cbind(a, b) ~ r,
+               alim=c(0,4),
+               labl=c("r", "%s[true](r)", "%s[approx](r)"),
+               desc=c("radius of circle",
+                      "true area %s",
+                      "rough area %s"),
+               fname="A")
>   X
Function value object (class 'fv')
for the function r -> A(r)
...............................
  Math.label   Description     
r r            radius of circle
a A[true](r)   true area A(r)  
b A[approx](r) rough area A(r) 
...............................
Default plot formula:  cbind(a,b)~r
where "." stands for 'b', 'a'
Recommended range of argument r: [0, 4]
Available range of argument r: [0, 5]
> 
> 
> 
> cleanEx()
> nameEx("fv.object")
> ### * fv.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fv.object
> ### Title: Function Value Table
> ### Aliases: fv.object
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
>     data(cells)
>     K <- Kest(cells)
> 
>     class(K)
[1] "fv"         "data.frame"
> 
>     K  # prints a sensible summary
Function value object (class 'fv')
for the function r -> K(r)
..............................................................
       Math.label       Description                           
r      r                distance argument r                   
theo   K[pois](r)       theoretical Poisson K(r)              
border hat(K)[bord](r)  border-corrected estimate of K(r)     
trans  hat(K)[trans](r) translation-corrected estimate of K(r)
iso    hat(K)[iso](r)   isotropic-corrected estimate of K(r)  
..............................................................
Default plot formula:  .~r
where "." stands for 'iso', 'trans', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
>     plot(K)
> 
> 
> 
> cleanEx()
> nameEx("fvnames")
> ### * fvnames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fvnames
> ### Title: Abbreviations for Groups of Columns in Function Value Table
> ### Aliases: fvnames fvnames<-
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    K <- Kest(cells)
>    fvnames(K, ".y")
[1] "iso"
>    fvnames(K, ".y") <- "trans"
> 
> 
> 
> cleanEx()
> nameEx("gauss.hermite")
> ### * gauss.hermite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gauss.hermite
> ### Title: Gauss-Hermite Quadrature Approximation to Expectation for Normal
> ###   Distribution
> ### Aliases: gauss.hermite
> ### Keywords: math
> 
> ### ** Examples
> 
>   gauss.hermite(function(x) x^2, 3, 1)
[1] 10
> 
> 
> 
> cleanEx()
> nameEx("gridcentres")
> ### * gridcentres
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gridcentres
> ### Title: Rectangular grid of points
> ### Aliases: gridcentres gridcenters
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   w <- unit.square()
>   xy <- gridcentres(w, 10,15)
>   ## Not run: 
> ##D   plot(w)
> ##D   points(xy)
> ##D   
> ## End(Not run)
> 
>   bdry <- list(x=c(0.1,0.3,0.7,0.4,0.2),
+                y=c(0.1,0.1,0.5,0.7,0.3))
>   w <- owin(c(0,1), c(0,1), poly=bdry)
>   xy <- gridcentres(w, 30, 30)
>   ok <- inside.owin(xy$x, xy$y, w)
>   ## Not run: 
> ##D   plot(w)
> ##D   points(xy$x[ok], xy$y[ok])
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("gridweights")
> ### * gridweights
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gridweights
> ### Title: Compute Quadrature Weights Based on Grid Counts
> ### Aliases: gridweights
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   Q <- quadscheme(runifpoispp(10))
>   X <- as.ppp(Q) # data and dummy points together
>   w <- gridweights(X, 10)
>   w <- gridweights(X, c(10, 10))
> 
> 
> 
> cleanEx()
> nameEx("grow.boxx")
> ### * grow.boxx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grow.boxx
> ### Title: Add margins to box in any dimension
> ### Aliases: grow.boxx grow.box3
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   w <- boxx(c(0,10), c(0,10), c(0,10), c(0,10))
>   # add a margin of size 1 on both sides in all four dimensions
>   b12 <- grow.boxx(w, 1)
> 
>   # add margin of size 2 at left, and margin of size 3 at right,
>   # in each dimension.
>   v <- grow.boxx(w, 2, 3)
> 
> 
> 
> cleanEx()
> nameEx("grow.rectangle")
> ### * grow.rectangle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grow.rectangle
> ### Title: Add margins to rectangle
> ### Aliases: grow.rectangle
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   w <- square(10)
>   # add a margin of width 1 on all four sides
>   square12 <- grow.rectangle(w, 1)
> 
>   # add margin of width 3 on the right side
>   # and margin of height 4 on top.
>   v <- grow.rectangle(w, c(0,3), c(0,4))
> 
>   # grow by 5 percent on all sides
>   grow.rectangle(w, fraction=0.05)
window: rectangle = [-0.5, 10.5] x [-0.5, 10.5] units
> 
> 
> 
> cleanEx()
> nameEx("harmonic")
> ### * harmonic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: harmonic
> ### Title: Basis for Harmonic Functions
> ### Aliases: harmonic
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    # inhomogeneous point pattern
>    X <- unmark(longleaf)
>    ## Don't show: 
>      # smaller dataset
>      X <- X[seq(1,npoints(X), by=50)]
>    
> ## End(Don't show)
> 
>    # fit Poisson point process with log-cubic intensity
>    fit.3 <- ppm(X ~ polynom(x,y,3), Poisson())
> 
>    # fit Poisson process with log-cubic-harmonic intensity
>    fit.h <- ppm(X ~ harmonic(x,y,3), Poisson())
> 
>    # Likelihood ratio test
>    lrts <- 2 * (logLik(fit.3) - logLik(fit.h))
>    df <- with(coords(X),
+               ncol(polynom(x,y,3)) - ncol(harmonic(x,y,3)))
>    pval <- 1 - pchisq(lrts, df=df)
> 
> 
> 
> cleanEx()
> nameEx("harmonise.fv")
> ### * harmonise.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: harmonise.fv
> ### Title: Make Function Tables Compatible
> ### Aliases: harmonise.fv harmonize.fv
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    H <- harmonise(K=Kest(cells), G=Gest(cells))
>    H
$K
Function value object (class 'fv')
for the function r -> K(r)
..............................................................
       Math.label       Description                           
r      r                distance argument r                   
theo   K[pois](r)       theoretical Poisson K(r)              
border hat(K)[bord](r)  border-corrected estimate of K(r)     
trans  hat(K)[trans](r) translation-corrected estimate of K(r)
iso    hat(K)[iso](r)   isotropic-corrected estimate of K(r)  
..............................................................
Default plot formula:  .~r
where "." stands for 'iso', 'trans', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]

$G
Function value object (class 'fv')
for the function r -> G(r)
.....................................................................
        Math.label      Description                                  
r       r               distance argument r                          
theo    G[pois](r)      theoretical Poisson G(r)                     
han     hat(G)[han](r)  Hanisch estimate of G(r)                     
rs      hat(G)[bord](r) border corrected estimate of G(r)            
km      hat(G)[km](r)   Kaplan-Meier estimate of G(r)                
hazard  hat(h)[km](r)   Kaplan-Meier estimate of hazard function h(r)
theohaz h[pois](r)      theoretical Poisson hazard function h(r)     
.....................................................................
Default plot formula:  .~r
where "." stands for 'km', 'rs', 'han', 'theo'
Recommended range of argument r: [0, 0.15]
Available range of argument r: [0, 0.25]

>    ## Not run: 
> ##D       ## generates a warning about duplicated columns
> ##D       try(cbind(H$K, H$G))
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("harmonise.im")
> ### * harmonise.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: harmonise.im
> ### Title: Make Pixel Images Compatible
> ### Aliases: harmonise.im harmonize.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    A <- setcov(square(1))
>    B <- function(x,y) { x }
>    G <- density(runifpoint(42))
>    harmonise(X=A, Y=B, Z=G)
$X
real-valued pixel image
257 x 257 pixel array (ny, nx)
enclosing rectangle: [-1, 1] x [-1, 1] units

$Y
real-valued pixel image
257 x 257 pixel array (ny, nx)
enclosing rectangle: [-1, 1] x [-1, 1] units

$Z
real-valued pixel image
257 x 257 pixel array (ny, nx)
enclosing rectangle: [-1, 1] x [-1, 1] units

> 
> 
> 
> cleanEx()
> nameEx("harmonise.msr")
> ### * harmonise.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: harmonise.msr
> ### Title: Make Measures Compatible
> ### Aliases: harmonise.msr
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   fit1 <- ppm(cells ~ x)
>   fit2 <- ppm(rpoispp(ex=cells) ~ x)
>   m1 <- residuals(fit1)
>   m2 <- residuals(fit2)
>   harmonise(m1, m2)
List of spatial objects

[[1]]
Scalar-valued measure
Approximated by 1107 quadrature points
window: rectangle = [0, 1] x [0, 1] units
79 atoms
Total mass:
discrete = 42   continuous = -42.002   total = -0.0022471

[[2]]
Scalar-valued measure
Approximated by 1107 quadrature points
window: rectangle = [0, 1] x [0, 1] units
79 atoms
Total mass:
discrete = 37   continuous = -37.002   total = -0.0023863

attr(,"class")
[1] "solist" "list"  
>   s1 <- residuals(fit1, type="score")
>   s2 <- residuals(fit2, type="score")
>   harmonise(s1, s2)
List of spatial objects

[[1]]
2-dimensional vector-valued measure
vector components: '(Intercept)' and 'x'
Approximated by 1107 quadrature points
window: rectangle = [0, 1] x [0, 1] units
79 atoms
Total mass:
(Intercept):	 discrete = 42   continuous = -42.002   total = -0.0022471
x:	 discrete = 21.803   continuous = -21.818   total = -0.01507

[[2]]
2-dimensional vector-valued measure
vector components: '(Intercept)' and 'x'
Approximated by 1107 quadrature points
window: rectangle = [0, 1] x [0, 1] units
79 atoms
Total mass:
(Intercept):	 discrete = 37   continuous = -37.002   total = -0.0023863
x:	 discrete = 19.37   continuous = -19.385   total = -0.014214

attr(,"class")
[1] "solist" "list"  
> 
> 
> 
> cleanEx()
> nameEx("harmonise.owin")
> ### * harmonise.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: harmonise.owin
> ### Title: Make Windows Compatible
> ### Aliases: harmonise.owin harmonize.owin
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    harmonise(X=letterR,
+              Y=grow.rectangle(Frame(letterR), 0.2),
+              Z=as.mask(letterR, eps=0.1),
+              V=as.mask(letterR, eps=0.07))
List of spatial objects

X:
window: binary image mask
38 x 28 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units

Y:
window: binary image mask
44 x 34 pixel array (ny, nx)
enclosing rectangle: [1.817, 4.13] x [0.445, 3.478] units

Z:
window: binary image mask
38 x 28 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units

V:
window: binary image mask
38 x 28 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
> 
> 
> 
> cleanEx()
> nameEx("has.close")
> ### * has.close
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: has.close
> ### Title: Check Whether Points Have Close Neighbours
> ### Aliases: has.close has.close.default has.close.ppp has.close.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   has.close(redwood, 0.05)
 [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
[25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
[37]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
[49]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
[61] FALSE FALSE
>   with(split(amacrine), has.close(on, 0.05, off))
  [1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE
 [13]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE
 [25]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE
 [37]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
 [49]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE
 [61]  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE
 [73]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
 [85]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
 [97]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE
[109] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE
[121]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE
[133]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE
[145]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
>   with(osteo, sum(has.close(pts, 20)))
 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 
 2  0  2  0  2  0  0  0  2  0  0  0  4  2  0  0  4  0  0  4  4  9  0  4  0  2 
27 28 29 30 31 32 33 34 35 36 37 38 39 40 
 0  0  6  0  5  0  0  0  0  6  4  2  4  2 
> 
> 
> 
> cleanEx()
> nameEx("headtail")
> ### * headtail
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: headtail
> ### Title: First or Last Part of a Spatial Pattern
> ### Aliases: head.ppp head.ppx head.psp head.tess tail.ppp tail.ppx
> ###   tail.psp tail.tess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   head(cells)
Planar point pattern: 6 points
window: rectangle = [0, 1] x [0, 1] units
>   tail(as.psp(spiders), 10)
planar line segment pattern: 10 line segments
window: rectangle = [0, 1125] x [0, 1125] mm
>   head(dirichlet(cells), 4)
Tessellation
Tiles are irregular polygons
4 tiles (irregular windows)
window: polygonal boundary
enclosing rectangle: [0.196708, 0.95] x [0, 0.178393] units
> 
> 
> 
> cleanEx()
> nameEx("heatkernelapprox")
> ### * heatkernelapprox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: heatkernelapprox
> ### Title: Approximation to Heat Kernel on Linear Network at Source Point
> ### Aliases: heatkernelapprox
> ### Keywords: math
> 
> ### ** Examples
> 
>   X <- runiflpp(3,simplenet)
>   heatkernelapprox(X, 0.5)
[1] 0.6391116 0.4507228 0.6676062
> 
> 
> 
> cleanEx()
> nameEx("hextess")
> ### * hextess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hextess
> ### Title: Hexagonal Grid or Tessellation
> ### Aliases: hexgrid hextess
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   if(interactive()) {
+     W <- Window(chorley)
+     s <- 0.7
+   } else {
+     W <- letterR
+     s <- 0.3
+   }
>   plot(hextess(W, s))
>   plot(hexgrid(W, s), add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("hist.funxy")
> ### * hist.funxy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hist.funxy
> ### Title: Histogram of Values of a Spatial Function
> ### Aliases: hist.funxy
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   f <- funxy(function(x,y) {x^2}, unit.square())
>   hist(f)
> 
> 
> 
> cleanEx()
> nameEx("hist.im")
> ### * hist.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hist.im
> ### Title: Histogram of Pixel Values in an Image
> ### Aliases: hist.im
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   X <- as.im(function(x,y) {x^2}, unit.square())
>   hist(X)
>   hist(cut(X,3))
> 
> 
> 
> cleanEx()
> nameEx("hopskel")
> ### * hopskel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hopskel
> ### Title: Hopkins-Skellam Test
> ### Aliases: hopskel hopskel.test
> ### Keywords: spatial nonparametric htest
> 
> ### ** Examples
> 
>   hopskel(redwood)
[1] 0.1994674
>   hopskel.test(redwood, alternative="clustered")

	Hopkins-Skellam test of CSR
	using F distribution

data:  redwood
A = 0.21096, p-value < 2.2e-16
alternative hypothesis: clustered (A < 1)

> 
> 
> 
> cleanEx()
> nameEx("hotrod")
> ### * hotrod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hotrod
> ### Title: Heat Kernel for a One-Dimensional Rod
> ### Aliases: hotrod
> ### Keywords: math
> 
> ### ** Examples
> 
>   curve(hotrod(1, 0.1, x, 0.7))
> 
>   # check it's a probability density
>   f <- function(x) hotrod(1, 0.1, x, 0.7)
>   integrate(f, 0, 1)
1 with absolute error < 1.1e-14
> 
>   ## absorbing ends
>   curve(hotrod(1, 0.1, x, 0.7, ends="a"))
> 
> 
> 
> cleanEx()
> nameEx("hyperframe")
> ### * hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hyperframe
> ### Title: Hyper Data Frame
> ### Aliases: hyperframe
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  # equivalent to a data frame
>   hyperframe(X=1:10, Y=3)
Hyperframe:
    X Y
1   1 3
2   2 3
3   3 3
4   4 3
5   5 3
6   6 3
7   7 3
8   8 3
9   9 3
10 10 3
> 
>  # list of functions
>   hyperframe(f=list(sin, cos, tan))
Hyperframe:
           f
1 (function)
2 (function)
3 (function)
> 
>  # table of functions and matching expressions
>   hyperframe(f=list(sin, cos, tan),
+              e=list(expression(sin(x)), expression(cos(x)), expression(tan(x))))
Hyperframe:
           f            e
1 (function) (expression)
2 (function) (expression)
3 (function) (expression)
> 
>   hyperframe(X=1:10, Y=letters[1:10], Z=factor(letters[1:10]),
+     stringsAsFactors=FALSE)
Hyperframe:
    X Y Z
1   1 a a
2   2 b b
3   3 c c
4   4 d d
5   5 e e
6   6 f f
7   7 g g
8   8 h h
9   9 i i
10 10 j j
> 
>   lambda <- runif(4, min=50, max=100)
>   X <- lapply(as.list(lambda), function(x) { rpoispp(x) })
>   h <- hyperframe(lambda=lambda, X=X)
>   h
Hyperframe:
    lambda     X
1 63.27543 (ppp)
2 68.60619 (ppp)
3 78.64267 (ppp)
4 95.41039 (ppp)
> 
>   h$lambda2 <- lambda^2
>   h[, "lambda3"] <- lambda^3
>   h[, "Y"] <- X
> 
> 
> 
> cleanEx()
> nameEx("idw")
> ### * idw
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: idw
> ### Title: Inverse-distance weighted smoothing of observations at irregular
> ###   points
> ### Aliases: idw
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    # data frame of marks: trees marked by diameter and height
>    plot(idw(finpines))
>    idw(finpines, at="points")[1:5,]
  diameter   height
1 2.461173 2.665964
2 2.088545 2.236501
3 3.738953 3.473610
4 3.256478 3.217379
5 5.782369 4.727551
>    plot(idw(finpines, se=TRUE)$SE)
>    idw(finpines, at="points", se=TRUE)$SE[1:5, ]
  diameter   height
1 1.743696 1.172250
2 1.547144 1.056356
3 1.937995 1.190939
4 2.171413 1.405488
5 2.580404 1.514831
> 
> 
> 
> cleanEx()
> nameEx("im")
> ### * im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: im
> ### Title: Create a Pixel Image Object
> ### Aliases: im
> ### Keywords: spatial manip datagen
> 
> ### ** Examples
> 
>    vec <- rnorm(1200)
>    mat <- matrix(vec, nrow=30, ncol=40)
>    whitenoise <- im(mat)
>    whitenoise <- im(mat, xrange=c(0,1), yrange=c(0,1))
>    whitenoise <- im(mat, xcol=seq(0,1,length=40), yrow=seq(0,1,length=30))
>    whitenoise <- im(vec, xcol=seq(0,1,length=40), yrow=seq(0,1,length=30))
>    plot(whitenoise)
> 
>    # Factor-valued images:
>    f <- factor(letters[1:12])
>    dim(f) <- c(3,4)
>    Z <- im(f)
> 
>    # Factor image from other image:
>    cutwhite <- cut(whitenoise, 3)
>    plot(cutwhite)
> 
>    # Factor image from raw data
>    cutmat <- cut(mat, 3)
>    dim(cutmat) <- c(30,40)
>    cutwhite <- im(cutmat)
>    plot(cutwhite)
> 
> 
> 
> cleanEx()
> nameEx("im.apply")
> ### * im.apply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: im.apply
> ### Title: Apply Function Pixelwise to List of Images
> ### Aliases: im.apply
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   DA <- density(split(amacrine))
>   DA
List of pixel images

off:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1.6012] x [0, 1] units (one unit = 662 microns)

on:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1.6012] x [0, 1] units (one unit = 662 microns)
>   im.apply(DA, max)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1.6012] x [0, 1] units
>   im.apply(DA, sum)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1.6012] x [0, 1] units
> 
>   ## Example with incompatible patterns of NA values
>   Z <- density(split(ants))
>   B <- owin(c(438, 666), c(80, 310))
>   Z[[1]][B] <- NA
>   opa <- par(mfrow=c(2,2))
>   plot(Z[[1]])
>   plot(Z[[2]])
>   #' Default action: NA -> NA
>   plot(im.apply(Z, mean))
>   #' Use NA handling in mean.default
>   plot(im.apply(Z, mean, na.rm=TRUE, fun.handles.na=TRUE))
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("imcov")
> ### * imcov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: imcov
> ### Title: Spatial Covariance of a Pixel Image
> ### Aliases: imcov
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- as.im(square(1))
>   v <- imcov(X)
>   plot(v)
> 
> 
> 
> cleanEx()
> nameEx("improve.kppm")
> ### * improve.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: improve.kppm
> ### Title: Improve Intensity Estimate of Fitted Cluster Point Process Model
> ### Aliases: improve.kppm
> ### Keywords: spatial fit model
> 
> ### ** Examples
> 
>   # fit a Thomas process using minimum contrast estimation method 
>   # to model interaction between points of the pattern
>   fit0 <- kppm(bei ~ elev + grad, data = bei.extra)
> 
>   # fit the log-linear intensity model with quasi-likelihood method
>   fit1 <- improve.kppm(fit0, type="quasi")
> 
>   # compare
>   coef(fit0)
(Intercept)        elev        grad 
-8.56355220  0.02143995  5.84646680 
>   coef(fit1)
 (Intercept)         elev         grad 
-10.08265063   0.03095423   6.77176986 
> 
> 
> 
> cleanEx()
> nameEx("incircle")
> ### * incircle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: incircle
> ### Title: Find Largest Circle Inside Window
> ### Aliases: incircle inradius
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   W <- square(1)
>   Wc <- incircle(W)
>   plot(W)
>   plot(disc(Wc$r, c(Wc$x, Wc$y)), add=TRUE)
> 
>   plot(letterR)
>   Rc <- incircle(letterR)
>   plot(disc(Rc$r, c(Rc$x, Rc$y)), add=TRUE)
> 
>   W <- as.mask(letterR)
>   plot(W)
>   Rc <- incircle(W)
>   plot(disc(Rc$r, c(Rc$x, Rc$y)), add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("increment.fv")
> ### * increment.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: increment.fv
> ### Title: Increments of a Function
> ### Aliases: increment.fv
> ### Keywords: spatial math nonparametric
> 
> ### ** Examples
> 
>   plot(increment.fv(Kest(cells), 0.05))
> 
> 
> 
> cleanEx()
> nameEx("infline")
> ### * infline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: infline
> ### Title: Infinite Straight Lines
> ### Aliases: infline plot.infline print.infline
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   infline(a=10:13,b=1)
4 infinite lines
   a b  h  v        p    theta
1 10 1 NA NA 7.071068 2.356194
2 11 1 NA NA 7.778175 2.356194
3 12 1 NA NA 8.485281 2.356194
4 13 1 NA NA 9.192388 2.356194
>   infline(p=1:3, theta=pi/4)
3 infinite lines
         a  b  h  v p     theta
1 1.414214 -1 NA NA 1 0.7853982
2 2.828427 -1 NA NA 2 0.7853982
3 4.242641 -1 NA NA 3 0.7853982
>   plot(c(-1,1),c(-1,1),type="n",xlab="",ylab="", asp=1)
>   plot(infline(p=0.4, theta=seq(0,pi,length=20)))
> 
> 
> 
> cleanEx()
> nameEx("influence.ppm")
> ### * influence.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: influence.ppm
> ### Title: Influence Measure for Spatial Point Process Model
> ### Aliases: influence.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X ~x+y)
>    plot(influence(fit))
> 
> 
> 
> cleanEx()
> nameEx("insertVertices")
> ### * insertVertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: insertVertices
> ### Title: Insert New Vertices in a Linear Network
> ### Aliases: insertVertices
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    opa <- par(mfrow=c(1,3), mar=rep(0,4))
>    simplenet
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
> 
>    plot(simplenet, main="")
>    plot(vertices(simplenet), add=TRUE)
> 
>    # add two new vertices at specified local coordinates
>    L <- insertVertices(simplenet, seg=c(3,7), tp=c(0.2, 0.5))
>    L
Linear network with 12 vertices and 12 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>    plot(L, main="")
>    plot(vertices(L), add=TRUE)
>    id <- attr(L, "id")
>    id
[1] 11 12
>    plot(vertices(L)[id], add=TRUE, pch=16)
> 
>    # add new vertices at three randomly-generated points
>    X <- runiflpp(3, simplenet)
>    LL <- insertVertices(simplenet, X)
>    plot(LL, main="")
>    plot(vertices(LL), add=TRUE)
>    ii <- attr(LL, "id")
>    plot(vertices(LL)[ii], add=TRUE, pch=16)
>    par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("inside.boxx")
> ### * inside.boxx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inside.boxx
> ### Title: Test Whether Points Are Inside A Multidimensional Box
> ### Aliases: inside.boxx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # Random points in box with side [0,2]
>   w <- boxx(c(0,2), c(0,2), c(0,2))
> 
>   # Random points in box with side [-1,3]
>   x <- runif(30, min=-1, max=3)
>   y <- runif(30, min=-1, max=3)
>   z <- runif(30, min=-1, max=3)
> 
>   # Points falling in smaller box
>   ok <- inside.boxx(x, y, z, w=w)
> 
>   # Same using a point pattern as argument:
>   X <- ppx(data = cbind(x, y, z), domain = boxx(c(0,3), c(0,3), c(0,3)))
>   ok2 <- inside.boxx(X, w=w)
> 
> 
> 
> cleanEx()
> nameEx("inside.owin")
> ### * inside.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inside.owin
> ### Title: Test Whether Points Are Inside A Window
> ### Aliases: inside.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # hexagonal window
>   k <- 6
>   theta <- 2 * pi * (0:(k-1))/k
>   co <- cos(theta)
>   si <- sin(theta)
>   mas <- owin(c(-1,1), c(-1,1), poly=list(x=co, y=si))
>   ## Not run: 
> ##D   plot(mas)
> ##D   
> ## End(Not run)
> 
>   # random points in rectangle
>   x <- runif(30,min=-1, max=1)
>   y <- runif(30,min=-1, max=1)
> 
>   ok <- inside.owin(x, y, mas)
> 
>   ## Not run: 
> ##D   points(x[ok], y[ok])
> ##D   points(x[!ok], y[!ok], pch="x")
> ##D   
> ## End(Not run)  
> 
> 
> 
> cleanEx()
> nameEx("integral.im")
> ### * integral.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integral.im
> ### Title: Integral of a Pixel Image
> ### Aliases: integral integral.im
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    # approximate integral of f(x,y) dx dy
>    f <- function(x,y){3*x^2 + 2*y}
>    Z <- as.im(f, square(1))
>    integral.im(Z)
[1] 1.999985
>    # correct answer is 2
> 
>    D <- density(cells)
>    integral.im(D)
[1] 42.92523
>    # should be approximately equal to number of points = 42
> 
>    # integrate over the subset [0.1,0.9] x [0.2,0.8]
>    W <- owin(c(0.1,0.9), c(0.2,0.8))
>    integral.im(D, W)
[1] 21.73123
> 
> 
> 
> cleanEx()
> nameEx("integral.linim")
> ### * integral.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integral.linim
> ### Title: Integral on a Linear Network
> ### Aliases: integral.linim integral.linfun
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # make some data
>   xcoord <- linfun(function(x,y,seg,tp) { x }, simplenet)
>   integral(xcoord)
[1] 1.449267
>   X <- as.linim(xcoord)
>   integral(X)
[1] 1.449267
> 
>   # integrals inside each tile of a tessellation
>   A <- quadrats(Frame(simplenet), 3)
>   integral(X, A)
Tile row 1, col 1 Tile row 1, col 2 Tile row 1, col 3 Tile row 2, col 1 
       0.03912433        0.25579834        0.23210682        0.11343961 
Tile row 2, col 2 Tile row 2, col 3 Tile row 3, col 1 Tile row 3, col 2 
       0.17871664        0.20526235        0.02947088        0.25101451 
Tile row 3, col 3 
       0.13468678 
> 
> 
> 
> cleanEx()
> nameEx("integral.msr")
> ### * integral.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integral.msr
> ### Title: Integral of a Measure
> ### Aliases: integral.msr
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    fit <- ppm(cells ~ x)
>    rr <- residuals(fit)
>    integral(rr)
[1] -6.444953e-10
> 
>    # vector-valued measure
>    rs <- residuals(fit, type="score")
>    integral(rs)
  (Intercept)             x 
-6.444953e-10 -1.763329e-10 
> 
>    # multitype
>    fitA <- ppm(amacrine ~ x)
>    rrA <- residuals(fitA)
>    sapply(split(rrA), integral)
off  on 
 -5   5 
> 
>    # multitype and vector-valued
>    rsA <- residuals(fitA, type="score")
>    sapply(split(rsA), integral)
                off     on
(Intercept) -5.0000 5.0000
x           -3.6253 3.6253
> 
>    ## integral over a subregion
>    integral(rr, domain=square(0.5))
[1] 2.100324
>    ## integrals over the tiles of a tessellation
>    integral(rr, domain=quadrats(cells, 2))
Tile row 1, col 1 Tile row 1, col 2 Tile row 2, col 1 Tile row 2, col 2 
        0.0815549        -0.1005221         2.1003240        -1.1002438 
> 
> 
> 
> cleanEx()
> nameEx("intensity.lpp")
> ### * intensity.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intensity.lpp
> ### Title: Empirical Intensity of Point Pattern on Linear Network
> ### Aliases: intensity.lpp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   intensity(chicago)

     assault     burglary     cartheft       damage      robbery        theft 
0.0006741528 0.0001605126 0.0002247176 0.0011235879 0.0001284100 0.0012198955 
    trespass 
0.0001926151 
> 
> 
> 
> cleanEx()
> nameEx("intensity.ppm")
> ### * intensity.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intensity.ppm
> ### Title: Intensity of Fitted Point Process Model
> ### Aliases: intensity.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fitP <- ppm(swedishpines ~ 1)
>   intensity(fitP)
[1] 0.007395833
>   fitS <- ppm(swedishpines ~ 1, Strauss(9))
>   intensity(fitS)
[1] 0.009398588
>   fitSx <- ppm(swedishpines ~ x, Strauss(9))
>   lamSx <- intensity(fitSx)
>   fitG <- ppm(swedishpines ~ 1, Geyer(9, 1))
>   lamG <- intensity(fitG)
>   fitA <- ppm(swedishpines ~ 1, AreaInter(7))
>   lamA <- intensity(fitA)
> 
> 
> 
> cleanEx()
> nameEx("intensity.ppp")
> ### * intensity.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intensity.ppp
> ### Title: Empirical Intensity of Point Pattern
> ### Aliases: intensity.ppp intensity.splitppp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   japanesepines
Planar point pattern: 65 points
window: rectangle = [0, 1] x [0, 1] units (one unit = 5.7 metres)
>   intensity(japanesepines)
[1] 65
>   unitname(japanesepines)
5.7 metres 
>   intensity(rescale(japanesepines))
[1] 2.000616
> 
>   intensity(amacrine)
     off       on 
88.68302 94.92830 
>   intensity(split(amacrine))
     off       on 
88.68302 94.92830 
> 
>   # numeric vector of weights
>   volumes <- with(marks(finpines), (pi/4) * height * diameter^2)
>   intensity(finpines, weights=volumes)
[1] 38.2108
> 
>   # expression for weights
>   intensity(finpines, weights=expression((pi/4) * height * diameter^2))
[1] 38.2108
> 
> 
> 
> cleanEx()
> nameEx("intensity.ppx")
> ### * intensity.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intensity.ppx
> ### Title: Intensity of a Multidimensional Space-Time Point Pattern
> ### Aliases: intensity.ppx
> 
> ### ** Examples
> 
>   X <- osteo$pts[[1]]
>   intensity(X)
[1] 3.566529e-05
>   marks(X) <- factor(sample(letters[1:3], npoints(X), replace=TRUE))
>   intensity(X)
           a            b            c 
1.371742e-05 8.230453e-06 1.371742e-05 
> 
> 
> 
> cleanEx()
> nameEx("intensity.psp")
> ### * intensity.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intensity.psp
> ### Title: Empirical Intensity of Line Segment Pattern
> ### Aliases: intensity.psp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   S <- as.psp(simplenet)
>   intensity(S)
[1] 2.904852
>   intensity(S, weights=runif(nsegments(S)))
[1] 5.515139
>   intensity(S, weights=expression((x0+x1)/2))
[1] 4.926373
> 
> 
> 
> cleanEx()
> nameEx("intensity.quadratcount")
> ### * intensity.quadratcount
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intensity.quadratcount
> ### Title: Intensity Estimates Using Quadrat Counts
> ### Aliases: intensity.quadratcount
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   qa <- quadratcount(swedishpines, 4,3)
>   qa
             x
y             [0,24) [24,48) [48,72) [72,96]
  [66.7,100]       7       3       6       5
  [33.3,66.7)      5       9       7       7
  [0,33.3)         4       3       6       9
>   intensity(qa)
             x
y              [0,24) [24,48) [48,72) [72,96]
  [66.7,100]  0.00875 0.00375 0.00750 0.00625
  [33.3,66.7) 0.00625 0.01125 0.00875 0.00875
  [0,33.3)    0.00500 0.00375 0.00750 0.01125
>   plot(intensity(qa, image=TRUE))
> 
> 
> 
> cleanEx()
> nameEx("interp.colourmap")
> ### * interp.colourmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interp.colourmap
> ### Title: Interpolate smoothly between specified colours
> ### Aliases: interp.colourmap
> ### Keywords: spatial color
> 
> ### ** Examples
> 
>   co <- colourmap(inputs=c(0, 0.5, 1), c("black", "red", "white"))
>   plot(interp.colourmap(co))
> 
> 
> 
> cleanEx()
> nameEx("interp.im")
> ### * interp.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interp.im
> ### Title: Interpolate a Pixel Image
> ### Aliases: interp.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    opa <- par(mfrow=c(1,2))
>    # coarse image
>    V <- as.im(function(x,y) { x^2 + y }, owin(), dimyx=10)
>    plot(V, main="coarse image", col=terrain.colors(256))
> 
>    # lookup value at location (0.5,0.5)
>    V[list(x=0.5,y=0.5)]
[1] 0.8525
>    # interpolated value at location (0.5,0.5)
>    interp.im(V, 0.5, 0.5)
[1] 0.7525
>    interp.im(V, 0.5, 0.5, bilinear=TRUE)
[1] 0.7525
>    # true value is 0.75
> 
>    # how to obtain an interpolated image at a desired resolution
>    U <- as.im(interp.im, W=owin(), Z=V, dimyx=256)
>    plot(U, main="interpolated image", col=terrain.colors(256))
>    par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("intersect.lintess")
> ### * intersect.lintess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intersect.lintess
> ### Title: Intersection of Tessellations on a Linear Network
> ### Aliases: intersect.lintess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- divide.linnet(runiflpp(4, simplenet))
>   Y <- divide.linnet(runiflpp(3, simplenet))
>   opa <- par(mfrow=c(1,3))
>   plot(X)
>   plot(Y)
>   plot(intersect.lintess(X,Y))
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("intersect.owin")
> ### * intersect.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intersect.owin
> ### Title: Intersection, Union or Set Subtraction of Windows
> ### Aliases: intersect.owin union.owin setminus.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
> # rectangles
>    u <- unit.square()
>    v <- owin(c(0.5,3.5), c(0.4,2.5))
> # polygon
>    data(letterR)
> # mask
>    m <- as.mask(letterR)
> 
> # two rectangles
>    intersect.owin(u, v) 
window: rectangle = [0.5, 1] x [0.4, 1] units
>    union.owin(u,v)
window: polygonal boundary
enclosing rectangle: [0, 3.5] x [0, 2.5] units
>    setminus.owin(u,v)
window: polygonal boundary
enclosing rectangle: [0, 1] x [0, 1] units
> 
> # polygon and rectangle
>    intersect.owin(letterR, v)
window: polygonal boundary
enclosing rectangle: [2.017, 3.5] x [0.653, 2.5] units
>    union.owin(letterR,v)
window: polygonal boundary
enclosing rectangle: [0.5, 3.93] x [0.4, 3.278] units
>    setminus.owin(letterR,v)
window: polygonal boundary
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
> 
> # mask and rectangle
>    intersect.owin(m, v)
window: binary image mask
90 x 99 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.5] x [0.645, 2.5] units
>    union.owin(m,v)
window: binary image mask
140 x 230 pixel array (ny, nx)
enclosing rectangle: [0.492578, 3.93] x [0.398156, 3.278] units
>    setminus.owin(m,v)
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
> 
> # mask and polygon
>    p <- rotate(v, 0.2)
>    intersect.owin(m, p)
window: binary image mask
122 x 89 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.350765] x [0.645, 3.1455091] units
>    union.owin(m,p)
window: binary image mask
135 x 263 pixel array (ny, nx)
enclosing rectangle: [-0.000617, 3.93] x [0.501008, 3.278] units
>    setminus.owin(m,p)
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
> 
> # two polygons
>    A <- letterR
>    B <- rotate(letterR, 0.2)
>    plot(boundingbox(A,B), main="intersection")
>    w <- intersect.owin(A, B)
>    plot(w, add=TRUE, col="lightblue")
>    plot(A, add=TRUE)
>    plot(B, add=TRUE)
> 
>    plot(boundingbox(A,B), main="union")
>    w <- union.owin(A,B)
>    plot(w, add=TRUE, col="lightblue")   
>    plot(A, add=TRUE)
>    plot(B, add=TRUE)
> 
>    plot(boundingbox(A,B), main="set minus")
>    w <- setminus.owin(A,B)
>    plot(w, add=TRUE, col="lightblue")   
>    plot(A, add=TRUE)
>    plot(B, add=TRUE)
> 
> # intersection and union of three windows
>    C <- shift(B, c(0.2, 0.3))
>    plot(union.owin(A,B,C))
>    plot(intersect.owin(A,B,C))
> 
> 
> 
> cleanEx()
> nameEx("intersect.tess")
> ### * intersect.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intersect.tess
> ### Title: Intersection of Two Tessellations
> ### Aliases: intersect.tess
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   opa <- par(mfrow=c(1,3))
> # polygon
>   data(letterR)
>   plot(letterR)
> # tessellation of rectangles
>   X <- tess(xgrid=seq(2, 4, length=10), ygrid=seq(0, 3.5, length=8))
>   plot(X)
>   plot(intersect.tess(X, letterR))
> 
>   A <- runifpoint(10)
>   B <- runifpoint(10)
>   plot(DA <- dirichlet(A))
>   plot(DB <- dirichlet(B))
>   plot(intersect.tess(DA, DB))
>   par(opa)
> 
>   marks(DA) <- 1:10
>   marks(DB) <- 1:10
>   plot(Z <- intersect.tess(DA,DB, keepmarks=TRUE))
>   mZ <- marks(Z)
>   tZ <- tiles(Z)
>   for(i in which(mZ[,1] == 3)) plot(tZ[[i]], add=TRUE, col="pink")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("invoke.symbolmap")
> ### * invoke.symbolmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: invoke.symbolmap
> ### Title: Plot Data Using Graphics Symbol Map
> ### Aliases: invoke.symbolmap
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   g <- symbolmap(range=c(-1,1),
+                    shape=function(x) ifelse(x > 0, "circles", "squares"),
+                    size=function(x) sqrt(ifelse(x > 0, x/pi, -x))/15,
+                    bg=function(x) ifelse(x > 0, "green", "red"))
>   plot(square(1), main="")
>   a <- invoke.symbolmap(g, runif(10, -1, 1), runifpoint(10), add=TRUE)
>   a 
[1] 0.06576792
> 
> 
> 
> cleanEx()
> nameEx("ippm")
> ### * ippm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ippm
> ### Title: Fit Point Process Model Involving Irregular Trend Parameters
> ### Aliases: ippm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   nd <- 32
>   ## Don't show: 
> nd <- 10
> ## End(Don't show)
>   
>   gamma0 <- 3
>   delta0 <- 5
>   POW <- 3
>   # Terms in intensity
>   Z <- function(x,y) { -2*y }
>   f <- function(x,y,gamma,delta) { 1 + exp(gamma - delta * x^POW) }
>   # True intensity
>   lamb <- function(x,y,gamma,delta) { 200 * exp(Z(x,y)) * f(x,y,gamma,delta) }
>   # Simulate realisation
>   lmax <- max(lamb(0,0,gamma0,delta0), lamb(1,1,gamma0,delta0))
>   set.seed(42)
>   X <- rpoispp(lamb, lmax=lmax, win=owin(), gamma=gamma0, delta=delta0)
>   # Partial derivatives of log f
>   DlogfDgamma <- function(x,y, gamma, delta) {
+     topbit <- exp(gamma - delta * x^POW)
+     topbit/(1 + topbit)
+   }
>   DlogfDdelta <- function(x,y, gamma, delta) {
+     topbit <- exp(gamma - delta * x^POW)
+     - (x^POW) * topbit/(1 + topbit)
+   }
>   # irregular score
>   Dlogf <- list(gamma=DlogfDgamma, delta=DlogfDdelta)
>   # fit model
>   ippm(X ~Z + offset(log(f)),
+        covariates=list(Z=Z, f=f),
+        iScore=Dlogf,
+        start=list(gamma=1, delta=1),
+        nlm.args=list(stepmax=1),
+        nd=nd)
Nonstationary Poisson process

Log intensity:  ~Z + offset(log(f))

Fitted trend coefficients:
(Intercept)           Z 
   5.305261    1.036238 

Irregular parameters (covfunargs) fitted by 'ippm':
gamma = 3.055146 
delta = 4.760773 
            Estimate       S.E.   CI95.lo  CI95.hi Ztest      Zval
(Intercept) 5.305261 0.05064260 5.2060038 5.404519   *** 104.75887
Z           1.036238 0.05928704 0.9200378 1.152439   ***  17.47833
> 
> 
> 
> cleanEx()
> nameEx("is.connected")
> ### * is.connected
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.connected
> ### Title: Determine Whether an Object is Connected
> ### Aliases: is.connected is.connected.default is.connected.linnet
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   d <- distmap(cells, dimyx=256)
>   X <- levelset(d, 0.07)
>   plot(X)
>   is.connected(X)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("is.connected.ppp")
> ### * is.connected.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.connected.ppp
> ### Title: Determine Whether a Point Pattern is Connected
> ### Aliases: is.connected.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   is.connected(redwoodfull, 0.1)
[1] FALSE
>   is.connected(redwoodfull, 0.2)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.hybrid")
> ### * is.hybrid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.hybrid
> ### Title: Test Whether Object is a Hybrid
> ### Aliases: is.hybrid is.hybrid.ppm is.hybrid.interact
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   S <- Strauss(0.1)
>   is.hybrid(S)
[1] FALSE
>   H <- Hybrid(Strauss(0.1), Geyer(0.2, 3))
>   is.hybrid(H)
[1] TRUE
> 
>   data(redwood)
>   fit <- ppm(redwood, ~1, H)
>   is.hybrid(fit)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.marked.ppm")
> ### * is.marked.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.marked.ppm
> ### Title: Test Whether A Point Process Model is Marked
> ### Aliases: is.marked.ppm is.marked.lppm
> ### Keywords: spatial manip models
> 
> ### ** Examples
> 
>    X <- lansing
>    # Multitype point pattern --- trees marked by species
> 
>    ## Don't show: 
>       # Smaller dataset
>       X <- amacrine
>    
> ## End(Don't show)
> 
>   fit1 <- ppm(X, ~ marks, Poisson())
>   is.marked(fit1)
[1] TRUE
>   # TRUE
> 
>   fit2 <- ppm(X, ~ 1, Poisson())
>   is.marked(fit2)
[1] TRUE
>   # TRUE
> 
>   # Unmarked point pattern
>   fit3 <- ppm(cells, ~ 1, Poisson())
>   is.marked(fit3)
[1] FALSE
>   # FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("is.marked.ppp")
> ### * is.marked.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.marked.ppp
> ### Title: Test Whether A Point Pattern is Marked
> ### Aliases: is.marked.ppp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    data(cells)
>    is.marked(cells)  #FALSE
[1] FALSE
>    data(longleaf)
>    is.marked(longleaf) #TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.multitype.ppm")
> ### * is.multitype.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.multitype.ppm
> ### Title: Test Whether A Point Process Model is Multitype
> ### Aliases: is.multitype.ppm is.multitype.lppm
> ### Keywords: spatial manip models
> 
> ### ** Examples
> 
>    X <- lansing
>    # Multitype point pattern --- trees marked by species
> 
>    ## Don't show: 
>       # Smaller dataset
>       X <- amacrine
>    
> ## End(Don't show)
> 
>   fit1 <- ppm(X, ~ marks, Poisson())
>   is.multitype(fit1)
[1] TRUE
>   # TRUE
> 
>   fit2 <- ppm(X, ~ 1, Poisson())
>   is.multitype(fit2)
[1] TRUE
>   # TRUE
> 
>   # Unmarked point pattern
>   fit3 <- ppm(cells, ~ 1, Poisson())
>   is.multitype(fit3)
[1] FALSE
>   # FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("is.multitype.ppp")
> ### * is.multitype.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.multitype.ppp
> ### Title: Test Whether A Point Pattern is Multitype
> ### Aliases: is.multitype.ppp is.multitype.lpp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    is.multitype(cells)  #FALSE - no marks
[1] FALSE
>    is.multitype(longleaf) #FALSE - real valued marks
[1] FALSE
>    is.multitype(amacrine) #TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.stationary")
> ### * is.stationary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.stationary
> ### Title: Recognise Stationary and Poisson Point Process Models
> ### Aliases: is.stationary is.stationary.ppm is.stationary.kppm
> ###   is.stationary.lppm is.stationary.slrm is.stationary.rmhmodel
> ###   is.stationary.dppm is.stationary.detpointprocfamily is.poisson
> ###   is.poisson.ppm is.poisson.kppm is.poisson.lppm is.poisson.slrm
> ###   is.poisson.rmhmodel is.poisson.interact
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   data(cells)
>   data(redwood)
> 
>   fit <- ppm(cells ~ x)
>   is.stationary(fit)
[1] FALSE
>   is.poisson(fit)
[1] TRUE
> 
>   fut <- kppm(redwood ~ 1, "MatClust")
>   is.stationary(fut)
[1] TRUE
>   is.poisson(fut)
[1] FALSE
> 
>   fot <- slrm(cells ~ x)
>   is.stationary(fot)
[1] FALSE
>   is.poisson(fot)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.subset.owin")
> ### * is.subset.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.subset.owin
> ### Title: Determine Whether One Window is Contained In Another
> ### Aliases: is.subset.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    w1 <- as.owin(c(0,1,0,1))
>    w2 <- as.owin(c(-1,2,-1,2))
>    is.subset.owin(w1,w2)  # Returns TRUE.
[1] TRUE
>    is.subset.owin(w2,w1)  # Returns FALSE.
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("joinVertices")
> ### * joinVertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: joinVertices
> ### Title: Join Vertices in a Network
> ### Aliases: joinVertices
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   snet <- joinVertices(simplenet, 4, 8)
>   plot(solist(simplenet, snet), main="")
>   X <- runiflpp(3, simplenet)
>   Y <- joinVertices(X, 4, 8)
> 
> 
> 
> cleanEx()
> nameEx("kernel.factor")
> ### * kernel.factor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kernel.factor
> ### Title: Scale factor for density kernel
> ### Aliases: kernel.factor
> ### Keywords: methods nonparametric smooth
> 
> ### ** Examples
> 
>    kernel.factor("rect")
[1] 1.732051
>    # bandwidth for Epanechnikov kernel with half-width h=1
>    h <- 1
>    bw <- h/kernel.factor("epa")
> 
> 
> 
> cleanEx()
> nameEx("kernel.moment")
> ### * kernel.moment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kernel.moment
> ### Title: Moment of Smoothing Kernel
> ### Aliases: kernel.moment
> ### Keywords: methods nonparametric smooth
> 
> ### ** Examples
> 
>    kernel.moment(1, 0.1, "epa")
[1] -0.1837688
>    curve(kernel.moment(2, x, "epa"), from=-1, to=1)
> 
> 
> 
> cleanEx()
> nameEx("kernel.squint")
> ### * kernel.squint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kernel.squint
> ### Title: Integral of Squared Kernel
> ### Aliases: kernel.squint
> ### Keywords: methods nonparametric smooth
> 
> ### ** Examples
> 
>    kernel.squint("gaussian", 3)
[1] 0.0940316
> 
>    # integral of squared Epanechnikov kernel with half-width h=1
>    h <- 1
>    bw <- h/kernel.factor("epa")
>    kernel.squint("epa", bw)
[1] 0.6
> 
> 
> 
> cleanEx()
> nameEx("kppm")
> ### * kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kppm
> ### Title: Fit Cluster or Cox Point Process Model
> ### Aliases: kppm kppm.formula kppm.ppp kppm.quad
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   # method for point patterns
>   kppm(redwood, ~1, "Thomas")
Stationary cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: K-function

Uniform intensity:	62

Cluster model: Thomas process
Fitted cluster parameters:
     kappa      scale 
23.5511449  0.0470461 
Mean cluster size:  2.632568 points
>   # method for formulas
>   kppm(redwood ~ 1, "Thomas")
Stationary cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: K-function

Uniform intensity:	62

Cluster model: Thomas process
Fitted cluster parameters:
     kappa      scale 
23.5511449  0.0470461 
Mean cluster size:  2.632568 points
> 
>   # different models for clustering
>   kppm(redwood ~ x, "MatClust") 
Inhomogeneous cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: inhomogeneous K-function

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  3.9745791   0.2976994 

Cluster model: Matern cluster process
Fitted cluster parameters:
      kappa       scale 
23.89255874  0.08525192 
Mean cluster size:  [pixel image]
>   kppm(redwood ~ x, "MatClust", statistic="pcf", statargs=list(stoyan=0.2)) 
Warning: Some values of the empirical function 'pcf' were infinite or NA. Range of r values was reset to [0.00048828125, 0.25]
Inhomogeneous cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: inhomogeneous pair correlation function

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  3.9745791   0.2976994 

Cluster model: Matern cluster process
Fitted cluster parameters:
      kappa       scale 
22.82939656  0.06594836 
Mean cluster size:  [pixel image]
>   kppm(redwood ~ x, cluster="Cauchy", statistic="K")
Inhomogeneous cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: inhomogeneous K-function

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  3.9745791   0.2976994 

Cluster model: Cauchy process
Fitted cluster parameters:
      kappa       scale 
12.20670806  0.04506227 
Mean cluster size:  [pixel image]
>   kppm(redwood, cluster="VarGamma", nu = 0.5, statistic="pcf")
Warning: Some values of the empirical function 'pcf' were infinite or NA. Range of r values was reset to [0.00048828125, 0.25]
Stationary cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: pair correlation function

Uniform intensity:	62

Cluster model: Variance Gamma process (nu=0.5)
Fitted cluster parameters:
      kappa       scale 
24.38941996  0.02747829 
Mean cluster size:  2.542086 points
> 
>   # log-Gaussian Cox process (LGCP) models
>   kppm(redwood ~ 1, "LGCP", statistic="pcf")
Warning: Some values of the empirical function 'pcf' were infinite or NA. Range of r values was reset to [0.00048828125, 0.25]
Stationary Cox point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: pair correlation function

Uniform intensity:	62

Cox model: log-Gaussian Cox process
	Covariance model: exponential
Fitted covariance parameters:
      var     scale 
1.2973343 0.0711314 
Fitted mean of log of random intensity: 3.478467
>   if(require("RandomFields")) {
+     # Random Fields package is needed for non-default choice of covariance model
+     kppm(redwood ~ x, "LGCP", statistic="pcf",
+                               model="matern", nu=0.3,
+                               control=list(maxit=10))
+   }
Loading required package: RandomFields
Loading required package: sp
Loading required package: RandomFieldsUtils

Attaching package: 'RandomFields'

The following object is masked from 'package:RandomFieldsUtils':

    RFoptions

The following object is masked from 'package:nlme':

    Variogram

Warning: Some values of the empirical function 'pcf' were infinite or NA. Range of r values was reset to [0.00048828125, 0.25]
Warning: Iteration limit maxit was reached after 11 function evaluations
Inhomogeneous Cox point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: inhomogeneous pair correlation function

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  3.9745791   0.2976994 

Cox model: log-Gaussian Cox process
	Covariance model: matern
	Covariance parameters: nu = 0.3
Fitted covariance parameters:
       var      scale 
1.13281250 0.08169365 
Fitted mean of log of random intensity: [pixel image]
> 
>   # Different fitting techniques
>   kppm(redwood ~ 1, "Thomas", method="c")
Stationary cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by maximum second order composite likelihood
	rmax = 0.25
	weight function: Indicator(distance <= 0.125)

Uniform intensity:	62

Cluster model: Thomas process
Fitted cluster parameters:
      kappa       scale 
28.02839670  0.03538136 
Mean cluster size:  2.212042 points
>   kppm(redwood ~ 1, "Thomas", method="p")
Stationary cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by maximum Palm likelihood
	rmax = 0.25
	weight function: Indicator(distance <= 0.125)

Uniform intensity:	62

Cluster model: Thomas process
Fitted cluster parameters:
      kappa       scale 
24.91180093  0.03554333 
Mean cluster size:  2.48878 points
>   # composite likelihood method
>   kppm(redwood ~ x, "VarGamma", method="clik2", nu.ker=-3/8)
Inhomogeneous cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by maximum second order composite likelihood
	rmax = 0.25
	weight function: Indicator(distance <= 0.125)

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  3.9745791   0.2976994 

Cluster model: Variance Gamma process (nu=-0.38)
Fitted cluster parameters:
       kappa        scale 
8.151593e-05 1.389202e-01 
Mean cluster size:  [pixel image]
>   # quasi-likelihood method
>   kppm(redwood ~ x, "Thomas", improve.type = "quasi")
Inhomogeneous cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: inhomogeneous K-function

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  3.8380227   0.4059933 

Cluster model: Thomas process
Fitted cluster parameters:
      kappa       scale 
22.92087243  0.04635311 
Mean cluster size:  [pixel image]
> 
> 
> 
> 
> cleanEx()

detaching 'package:RandomFields', 'package:RandomFieldsUtils',
  'package:sp'

> nameEx("laslett")
> ### * laslett
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: laslett
> ### Title: Laslett's Transform
> ### Aliases: laslett
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
> a <- laslett(heather$coarse)
> with(a, clarkevans.test(TanNew[Rect], correction="D", nsim=39))

	Clark-Evans test
	Donnelly correction
	Monte Carlo test based on 39 simulations of CSR with fixed n

data:  TanNew[Rect]
R = 1.0458, p-value = 0.65
alternative hypothesis: two-sided

> X <- discs(runifpoint(15) %mark% 0.2, npoly=16)
> b <- laslett(X, type="left")
> b
Laslett Transform

Original object:
window: polygonal boundary
enclosing rectangle: [0, 1] x [0, 1] units

Transformed set:
window: polygonal boundary
enclosing rectangle: [0, 1] x [0.0102318, 1] units

Transformed area: 0.7232426 square units

9 left tangent points found.
> 
> 
> 
> cleanEx()
> nameEx("latest.news")
> ### * latest.news
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: latest.news
> ### Title: Print News About Latest Version of Package
> ### Aliases: latest.news
> ### Keywords: documentation
> 
> ### ** Examples
> 
>   if(interactive()) {
+ 
+     # current news
+     latest.news
+ 
+     # all news
+     news(package="spatstat")
+ 
+   }
> 
> 
> 
> cleanEx()
> nameEx("layered")
> ### * layered
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: layered
> ### Title: Create List of Plotting Layers
> ### Aliases: layered
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    D <- distmap(cells)
>    L <- layered(D, cells)
>    L
Layered object

Layer 1:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units

Layer 2:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
>    L <- layered(D, cells,
+     plotargs=list(list(ribbon=FALSE), list(pch=16)))
>    plot(L)
> 
>    layerplotargs(L)[[1]] <- list(.plot="contour")
>    plot(L)
> 
> 
> 
> cleanEx()
> nameEx("layerplotargs")
> ### * layerplotargs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: layerplotargs
> ### Title: Extract or Replace the Plot Arguments of a Layered Object
> ### Aliases: layerplotargs layerplotargs<-
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    W <- square(2)
>    L <- layered(W=W, X=cells)
>    ## The following are equivalent
>    layerplotargs(L) <- list(list(), list(pch=16))
>    layerplotargs(L)[[2]] <- list(pch=16)
>    layerplotargs(L)$X <- list(pch=16)
> 
>    ## The following are equivalent
>    layerplotargs(L) <- list(list(cex=2), list(cex=2))
>    layerplotargs(L) <- list(list(cex=2))
> 
> 
> 
> cleanEx()
> nameEx("layout.boxes")
> ### * layout.boxes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: layout.boxes
> ### Title: Generate a Row or Column Arrangement of Rectangles.
> ### Aliases: layout.boxes
> ### Keywords: utilities
> 
> ### ** Examples
> 
>   B <- owin(c(0,10),c(0,1))
>   boxes <- layout.boxes(B, 5, horizontal=TRUE)
>   plot(B, main="", col="blue")
>   niets <- lapply(boxes, plot, add=TRUE, col="grey")
> 
> 
> 
> cleanEx()
> nameEx("lengths_psp")
> ### * lengths_psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lengths_psp
> ### Title: Lengths of Line Segments
> ### Aliases: lengths.psp lengths_psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   b <- lengths_psp(a)   
> 
> 
> 
> cleanEx()
> nameEx("levelset")
> ### * levelset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: levelset
> ### Title: Level Set of a Pixel Image
> ### Aliases: levelset
> ### Keywords: spatial programming manip
> 
> ### ** Examples
> 
>   # test image
>   X <- as.im(function(x,y) { x^2 - y^2 }, unit.square())
> 
>   W <- levelset(X, 0.2)
>   W <- levelset(X, -0.3, ">")
> 
>   # compute area of level set
>   area(levelset(X, 0.1))
[1] 0.6167603
> 
> 
> 
> cleanEx()
> nameEx("leverage.ppm")
> ### * leverage.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: leverage.ppm
> ### Title: Leverage Measure for Spatial Point Process Model
> ### Aliases: leverage leverage.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X ~x+y)
>    plot(le <- leverage(fit))
>    mean(le)
[1] 2.997537
> 
> 
> 
> cleanEx()
> nameEx("lgcp.estK")
> ### * lgcp.estK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lgcp.estK
> ### Title: Fit a Log-Gaussian Cox Point Process by Minimum Contrast
> ### Aliases: lgcp.estK
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     if(interactive()) {
+       u <- lgcp.estK(redwood)
+     } else {
+       # slightly faster - better starting point
+       u <- lgcp.estK(redwood, c(var=1, scale=0.1))
+     }
>     u
Minimum contrast fit (object of class "minconfit")
Model: log-Gaussian Cox process
	 Covariance model: exponential
Fitted by matching theoretical K function to Kest(redwood)

Internal parameters fitted by minimum contrast ($par):
    sigma2      alpha 
1.04821762 0.09982586 

Fitted covariance parameters:
       var      scale 
1.04821762 0.09982586 

Converged successfully after 55 function evaluations

Starting values of parameters:
sigma2  alpha 
   1.0    0.1 
Domain of integration: [ 0 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u)
> 
>     ## Don't show: 
>       if(require(RandomFields)) {
+         K <- Kest(redwood, r=seq(0, 0.1, length=9))
+         op <- spatstat.options(fastK.lgcp=TRUE)
+         lgcp.estK(K, covmodel=list(model="matern", nu=0.3),
+                   control=list(maxit=2))
+         spatstat.options(op)
+       }
Loading required package: RandomFields
Loading required package: sp
Loading required package: RandomFieldsUtils

Attaching package: 'RandomFields'

The following object is masked from 'package:RandomFieldsUtils':

    RFoptions

The following object is masked from 'package:nlme':

    Variogram

Warning: Iteration limit maxit was reached after 5 function evaluations
>     
> ## End(Don't show)
>     if(FALSE) {
+       ## takes several minutes!
+       lgcp.estK(redwood, covmodel=list(model="matern", nu=0.3))
+     }
> 
> 
> 
> cleanEx()

detaching 'package:RandomFields', 'package:RandomFieldsUtils',
  'package:sp'

> nameEx("lgcp.estpcf")
> ### * lgcp.estpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lgcp.estpcf
> ### Title: Fit a Log-Gaussian Cox Point Process by Minimum Contrast
> ### Aliases: lgcp.estpcf
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(redwood)
>     u <- lgcp.estpcf(redwood, c(var=1, scale=0.1))
>     u
Minimum contrast fit (object of class "minconfit")
Model: log-Gaussian Cox process
	 Covariance model: exponential
Fitted by matching theoretical g function to pcf(redwood)

Internal parameters fitted by minimum contrast ($par):
    sigma2      alpha 
1.29729152 0.07112984 

Fitted covariance parameters:
       var      scale 
1.29729152 0.07112984 

Converged successfully after 59 function evaluations

Starting values of parameters:
sigma2  alpha 
   1.0    0.1 
Domain of integration: [ 0.00025 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u)
>     if(require(RandomFields)) {
+       lgcp.estpcf(redwood, covmodel=list(model="matern", nu=0.3))
+     }
Loading required package: RandomFields
Loading required package: sp
Loading required package: RandomFieldsUtils

Attaching package: 'RandomFields'

The following object is masked from 'package:RandomFieldsUtils':

    RFoptions

The following object is masked from 'package:nlme':

    Variogram

Minimum contrast fit (object of class "minconfit")
Model: log-Gaussian Cox process
	 Covariance model: matern
	 Covariance parameters: nu = 0.3
Fitted by matching theoretical g function to pcf(redwood)

Internal parameters fitted by minimum contrast ($par):
    sigma2      alpha 
1.45247167 0.07145082 

Fitted covariance parameters:
       var      scale 
1.45247167 0.07145082 

Converged successfully after 113 function evaluations

Starting values of parameters:
sigma2  alpha 
     1      1 
Domain of integration: [ 0.00025 , 0.25 ]
Exponents: p= 2, q= 0.25
> 
> 
> 
> cleanEx()

detaching 'package:RandomFields', 'package:RandomFieldsUtils',
  'package:sp'

> nameEx("linearK")
> ### * linearK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearK
> ### Title: Linear K Function
> ### Aliases: linearK
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(simplenet)
>   X <- rpoislpp(5, simplenet)
>   linearK(X)
Function value object (class 'fv')
for the function r -> K[L](r)
.................................................
     Math.label       Description                
r    r                distance argument r        
est  {hat(K)[L]}(r)   estimated K[L](r)          
theo {K[L]^{theo}}(r) theoretical Poisson K[L](r)
.................................................
Default plot formula:  .~r
where "." stands for 'est', 'theo'
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
>   linearK(X, correction="none")
Function value object (class 'fv')
for the function r -> K[net](r)
........................................
    Math.label       Description        
r   r                distance argument r
est {hat(K)[net]}(r) estimated K[net](r)
........................................
Default plot formula:  .~r
where "." stands for 'est'
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
> 
> 
> 
> cleanEx()
> nameEx("linearKcross")
> ### * linearKcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearKcross
> ### Title: Multitype K Function (Cross-type) for Linear Point Pattern
> ### Aliases: linearKcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(chicago)
>    K <- linearKcross(chicago, "assault", "robbery")
> 
> 
> 
> cleanEx()
> nameEx("linearKcross.inhom")
> ### * linearKcross.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearKcross.inhom
> ### Title: Inhomogeneous multitype K Function (Cross-type) for Linear Point
> ###   Pattern
> ### Aliases: linearKcross.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    lam <- table(marks(chicago))/(summary(chicago)$totlength)
>    lamI <- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
>    lamJ <- function(x,y,const=lam[["robbery"]]){ rep(const, length(x)) }
> 
>    K <- linearKcross.inhom(chicago, "assault", "robbery", lamI, lamJ)
> 
>    ## Not run: 
> ##D      fit <- lppm(chicago, ~marks + x)
> ##D      linearKcross.inhom(chicago, "assault", "robbery", fit, fit)
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("linearKdot")
> ### * linearKdot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearKdot
> ### Title: Multitype K Function (Dot-type) for Linear Point Pattern
> ### Aliases: linearKdot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(chicago)
>    K <- linearKdot(chicago, "assault")
> 
> 
> 
> cleanEx()
> nameEx("linearKdot.inhom")
> ### * linearKdot.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearKdot.inhom
> ### Title: Inhomogeneous multitype K Function (Dot-type) for Linear Point
> ###   Pattern
> ### Aliases: linearKdot.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    lam <- table(marks(chicago))/(summary(chicago)$totlength)
>    lamI <- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
>    lam. <- function(x,y,const=sum(lam)){ rep(const, length(x)) }
> 
>    K <- linearKdot.inhom(chicago, "assault", lamI, lam.)
> 
>    ## Not run: 
> ##D      fit <- lppm(chicago, ~marks + x)
> ##D      linearKdot.inhom(chicago, "assault", fit, fit)
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("linearKinhom")
> ### * linearKinhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearKinhom
> ### Title: Inhomogeneous Linear K Function
> ### Aliases: linearKinhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(simplenet)
>   X <- rpoislpp(5, simplenet)
>   fit <- lppm(X ~x)
>   K <- linearKinhom(X, lambda=fit)
Warning: Numerical underflow detected: sigma is probably too small
>   plot(K)
> 
> 
> 
> cleanEx()
> nameEx("lineardirichlet")
> ### * lineardirichlet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lineardirichlet
> ### Title: Dirichlet Tessellation on a Linear Network
> ### Aliases: lineardirichlet
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runiflpp(5, simplenet)
>   plot(lineardirichlet(X), lwd=3)
>   points(X)
> 
> 
> 
> cleanEx()
> nameEx("lineardisc")
> ### * lineardisc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lineardisc
> ### Title: Compute Disc of Given Radius in Linear Network
> ### Aliases: lineardisc countends
> ### Keywords: spatial
> 
> ### ** Examples
> 
>     # letter 'A' 
>     v <- ppp(x=(-2):2, y=3*c(0,1,2,1,0), c(-3,3), c(-1,7))
>     edg <- cbind(1:4, 2:5)
>     edg <- rbind(edg, c(2,4))
>     letterA <- linnet(v, edges=edg)
>     plot(letterA)
> 
>    lineardisc(letterA, c(0,3), 1.6)
$lines
planar line segment pattern: 5 line segments
window: rectangle = [-3, 3] x [-1, 7] units

$endpoints
Planar point pattern: 4 points
window: rectangle = [-3, 3] x [-1, 7] units

>    # count the endpoints
>    countends(letterA, c(0,3), 1.6)
[1] 4
>    # cross-check (slower)
>    en <- lineardisc(letterA, c(0,3), 1.6, plotit=FALSE)$endpoints
>    npoints(en)
[1] 4
> 
> 
> 
> cleanEx()
> nameEx("linearmarkconnect")
> ### * linearmarkconnect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearmarkconnect
> ### Title: Mark Connection Function for Multitype Point Pattern on Linear
> ###   Network
> ### Aliases: linearmarkconnect
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    pab <- linearmarkconnect(chicago, "assault", "burglary")
>   ## Not run: 
> ##D    plot(alltypes(chicago, linearmarkconnect))
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("linearmarkequal")
> ### * linearmarkequal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearmarkequal
> ### Title: Mark Connection Function for Multitype Point Pattern on Linear
> ###   Network
> ### Aliases: linearmarkequal
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    if(interactive()) {
+      X <- chicago
+    } else {
+      m <- sample(factor(c("A","B")), 20, replace=TRUE)
+      X <- runiflpp(20, simplenet) %mark% m
+    }
>    p <- linearmarkequal(X)
> 
> 
> 
> cleanEx()
> nameEx("linearpcf")
> ### * linearpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearpcf
> ### Title: Linear Pair Correlation Function
> ### Aliases: linearpcf
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(simplenet)
>   X <- rpoislpp(5, simplenet)
>   linearpcf(X)
Function value object (class 'fv')
for the function r -> g[L](r)
.................................................
     Math.label       Description                
r    r                distance argument r        
est  {hat(g)[L]}(r)   estimated g[L](r)          
theo {g[L]^{pois}}(r) theoretical Poisson g[L](r)
.................................................
Default plot formula:  .~r
where "." stands for 'est', 'theo'
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
>   linearpcf(X, correction="none")
Function value object (class 'fv')
for the function r -> g[net](r)
........................................
    Math.label       Description        
r   r                distance argument r
est {hat(g)[net]}(r) estimated g[net](r)
........................................
Default plot formula:  .~r
where "." stands for 'est'
Recommended range of argument r: [0, 0.76377]
Available range of argument r: [0, 0.76377]
> 
> 
> 
> cleanEx()
> nameEx("linearpcfcross")
> ### * linearpcfcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearpcfcross
> ### Title: Multitype Pair Correlation Function (Cross-type) for Linear
> ###   Point Pattern
> ### Aliases: linearpcfcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(chicago)
>    g <- linearpcfcross(chicago, "assault")
> 
> 
> 
> cleanEx()
> nameEx("linearpcfcross.inhom")
> ### * linearpcfcross.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearpcfcross.inhom
> ### Title: Inhomogeneous Multitype Pair Correlation Function (Cross-type)
> ###   for Linear Point Pattern
> ### Aliases: linearpcfcross.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    lam <- table(marks(chicago))/(summary(chicago)$totlength)
>    lamI <- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
>    lamJ <- function(x,y,const=lam[["robbery"]]){ rep(const, length(x)) }
> 
>    g <- linearpcfcross.inhom(chicago, "assault", "robbery", lamI, lamJ)
> 
>    ## Not run: 
> ##D      fit <- lppm(chicago, ~marks + x)
> ##D      linearpcfcross.inhom(chicago, "assault", "robbery", fit, fit)
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("linearpcfdot")
> ### * linearpcfdot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearpcfdot
> ### Title: Multitype Pair Correlation Function (Dot-type) for Linear Point
> ###   Pattern
> ### Aliases: linearpcfdot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(chicago)
>    g <- linearpcfdot(chicago, "assault")
> 
> 
> 
> cleanEx()
> nameEx("linearpcfdot.inhom")
> ### * linearpcfdot.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearpcfdot.inhom
> ### Title: Inhomogeneous Multitype Pair Correlation Function (Dot-type) for
> ###   Linear Point Pattern
> ### Aliases: linearpcfdot.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    lam <- table(marks(chicago))/(summary(chicago)$totlength)
>    lamI <- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
>    lam. <- function(x,y,const=sum(lam)){ rep(const, length(x)) }
> 
>    g <- linearpcfdot.inhom(chicago, "assault", lamI, lam.)
> 
>    ## Not run: 
> ##D      fit <- lppm(chicago, ~marks + x)
> ##D      linearpcfdot.inhom(chicago, "assault", fit, fit)
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("linearpcfinhom")
> ### * linearpcfinhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearpcfinhom
> ### Title: Inhomogeneous Linear Pair Correlation Function
> ### Aliases: linearpcfinhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(simplenet)
>   X <- rpoislpp(5, simplenet)
>   fit <- lppm(X ~x)
>   K <- linearpcfinhom(X, lambda=fit)
Warning: Numerical underflow detected: sigma is probably too small
>   plot(K)
> 
> 
> 
> cleanEx()
> nameEx("lineartileindex")
> ### * lineartileindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lineartileindex
> ### Title: Determine Which Tile Contains Each Given Point on a Linear
> ###   Network
> ### Aliases: lineartileindex
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    Z <- lineardirichlet(runiflpp(15, simplenet))
>    X <- runiflpp(10, simplenet)
>    coX <- coords(X)
>    ii <- lineartileindex(coX$seg, coX$tp, Z)
> 
> 
> 
> cleanEx()
> nameEx("linfun")
> ### * linfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linfun
> ### Title: Function on a Linear Network
> ### Aliases: linfun
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   f <- function(x,y,seg,tp) { x+y }
>   g <- linfun(f, simplenet)
>   plot(g)
>   X <- runiflpp(3, simplenet)
>   g(X)
[1] 1.302983 1.507310 1.264383
>   Z <- as.linim(g)
> 
>   f <- function(x,y,seg,tp, mul=1) { mul*(x+y) }
>   g <- linfun(f, simplenet)
>   plot(g)
>   plot(g, mul=10)
>   g(X, mul=10)
[1] 13.02983 15.07310 12.64383
>   Z <- as.linim(g, mul=10)
> 
> 
> 
> cleanEx()
> nameEx("linim")
> ### * linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linim
> ### Title: Create Pixel Image on Linear Network
> ### Aliases: linim
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   Z <- as.im(function(x,y) {x-y}, Frame(simplenet))
>   X <- linim(simplenet, Z)
>   X
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
> 
> 
> 
> cleanEx()
> nameEx("linnet")
> ### * linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linnet
> ### Title: Create a Linear Network
> ### Aliases: linnet
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   # letter 'A' specified by adjacency matrix
>   v <- ppp(x=(-2):2, y=3*c(0,1,2,1,0), c(-3,3), c(-1,7))
>   m <- matrix(FALSE, 5,5)
>   for(i in 1:4) m[i,i+1] <- TRUE
>   m[2,4] <- TRUE
>   m <- m | t(m)
>   letterA <- linnet(v, m)
>   plot(letterA)
> 
>   # letter 'A' specified by edge list
>   edg <- cbind(1:4, 2:5)
>   edg <- rbind(edg, c(2,4))
>   letterA <- linnet(v, edges=edg)
> 
> 
> 
> cleanEx()
> nameEx("lintess")
> ### * lintess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lintess
> ### Title: Tessellation on a Linear Network
> ### Aliases: lintess
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    # tessellation consisting of one tile for each existing segment
>    ns <- nsegments(simplenet)
>    df <- data.frame(seg=1:ns, t0=0, t1=1, tile=letters[1:ns])
>    u <- lintess(simplenet, df)
>    u
Tessellation on a linear network
10 tiles
>    plot(u)
>    S <- as.psp(simplenet)
>    marks(u) <- data.frame(len=lengths_psp(S), ang=angles.psp(S))
>    u
Tessellation on a linear network
10 tiles
Tessellation has mark variables len (double) and ang (double)
>    plot(u)
> 
> 
> 
> cleanEx()
> nameEx("lixellate")
> ### * lixellate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lixellate
> ### Title: Subdivide Segments of a Network
> ### Aliases: lixellate
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    A <- lixellate(simplenet, nsplit=4)
>    plot(A, main="lixellate(simplenet, nsplit=4)")
>    points(vertices(A), pch=16)
> 
>    spiders
Point pattern on linear network
48 points
Linear network with 156 vertices and 203 lines
Enclosing window: rectangle = [0, 1125] x [0, 1125] mm
>    lixellate(spiders, nsplit=3)
Point pattern on linear network
48 points
Linear network with 562 vertices and 609 lines
Enclosing window: rectangle = [0, 1125] x [0, 1125] mm
> 
> 
> 
> cleanEx()
> nameEx("localK")
> ### * localK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localK
> ### Title: Neighbourhood density function
> ### Aliases: localK localL
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(ponderosa)
>   X <- ponderosa
> 
>   # compute all the local L functions
>   L <- localL(X)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106. 108.
> 
>   # plot all the local L functions against r
>   plot(L, main="local L functions for ponderosa", legend=FALSE)
> 
>   # plot only the local L function for point number 7
>   plot(L, iso007 ~ r)
>   
>   # compute the values of L(r) for r = 12 metres
>   L12 <- localL(X, rvalue=12)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106. 108.
> 
>   # Spatially interpolate the values of L12
>   # Compare Figure 5(b) of Getis and Franklin (1987)
>   X12 <- X %mark% L12
>   Z <- Smooth(X12, sigma=5, dimyx=128)
> 
>   plot(Z, col=topo.colors(128), main="smoothed neighbourhood density")
>   contour(Z, add=TRUE)
>   points(X, pch=16, cex=0.5)
> 
> 
> 
> cleanEx()
> nameEx("localKcross")
> ### * localKcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localKcross
> ### Title: Local Multitype K Function (Cross-Type)
> ### Aliases: localKcross localLcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- amacrine
> 
>   # compute all the local Lcross functions
>   L <- localLcross(X)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140. 142.
> 
>   # plot all the local Lcross functions against r
>   plot(L, main="local Lcross functions for amacrine", legend=FALSE)
> 
>   # plot only the local L function for point number 7
>   plot(L, iso007 ~ r)
>   
>   # compute the values of L(r) for r = 0.1 metres
>   L12 <- localLcross(X, rvalue=0.1)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140. 142.
> 
> 
> 
> cleanEx()
> nameEx("localKcross.inhom")
> ### * localKcross.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localKcross.inhom
> ### Title: Inhomogeneous Multitype K Function
> ### Aliases: localKcross.inhom localLcross.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- amacrine
> 
>   # compute all the local L functions
>   L <- localLcross.inhom(X)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140. 142.
> 
>   # plot all the local L functions against r
>   plot(L, main="local L functions for ponderosa", legend=FALSE)
> 
>   # plot only the local L function for point number 7
>   plot(L, iso007 ~ r)
> 
> 
> 
> cleanEx()
> nameEx("localKdot")
> ### * localKdot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localKdot
> ### Title: Local Multitype K Function (Dot-Type)
> ### Aliases: localKdot localLdot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- amacrine
> 
>   # compute all the local Ldot functions
>   L <- localLdot(X)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140. 142.
> 
>   # plot all the local Ldot functions against r
>   plot(L, main="local Ldot functions for amacrine", legend=FALSE)
> 
>   # plot only the local L function for point number 7
>   plot(L, iso007 ~ r)
>   
>   # compute the values of L(r) for r = 0.1 metres
>   L12 <- localLdot(X, rvalue=0.1)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140. 142.
> 
> 
> 
> cleanEx()
> nameEx("localKinhom")
> ### * localKinhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localKinhom
> ### Title: Inhomogeneous Neighbourhood Density Function
> ### Aliases: localKinhom localLinhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(ponderosa)
>   X <- ponderosa
> 
>   # compute all the local L functions
>   L <- localLinhom(X)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106. 108.
> 
>   # plot all the local L functions against r
>   plot(L, main="local L functions for ponderosa", legend=FALSE)
> 
>   # plot only the local L function for point number 7
>   plot(L, iso007 ~ r)
>   
>   # compute the values of L(r) for r = 12 metres
>   L12 <- localL(X, rvalue=12)
1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106. 108.
> 
> 
> 
> cleanEx()
> nameEx("localpcf")
> ### * localpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localpcf
> ### Title: Local pair correlation function
> ### Aliases: localpcf localpcfinhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(ponderosa)
>   X <- ponderosa
> 
>   g <- localpcf(X, stoyan=0.5)
>   colo <- c(rep("grey", npoints(X)), "blue")
>   a <- plot(g, main=c("local pair correlation functions", "Ponderosa pines"),
+           legend=FALSE, col=colo, lty=1)
> 
>   # plot only the local pair correlation function for point number 7
>   plot(g, est007 ~ r)
> 
>   gi <- localpcfinhom(X, stoyan=0.5)
>   a <- plot(gi, main=c("inhomogeneous local pair correlation functions",
+                        "Ponderosa pines"),
+                 legend=FALSE, col=colo, lty=1)
> 
> 
> 
> cleanEx()
> nameEx("logLik.dppm")
> ### * logLik.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logLik.dppm
> ### Title: Log Likelihood and AIC for Fitted Determinantal Point Process
> ###   Model
> ### Aliases: logLik.dppm AIC.dppm extractAIC.dppm nobs.dppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- dppm(swedishpines ~ x, dppGauss(), method="palm")
>   nobs(fit)
[1] 71
>   logLik(fit)
'log Lik.' -1020.688 (df=2)
>   extractAIC(fit)
[1]    2.000 2045.375
>   AIC(fit)
[1] 2045.375
> 
> 
> 
> cleanEx()
> nameEx("logLik.kppm")
> ### * logLik.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logLik.kppm
> ### Title: Log Likelihood and AIC for Fitted Cox or Cluster Point Process
> ###   Model
> ### Aliases: logLik.kppm AIC.kppm extractAIC.kppm nobs.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- kppm(redwood ~ x, "Thomas", method="palm")
>   nobs(fit)
[1] 62
>   logLik(fit)
'log Lik.' 1234.955 (df=2)
>   extractAIC(fit)
[1]     2.00 -2465.91
>   AIC(fit)
[1] -2465.91
>   step(fit)
Start:  AIC=-2465.91
~x

       Df     AIC
- x     1 -2478.7
<none>    -2465.9

Step:  AIC=-2478.72
~1

Stationary cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by maximum Palm likelihood
	rmax = 0.25
	weight function: Indicator(distance <= 0.125)

Uniform intensity:	62

Cluster model: Thomas process
Fitted cluster parameters:
      kappa       scale 
24.91180093  0.03554333 
Mean cluster size:  2.48878 points
> 
> 
> 
> cleanEx()
> nameEx("logLik.mppm")
> ### * logLik.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logLik.mppm
> ### Title: Log Likelihood and AIC for Multiple Point Process Model
> ### Aliases: logLik.mppm AIC.mppm extractAIC.mppm nobs.mppm getCall.mppm
> ###   terms.mppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- mppm(Bugs ~ x, hyperframe(Bugs=waterstriders))
>   logLik(fit)
'log Lik.' -564.1094 (df=2)
>   AIC(fit)
[1] 1132.219
>   nobs(fit)
[1] 110
>   getCall(fit)
mppm(formula = Bugs ~ x, data = hyperframe(Bugs = waterstriders))
> 
> 
> 
> cleanEx()
> nameEx("logLik.ppm")
> ### * logLik.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logLik.ppm
> ### Title: Log Likelihood and AIC for Point Process Model
> ### Aliases: logLik.ppm deviance.ppm AIC.ppm extractAIC.ppm nobs.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   data(cells)
>   fit <- ppm(cells, ~x)
>   nobs(fit)
[1] 42
>   logLik(fit)
'log Lik.' 115.0737 (df=2)
>   deviance(fit)
[1] 326.3207
>   extractAIC(fit)
[1]    2.0000 -226.1473
>   AIC(fit)
[1] -226.1473
>   step(fit)
Start:  AIC=-226.15
~x

       Df     AIC
- x     1 -227.96
<none>    -226.15

Step:  AIC=-227.96
~1

Stationary Poisson process
Intensity: 42
            Estimate      S.E.  CI95.lo  CI95.hi Ztest     Zval
log(lambda)  3.73767 0.1543033 3.435241 4.040099   *** 24.22287
> 
> 
> 
> cleanEx()
> nameEx("logLik.slrm")
> ### * logLik.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logLik.slrm
> ### Title: Loglikelihood of Spatial Logistic Regression
> ### Aliases: logLik.slrm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>   X <- rpoispp(42)
>   fit <- slrm(X ~ x+y)
>   logLik(fit)
'log Lik.' 96.8858 (df=3)
>   logLik(fit, adjust=FALSE)
'log Lik.' -262.1644 (df=3)
> 
> 
> 
> cleanEx()
> nameEx("lohboot")
> ### * lohboot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lohboot
> ### Title: Bootstrap Confidence Bands for Summary Function
> ### Aliases: lohboot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   p <- lohboot(simdat, stoyan=0.5)
>   g <- lohboot(simdat, stoyan=0.5, block=TRUE)
>   g
Function value object (class 'fv')
for the function r -> g(r)
..........................................................
       Math.label      Description                        
r      r               distance argument r                
theo   g[pois](r)      theoretical Poisson g(r)           
border hat(g)[bord](r) border-corrected estimate of g(r)  
lo     hat(g)[loCI](r) lower 95% confidence limit for g(r)
hi     hat(g)[hiCI](r) upper 95% confidence limit for g(r)
..........................................................
Default plot formula:  .~r
where "." stands for 'border', 'theo', 'hi', 'lo'
Columns 'hi' and 'lo' will be plotted as shading (by default)
Recommended range of argument r: [0, 2.5]
Available range of argument r: [0, 2.5]
>   plot(g)
> 
> 
> 
> cleanEx()
> nameEx("lpp")
> ### * lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lpp
> ### Title: Create Point Pattern on Linear Network
> ### Aliases: lpp
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   # letter 'A' 
>   v <- ppp(x=(-2):2, y=3*c(0,1,2,1,0), c(-3,3), c(-1,7))
>   edg <- cbind(1:4, 2:5)
>   edg <- rbind(edg, c(2,4))
>   letterA <- linnet(v, edges=edg)
> 
>   # points on letter A
>   xx <- list(x=c(-1.5,0,0.5,1.5), y=c(1.5,3,4.5,1.5))
>   X <- lpp(xx, letterA)
> 
>   plot(X)
>   X
Point pattern on linear network
4 points
Linear network with 5 vertices and 5 lines
Enclosing window: rectangle = [-3, 3] x [-1, 7] units
>   summary(X)
Point pattern on linear network
4 points
Linear network with 5 vertices and 5 lines
Total length 14.64911 units
Average intensity 0.2730541 points per unit length
Unmarked
Enclosing window: rectangle = [-3, 3] x [-1, 7] units
> 
>   # empty pattern
>   lpp(L=letterA)
Point pattern on linear network
0 points
Linear network with 5 vertices and 5 lines
Enclosing window: rectangle = [-3, 3] x [-1, 7] units
> 
> 
> 
> cleanEx()
> nameEx("lppm")
> ### * lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lppm
> ### Title: Fit Point Process Model to Point Pattern on Linear Network
> ### Aliases: lppm lppm.formula lppm.lpp
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <- runiflpp(15, simplenet)
>   lppm(X ~1)
Point process model on linear network
Stationary Poisson process
Intensity: 5.163775
            Estimate      S.E.  CI95.lo  CI95.hi Ztest     Zval
(Intercept) 1.641668 0.2581989 1.135607 2.147728   *** 6.358152
Original data: X
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   lppm(X ~x)
Point process model on linear network
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  1.4137374   0.4498367 

             Estimate      S.E.     CI95.lo  CI95.hi Ztest      Zval
(Intercept) 1.4137374 0.7337219 -0.02433113 2.851806       1.9268027
x           0.4498367 1.3331747 -2.16313771 3.062811       0.3374177
Original data: X
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   marks(X) <- factor(rep(letters[1:3], 5))
>   lppm(X ~ marks)
Point process model on linear network
Stationary multitype Poisson process

Possible marks: 'a', 'b' and 'c'

Log intensity:  ~marks

Intensities:
  beta_a   beta_b   beta_c 
1.721258 1.721258 1.721258 

                 Estimate      S.E.    CI95.lo  CI95.hi Ztest          Zval
(Intercept)  5.430556e-01 0.4472136 -0.3334669 1.419578        1.214309e+00
marksb      -2.754398e-12 0.6324555 -1.2395901 1.239590       -4.355086e-12
marksc      -9.437120e-13 0.6324555 -1.2395901 1.239590       -1.492140e-12
Original data: X
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   lppm(X ~ marks * x)
Point process model on linear network
Nonstationary multitype Poisson process

Possible marks: 'a', 'b' and 'c'

Log intensity:  ~marks * x

Fitted trend coefficients:
(Intercept)      marksb      marksc           x    marksb:x    marksc:x 
  0.7084241   0.6442487  -2.2879409  -0.3361913  -1.4017912   4.0909696 

              Estimate     S.E.   CI95.lo   CI95.hi Ztest       Zval
(Intercept)  0.7084241 1.205716 -1.654737  3.071585        0.5875545
marksb       0.6442487 1.651333 -2.592305  3.880802        0.3901385
marksc      -2.2879409 2.121261 -6.445536  1.869654       -1.0785758
x           -0.3361913 2.306030 -4.855927  4.183545       -0.1457879
marksb:x    -1.4017912 3.318114 -7.905176  5.101594       -0.4224662
marksc:x     4.0909696 3.547845 -2.862680 11.044619        1.1530856
Original data: X
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("lurking")
> ### * lurking
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lurking
> ### Title: Lurking Variable Plot
> ### Aliases: lurking lurking.ppp lurking.ppm
> ### Keywords: spatial models hplot
> 
> ### ** Examples
> 
>   (a <- lurking(nztrees, expression(x), type="raw"))
Lurking variable plot (object of class 'lurk')
Residual type:  raw residuals
Covariate on horizontal axis:  x
Range of covariate values:  [0, 153]
Cumulative plot
Includes standard deviation for confidence bands
Variance calculation: new style
>   fit <- ppm(nztrees ~x, Poisson(), nd=128)
>   (b <- lurking(fit, expression(x), type="raw"))
Lurking variable plot (object of class 'lurk')
Residual type:  raw residuals
Covariate on horizontal axis:  x
Range of covariate values:  [0, 153]
Cumulative plot
Includes standard deviation for confidence bands
Variance calculation: new style
>   lurking(fit, expression(x), type="raw", cumulative=FALSE)
> 
> 
> 
> cleanEx()
> nameEx("lurking.mppm")
> ### * lurking.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lurking.mppm
> ### Title: Lurking Variable Plot for Multiple Point Patterns
> ### Aliases: lurking.mppm
> ### Keywords: spatial models hplot
> 
> ### ** Examples
> 
>   fit <- mppm(Points ~ Image + Group, demohyper)
>   lurking(fit, expression(Image), type="P")
>   lurking(fit, expression(Image), type="P", separate=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("lut")
> ### * lut
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lut
> ### Title: Lookup Tables
> ### Aliases: lut
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # lookup table for real numbers, using breakpoints
>   cr <- lut(factor(c("low", "medium", "high")), breaks=c(0,5,10,15))
>   cr
Lookup table for the range [0, 15] 
  interval output
1   [0, 5)    low
2  [5, 10) medium
3 [10, 15]   high
>   cr(3.2)
[1] low
Levels: high low medium
>   cr(c(3,5,7))
[1] low    medium medium
Levels: high low medium
>   # lookup table for discrete set of values
>   ct <- lut(c(0,1), inputs=c(FALSE, TRUE))
>   ct(TRUE)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("markconnect")
> ### * markconnect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markconnect
> ### Title: Mark Connection Function
> ### Aliases: markconnect
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # Hughes' amacrine data
>     # Cells marked as 'on'/'off'
>     data(amacrine)
>     M <- markconnect(amacrine, "on", "off")
>     plot(M)
> 
>     # Compute for all pairs of types at once
>     plot(alltypes(amacrine, markconnect))
> 
> 
> 
> cleanEx()
> nameEx("markcorr")
> ### * markcorr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markcorr
> ### Title: Mark Correlation Function
> ### Aliases: markcorr
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # CONTINUOUS-VALUED MARKS:
>     # (1) Spruces
>     # marks represent tree diameter
>     # mark correlation function
>     ms <- markcorr(spruces)
>     plot(ms)
> 
>     # (2) simulated data with independent marks
>     X <- rpoispp(100)
>     X <- X %mark% runif(npoints(X))
>     ## Not run: 
> ##D     Xc <- markcorr(X)
> ##D     plot(Xc)
> ##D     
> ## End(Not run)
>     
>     # MULTITYPE DATA:
>     # Hughes' amacrine data
>     # Cells marked as 'on'/'off'
>     # (3) Kernel density estimate with Epanecnikov kernel
>     # (as proposed by Stoyan & Stoyan)
>     M <- markcorr(amacrine, function(m1,m2) {m1==m2},
+                   correction="translate", method="density",
+                   kernel="epanechnikov")
>     plot(M)
>     # Note: kernel="epanechnikov" comes from help(density)
> 
>     # (4) Same again with explicit control over bandwidth
>     ## Not run: 
> ##D     M <- markcorr(amacrine, 
> ##D                   correction="translate", method="density",
> ##D                   kernel="epanechnikov", bw=0.02)
> ##D     # see help(density) for correct interpretation of 'bw'
> ##D     
> ## End(Not run)
> 
>    ## Don't show: 
>     niets <- markcorr(amacrine, function(m1,m2){m1 == m2}, method="loess")
>     if(require(sm))
+       niets <- markcorr(X, correction="isotropic", method="smrep", hmult=2)
Loading required package: sm
Package 'sm', version 2.2-5.6: type help(sm) for summary information
>     
> ## End(Don't show)
> 
>    # weighted mark correlation
>    Y <- subset(betacells, select=type)
>    a <- marks(betacells)$area
>    v <- markcorr(Y, weights=a)
> 
> 
> 
> cleanEx()

detaching 'package:sm'

> nameEx("markcrosscorr")
> ### * markcrosscorr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markcrosscorr
> ### Title: Mark Cross-Correlation Function
> ### Aliases: markcrosscorr
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   # The dataset 'betacells' has two columns of marks:
>   #       'type' (factor)
>   #       'area' (numeric)
>   if(interactive()) plot(betacells)
>   plot(markcrosscorr(betacells))
> 
> 
> 
> cleanEx()
> nameEx("markmarkscatter")
> ### * markmarkscatter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markmarkscatter
> ### Title: Mark-Mark Scatter Plot
> ### Aliases: markmarkscatter
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   markmarkscatter(longleaf, 10)
> 
>   markmarkscatter(spruces, 10, jit=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("marks")
> ### * marks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marks
> ### Title: Marks of a Point Pattern
> ### Aliases: marks marks.ppp marks.ppx marks<- marks<-.ppp marks<-.ppx
> ###   setmarks %mark%
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    X <- amacrine
>    # extract marks
>    m <- marks(X)
>    # recode the mark values "off", "on" as 0, 1
>    marks(X) <- as.integer(m == "on")
> 
> 
> 
> cleanEx()
> nameEx("marks.psp")
> ### * marks.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marks.psp
> ### Title: Marks of a Line Segment Pattern
> ### Aliases: marks.psp marks<-.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   m <- data.frame(A=1:10, B=letters[1:10])
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin(), marks=m)
> 
>   marks(X) 
    A B
1   1 a
2   2 b
3   3 c
4   4 d
5   5 e
6   6 f
7   7 g
8   8 h
9   9 i
10 10 j
>   marks(X)[,2]
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
>   marks(X) <- 42
>   marks(X) <- NULL
> 
> 
> 
> cleanEx()
> nameEx("marks.tess")
> ### * marks.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marks.tess
> ### Title: Marks of a Tessellation
> ### Aliases: marks.tess marks.lintess marks<-.tess marks<-.lintess
> ###   unmark.tess unmark.lintess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   D <- dirichlet(cells)
>   marks(D) <- tile.areas(D)
> 
>   B <- lineardirichlet(runiflpp(5, simplenet))
>   marks(B) <- letters[1:5]
> 
> 
> 
> cleanEx()
> nameEx("markstat")
> ### * markstat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markstat
> ### Title: Summarise Marks in Every Neighbourhood in a Point Pattern
> ### Aliases: markstat
> ### Keywords: spatial programming
> 
> ### ** Examples
> 
>   trees <- longleaf
>   ## Don't show: 
>      trees <- trees[seq(1, npoints(trees), by=6)]
>   
> ## End(Don't show)
> 
>   # average diameter of 5 closest neighbours of each tree
>   md <- markstat(trees, mean, N=5)
> 
>   # range of diameters of trees within 10 metre radius
>   rd <- markstat(trees, range, R=10)
> 
> 
> 
> cleanEx()
> nameEx("marktable")
> ### * marktable
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marktable
> ### Title: Tabulate Marks in Neighbourhood of Every Point in a Point
> ###   Pattern
> ### Aliases: marktable
> ### Keywords: spatial programming
> 
> ### ** Examples
> 
>   head(marktable(amacrine, 0.1))
     mark
point off on
    1   1  1
    2   2  2
    3   4  3
    4   3  1
    5   4  1
    6   2  3
>   head(marktable(amacrine, 0.1, exclude=FALSE))
     mark
point off on
    1   1  2
    2   2  3
    3   4  4
    4   3  2
    5   4  2
    6   2  4
>   marktable(amacrine, N=1, collapse=TRUE)
     neighbour
point off  on
  off  17 125
  on  126  26
> 
> 
> 
> cleanEx()
> nameEx("markvario")
> ### * markvario
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markvario
> ### Title: Mark Variogram
> ### Aliases: markvario
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>     # Longleaf Pine data
>     # marks represent tree diameter
>     data(longleaf)
>     # Subset of this large pattern
>     swcorner <- owin(c(0,100),c(0,100))
>     sub <- longleaf[ , swcorner]
>     # mark correlation function
>     mv <- markvario(sub)
>     plot(mv)
> 
> 
> 
> cleanEx()
> nameEx("matchingdist")
> ### * matchingdist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matchingdist
> ### Title: Distance for a Point Pattern Matching
> ### Aliases: matchingdist
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # an optimal matching
>   X <- runifpoint(20)
>   Y <- runifpoint(20)
>   m.opt <- pppdist(X, Y)
>   summary(m.opt)
spa-1 matching of two planar point patterns (cutoff = 1)
pp1: 20 points
pp2: 20 points
window: rectangle = [0, 1] x [0, 1] units
point matching, 20 lines
matching is 1-1
distance: 0.162927358155896
>   matchingdist(m.opt)
[1] 0.1629274
>        # is the same as the distance given by summary(m.opt)
>   
>   # sequential nearest neighbour matching
>   # (go through all points of point pattern X in sequence
>   # and match each point with the closest point of Y that is
>   # still unmatched)
>   am <- matrix(0, 20, 20)
>   h <- matrix(c(1:20, rep(0,20)), 20, 2)
>   h[1,2] = nncross(X[1],Y)[1,2]
>   for (i in 2:20) {
+     nn <- nncross(X[i],Y[-h[1:(i-1),2]])[1,2]
+     h[i,2] <- ((1:20)[-h[1:(i-1),2]])[nn]
+   }
>   am[h] <- 1
>   m.nn <- pppmatching(X, Y, am)
>   matchingdist(m.nn, type="spa", cutoff=1, q=1)
[1] 0.176736
>        # is >= the distance obtained for m.opt
>        # in most cases strictly >
> 
>   opa <- par(mfrow=c(1,2))
>   plot(m.opt, main="optimal")
>   plot(m.nn,  main="nearest neighbour")
>   text(X, 1:20, pos=1, offset=0.3, cex=0.8)
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("matclust.estK")
> ### * matclust.estK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matclust.estK
> ### Title: Fit the Matern Cluster Point Process by Minimum Contrast
> ### Aliases: matclust.estK
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(redwood)
>     u <- matclust.estK(redwood, c(kappa=10, scale=0.1))
>     u
Minimum contrast fit (object of class "minconfit")
Model: Matern Cluster process
Fitted by matching theoretical K function to Kest(redwood)

Internal parameters fitted by minimum contrast ($par):
      kappa           R 
24.56179311  0.08653217 

Fitted cluster parameters:
      kappa       scale 
24.56179311  0.08653217 

Converged successfully after 83 function evaluations

Starting values of parameters:
kappa     R 
 10.0   0.1 
Domain of integration: [ 0 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u)
> 
> 
> 
> cleanEx()
> nameEx("matclust.estpcf")
> ### * matclust.estpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matclust.estpcf
> ### Title: Fit the Matern Cluster Point Process by Minimum Contrast Using
> ###   Pair Correlation
> ### Aliases: matclust.estpcf
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(redwood)
>     u <- matclust.estpcf(redwood, c(kappa=10, R=0.1))
>     u
Minimum contrast fit (object of class "minconfit")
Model: Matern Cluster process
Fitted by matching theoretical g function to pcf(redwood)

Internal parameters fitted by minimum contrast ($par):
     kappa          R 
24.3423653  0.0787361 

Fitted cluster parameters:
     kappa      scale 
24.3423653  0.0787361 

Converged successfully after 77 function evaluations

Starting values of parameters:
kappa     R 
 10.0   0.1 
Domain of integration: [ 0.0004883 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u, legendpos="topright")
> 
> 
> 
> cleanEx()
> nameEx("matrixpower")
> ### * matrixpower
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrixpower
> ### Title: Power of a Matrix
> ### Aliases: matrixpower matrixsqrt matrixinvsqrt
> ### Keywords: algebra array
> 
> ### ** Examples
> 
>   x <- matrix(c(10,2,2,1), 2, 2)
>   y <- matrixsqrt(x)
>   y
         [,1]      [,2]
[1,] 3.122245 0.5015860
[2,] 0.501586 0.8651078
>   y %*% y 
     [,1] [,2]
[1,]   10    2
[2,]    2    1
>   z <- matrixinvsqrt(x)
>   z %*% y
             [,1]          [,2]
[1,] 1.000000e+00 -2.775558e-17
[2,] 2.220446e-16  1.000000e+00
>   matrixpower(x, 0.1)
           [,1]       [,2]
[1,] 1.25046916 0.06455785
[2,] 0.06455785 0.95995884
> 
> 
> 
> cleanEx()
> nameEx("maxnndist")
> ### * maxnndist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maxnndist
> ### Title: Compute Minimum or Maximum Nearest-Neighbour Distance
> ### Aliases: maxnndist minnndist
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   min(nndist(swedishpines))
[1] 2.236068
>   minnndist(swedishpines)
[1] 2.236068
> 
>   max(nndist(swedishpines))
[1] 15.65248
>   maxnndist(swedishpines)
[1] 15.65248
> 
>   minnndist(lansing, positive=TRUE)
[1] 0.001
> 
>   if(interactive()) {
+      X <- rpoispp(1e6)
+      system.time(min(nndist(X)))
+      system.time(minnndist(X))
+   }
> 
>   minnndist(amacrine, by=marks(amacrine))
         off         on
1 0.02486202 0.00840000
2 0.00840000 0.03218897
>   maxnndist(amacrine, by=marks(amacrine))
        off        on
1 0.1542528 0.1087250
2 0.1086695 0.1627706
> 
> 
> 
> cleanEx()
> nameEx("mean.im")
> ### * mean.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean.im
> ### Title: Mean and Median of Pixel Values in an Image
> ### Aliases: mean.im median.im
> ### Keywords: spatial methods univar
> 
> ### ** Examples
> 
>   X <- as.im(function(x,y) {x^2}, unit.square())
>   mean(X)
[1] 0.3333282
>   median(X)
[1] 0.2500153
>   mean(X, trim=0.05)
[1] 0.3175132
> 
> 
> 
> cleanEx()
> nameEx("mean.linim")
> ### * mean.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean.linim
> ### Title: Mean, Median, Quantiles of Pixel Values on a Linear Network
> ### Aliases: mean.linim median.linim quantile.linim
> ### Keywords: spatial methods univar
> 
> ### ** Examples
> 
>   M <- as.mask.psp(as.psp(simplenet))
>   Z <- as.im(function(x,y) {x-y}, W=M)
>   X <- linim(simplenet, Z)
>   X
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
>   mean(X)
[1] -0.02873373
>   median(X)
[1] -0.078125
>   quantile(X)
        0%        25%        50%        75%       100% 
-0.6484375 -0.2187500 -0.0781250  0.1796875  0.5625000 
> 
> 
> 
> cleanEx()
> nameEx("measureContinuous")
> ### * measureContinuous
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: measureContinuous
> ### Title: Discrete and Continuous Components of a Measure
> ### Aliases: measureContinuous measureDiscrete
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    rp <- residuals(fit, type="pearson")
> 
>    rp
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 10.577   continuous = -10.463   total = 0.11362
>    measureDiscrete(rp)
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 10.577   continuous = 0   total = 10.577
>    measureContinuous(rp)
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 0   continuous = -10.463   total = -10.463
> 
> 
> 
> cleanEx()
> nameEx("measureVariation")
> ### * measureVariation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: measureVariation
> ### Title: Positive and Negative Parts, and Variation, of a Measure
> ### Aliases: measureVariation measurePositive measureNegative
> ###   totalVariation
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    rp <- residuals(fit, type="pearson")
> 
>    measurePositive(rp)
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 10.577   continuous = 0   total = 10.577
>    measureNegative(rp)
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 0   continuous = 10.463   total = 10.463
>    measureVariation(rp)
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 10.577   continuous = 10.463   total = 21.04
> 
>    # total variation norm
>    totalVariation(rp)
[1] 21.04031
> 
> 
> 
> cleanEx()
> nameEx("mergeLevels")
> ### * mergeLevels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mergeLevels
> ### Title: Merge Levels of a Factor
> ### Aliases: mergeLevels
> ### Keywords: manip spatial
> 
> ### ** Examples
> 
>    likert <- c("Strongly Agree", "Agree", "Neutral",
+                "Disagree", "Strongly Disagree")
>    answers <- factor(sample(likert, 15, replace=TRUE), levels=likert)
>    answers
 [1] Strongly Agree    Disagree          Strongly Agree    Agree            
 [5] Strongly Disagree Neutral           Agree             Neutral          
 [9] Neutral           Strongly Agree    Strongly Disagree Strongly Disagree
[13] Agree             Agree             Strongly Agree   
Levels: Strongly Agree Agree Neutral Disagree Strongly Disagree
>    mergeLevels(answers, Positive=c("Strongly Agree", "Agree"),
+                         Negative=c("Strongly Disagree", "Disagree"))
 [1] Positive Negative Positive Positive Negative Neutral  Positive Neutral 
 [9] Neutral  Positive Negative Negative Positive Positive Positive
Levels: Positive Neutral Negative
> 
> 
> 
> cleanEx()
> nameEx("methods.box3")
> ### * methods.box3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.box3
> ### Title: Methods for Three-Dimensional Box
> ### Aliases: methods.box3 print.box3 unitname.box3 unitname<-.box3
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    X <- box3(c(0,10),c(0,10),c(0,5), unitname=c("metre", "metres"))
>    X
Box: [0, 10] x [0, 10] x [0, 5] metres
>    unitname(X)
metre / metres 
>    # Northern European usage
>    unitname(X) <- "meter"
> 
> 
> 
> cleanEx()
> nameEx("methods.boxx")
> ### * methods.boxx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.boxx
> ### Title: Methods for Multi-Dimensional Box
> ### Aliases: methods.boxx print.boxx unitname.boxx unitname<-.boxx
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    X <- boxx(c(0,10),c(0,10),c(0,5),c(0,1), unitname=c("metre", "metres"))
>    X
4-dimensional box:
[0, 10] x [0, 10] x [0, 5] x [0, 1] metres  
>    unitname(X)
metre / metres 
>    # Northern European usage
>    unitname(X) <- "meter"
> 
> 
> 
> cleanEx()
> nameEx("methods.distfun")
> ### * methods.distfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.distfun
> ### Title: Geometrical Operations for Distance Functions
> ### Aliases: methods.distfun shift.distfun rotate.distfun
> ###   scalardilate.distfun affine.distfun flipxy.distfun reflect.distfun
> ###   rescale.distfun
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    (f <- distfun(letterR))
Distance function for window
window: polygonal boundary
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
>    plot(f)
>    flipxy(f)
Distance function for window
window: polygonal boundary
enclosing rectangle: [0.645, 3.278] x [2.017, 3.93] units
>    shift(f, origin="midpoint")
Distance function for window
window: polygonal boundary
enclosing rectangle: [-0.9565, 0.9565] x [-1.3165, 1.3165] units
>    plot(rotate(f, angle=pi/2))
> 
>    (g <- distfun(lansing))
Distance function for point pattern
Marked planar point pattern: 2251 points
Multitype, with levels = blackoak, hickory, maple, misc, redoak, whiteoak 
window: rectangle = [0, 1] x [0, 1] units (one unit = 924 feet)
>    rescale(g)
Distance function for point pattern
Marked planar point pattern: 2251 points
Multitype, with levels = blackoak, hickory, maple, misc, redoak, whiteoak 
window: rectangle = [0, 924] x [0, 924] feet
> 
> 
> 
> cleanEx()
> nameEx("methods.dppm")
> ### * methods.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.dppm
> ### Title: Methods for Determinantal Point Process Models
> ### Aliases: methods.dppm coef.dppm formula.dppm print.dppm terms.dppm
> ###   labels.dppm
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   fit <- dppm(swedishpines ~ x + y, dppGauss())
>   coef(fit)
  (Intercept)             x             y 
-5.1247387900  0.0045966001 -0.0002187224 
>   formula(fit)
~x + y
>   tf <- terms(fit)
>   labels(fit)
[1] "x" "y"
> 
> 
> 
> cleanEx()
> nameEx("methods.fii")
> ### * methods.fii
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.fii
> ### Title: Methods for Fitted Interactions
> ### Aliases: methods.fii print.fii plot.fii coef.fii summary.fii
> ###   print.summary.fii coef.summary.fii
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   mod <- ppm(cells, ~1, Strauss(0.1))
>   f <- fitin(mod)
>   f
Strauss process
Interaction distance:	0.1
Fitted interaction parameter gamma:	 0.0050219
>   summary(f)
Interaction: Strauss process
Interaction distance:	0.1
Fitted interaction parameter gamma:	 0.0050219

Relevant coefficients:
Interaction 
   -5.29395 
>   plot(f)
Warning in sprintf(legdesc, ylab) : argument not used by format
>   coef(f)
(Intercept) Interaction 
   7.037147   -5.293950 
>   coef(summary(f))
[1] 0.0050219
> 
> 
> 
> cleanEx()
> nameEx("methods.funxy")
> ### * methods.funxy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.funxy
> ### Title: Methods for Spatial Functions
> ### Aliases: methods.funxy contour.funxy persp.funxy plot.funxy
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    f <- distfun(letterR)
>    contour(f)
>    B <- owin(c(1,5), c(-1, 4))
>    contour(f, W=B)
>    persp(f, W=B, theta=40, phi=40, border=NA, shade=0.7)
> 
> 
> 
> cleanEx()
> nameEx("methods.kppm")
> ### * methods.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.kppm
> ### Title: Methods for Cluster Point Process Models
> ### Aliases: methods.kppm coef.kppm formula.kppm print.kppm terms.kppm
> ###   labels.kppm
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   data(redwood)
>   fit <- kppm(redwood ~ x, "MatClust")
>   coef(fit)
(Intercept)           x 
  3.9745791   0.2976994 
>   formula(fit)
~x
>   tf <- terms(fit)
>   labels(fit)
[1] "x"
> 
> 
> 
> cleanEx()
> nameEx("methods.layered")
> ### * methods.layered
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.layered
> ### Title: Methods for Layered Objects
> ### Aliases: methods.layered shift.layered reflect.layered flipxy.layered
> ###   rotate.layered affine.layered rescale.layered scalardilate.layered
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   L <- layered(letterR, runifpoint(20, letterR))
>   plot(L)
>   plot(rotate(L, pi/4))
> 
> 
> 
> cleanEx()
> nameEx("methods.linfun")
> ### * methods.linfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.linfun
> ### Title: Methods for Functions on Linear Network
> ### Aliases: methods.linfun print.linfun summary.linfun plot.linfun
> ###   as.data.frame.linfun as.owin.linfun as.function.linfun
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- runiflpp(3, simplenet)
>    f <- nnfun(X)
>    f
Nearest-neighbour function for lpp object
Point pattern on linear network
3 points
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
Function returns the index of the neighbour
>    plot(f)
>    as.function(f)
function (...) 
{
    argh <- list(...)
    extra <- names(argh) %in% otherfargs
    if (!any(extra)) {
        X <- as.lpp(..., L = L)
        value <- do.call(f, as.list(coords(X)))
    }
    else {
        extrargs <- argh[extra]
        mainargs <- argh[!extra]
        X <- do.call(as.lpp, append(mainargs, list(L = L)))
        value <- do.call(f, append(as.list(coords(X)), extrargs))
    }
    return(value)
}
<bytecode: 0x000000001a1ba238>
<environment: 0x0000000024c34d18>
>    as.owin(f)
window: rectangle = [0, 1] x [0, 1] units
>    head(as.data.frame(f))
         xc        yc         x         y seg         tp values
1 0.1523438 0.2148438 0.1519668 0.2151101   2 0.01287602      1
2 0.1523438 0.2226562 0.1556485 0.2203216   2 0.03382291      1
3 0.1601562 0.2226562 0.1582495 0.2240033   2 0.04862120      1
4 0.1601562 0.2304688 0.1619313 0.2292148   2 0.06956809      1
5 0.1679688 0.2304688 0.1645323 0.2328965   2 0.08436639      1
6 0.1679688 0.2382812 0.1682140 0.2381080   2 0.10531328      1
> 
> 
> 
> cleanEx()
> nameEx("methods.linim")
> ### * methods.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.linim
> ### Title: Methods for Images on a Linear Network
> ### Aliases: methods.linim as.im.linim as.data.frame.linim print.linim
> ###   summary.linim affine.linim scalardilate.linim shift.linim
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    M <- as.mask.psp(as.psp(simplenet))
>    Z <- as.im(function(x,y) {x-y}, W=M)
>    X <- linim(simplenet, Z)
>    ## ............  print basic details .........................
>    X
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
>    ## ............  print gory details  .........................
>    summary(X)
real-valued pixel image on a linear network
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
dimensions of each pixel: 0.00781 x 0.0078125 units
Pixel values (on network):
	range = [-0.6484375, 0.5625]
	integral = -0.08346721
	mean = -0.03898061
Underlying network:
Linear network with 10 vertices and 10 lines
Total length 2.904852 units
Maximum vertex degree: 4
[Non-sparse matrix representation]
Network is connected
Diameter: 1.248943 units
Bounding radius: 0.7793609 units
Numerical tolerance: 0.0001501466 units
Enclosing window: rectangle = [0, 1] x [0, 1] units
>    ## ...........................................................
>    shift(X, c(1,1))
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [1, 2] x [1, 2] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [1, 2] x [1, 2] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.00609 units
>    scalardilate(X, 2)
Image on linear network
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 2] x [0, 2] units
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 2] x [0, 2] units
 Data frame: 477 sample points along network
 Average density: one sample point per 0.0122 units
>    head(as.data.frame(X))
         xc        yc         x         y seg         tp     values
1 0.1523438 0.2148438 0.1519668 0.2151101   2 0.01287602 -0.0625000
2 0.1523438 0.2226562 0.1556485 0.2203216   2 0.03382291 -0.0703125
3 0.1601562 0.2226562 0.1582495 0.2240033   2 0.04862120 -0.0625000
4 0.1601562 0.2304688 0.1619313 0.2292148   2 0.06956809 -0.0703125
5 0.1679688 0.2304688 0.1645323 0.2328965   2 0.08436639 -0.0625000
6 0.1679688 0.2382812 0.1682140 0.2381080   2 0.10531328 -0.0703125
> 
> 
> 
> cleanEx()
> nameEx("methods.linnet")
> ### * methods.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.linnet
> ### Title: Methods for Linear Networks
> ### Aliases: methods.linnet as.linnet as.linnet.linnet as.owin.linnet
> ###   as.psp.linnet nsegments.linnet nvertices.linnet pixellate.linnet
> ###   print.linnet summary.linnet unitname.linnet unitname<-.linnet
> ###   vertexdegree vertices.linnet volume.linnet Window.linnet
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   simplenet
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   summary(simplenet)
Linear network with 10 vertices and 10 lines
Total length 2.904852 units
Maximum vertex degree: 4
[Non-sparse matrix representation]
Network is connected
Diameter: 1.248943 units
Bounding radius: 0.7793609 units
Numerical tolerance: 0.0001501466 units
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   nsegments(simplenet)
[1] 10
>   nvertices(simplenet)
[1] 10
>   pixellate(simplenet)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   volume(simplenet)
[1] 2.904852
>   unitname(simplenet) <- c("cubit", "cubits")
>   Window(simplenet)
window: rectangle = [0, 1] x [0, 1] cubits
> 
> 
> 
> cleanEx()
> nameEx("methods.lpp")
> ### * methods.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.lpp
> ### Title: Methods for Point Patterns on a Linear Network
> ### Aliases: methods.lpp as.ppp.lpp as.psp.lpp marks<-.lpp nsegments.lpp
> ###   print.lpp print.summary.lpp summary.lpp unitname.lpp unitname<-.lpp
> ###   unmark.lpp
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   X <- runiflpp(10, simplenet)
>   unitname(X) <- c("furlong", "furlongs")
>   X
Point pattern on linear network
10 points
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] furlongs
>   summary(X)
Point pattern on linear network
10 points
Linear network with 10 vertices and 10 lines
Total length 2.904852 furlongs
Average intensity 3.442517 points per furlong
Unmarked
Enclosing window: rectangle = [0, 1] x [0, 1] furlongs
>   summary(chicago)
Multitype point pattern on linear network
116 points
Linear network with 338 vertices and 503 lines
Total length 31150.21 feet
Average intensity 0.003723891 points per foot
Types of points:
         frequency proportion    intensity
assault         21 0.18103450 0.0006741528
burglary         5 0.04310345 0.0001605126
cartheft         7 0.06034483 0.0002247176
damage          35 0.30172410 0.0011235880
robbery          4 0.03448276 0.0001284100
theft           38 0.32758620 0.0012198950
trespass         6 0.05172414 0.0001926151
Enclosing window: rectangle = [0.3894, 1281.9863] x [153.1035, 1276.5602] feet
>   nsegments(X)
[1] 10
>   Y <- as.ppp(X)
> 
> 
> 
> cleanEx()
> nameEx("methods.lppm")
> ### * methods.lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.lppm
> ### Title: Methods for Fitted Point Process Models on a Linear Network
> ### Aliases: methods.lppm coef.lppm emend.lppm extractAIC.lppm formula.lppm
> ###   logLik.lppm deviance.lppm nobs.lppm print.lppm summary.lppm
> ###   terms.lppm update.lppm valid.lppm vcov.lppm as.linnet.lppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <- runiflpp(15, simplenet)
>   fit <- lppm(X ~ x)
>   print(fit)
Point process model on linear network
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
(Intercept)           x 
  1.4137374   0.4498367 

             Estimate      S.E.     CI95.lo  CI95.hi Ztest      Zval
(Intercept) 1.4137374 0.7337219 -0.02433113 2.851806       1.9268027
x           0.4498367 1.3331747 -2.16313771 3.062811       0.3374177
Original data: X
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   coef(fit)
(Intercept)           x 
  1.4137374   0.4498367 
>   formula(fit)
~x
>   terms(fit)
~x
attr(,"variables")
list(x)
attr(,"factors")
  x
x 1
attr(,"term.labels")
[1] "x"
attr(,"order")
[1] 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 0
attr(,".Environment")
<environment: R_GlobalEnv>
>   logLik(fit)
'log Lik.' 9.682089 (df=2)
>   deviance(fit)
[1] -19.36418
>   nobs(fit)
[1] 15
>   extractAIC(fit)
[1]   2.00000 -15.36418
>   update(fit, ~1)
Point process model on linear network
Stationary Poisson process
Intensity: 5.163775
            Estimate      S.E.  CI95.lo  CI95.hi Ztest     Zval
log(lambda) 1.641668 0.2581989 1.135607 2.147728   *** 6.358152
Original data: X
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   valid(fit)
[1] TRUE
>   vcov(fit)
            (Intercept)          x
(Intercept)   0.5383478 -0.9156117
x            -0.9156117  1.7773548
> 
> 
> 
> cleanEx()
> nameEx("methods.objsurf")
> ### * methods.objsurf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.objsurf
> ### Title: Methods for Objective Function Surfaces
> ### Aliases: methods.objsurf print.objsurf plot.objsurf persp.objsurf
> ###   image.objsurf contour.objsurf
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>  fit <- kppm(redwood ~ 1, "Thomas")
>  os <- objsurf(fit)
Evaluating 1024 function values...Done.
>   os
Objective function surface
Parameter ranges:
kappa: [15.7007632869552, 35.3267173956493] 
sigma2: [0.0014755567765475, 0.00332000274723187] 
Function value: contrast 
>   plot(os)
>   contour(os, add=TRUE)
>   persp(os)
> 
> 
> 
> cleanEx()
> nameEx("methods.pp3")
> ### * methods.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.pp3
> ### Title: Methods for three-dimensional point patterns
> ### Aliases: methods.pp3 print.pp3 summary.pp3 print.summary.pp3
> ###   unitname.pp3 unitname<-.pp3
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    X <- pp3(runif(42),runif(42),runif(42), box3(c(0,1), unitname="mm"))
>    X
Three-dimensional point pattern: 42 points
Box: [0, 1] x [0, 1] x [0, 1] mm
>    unitname(X)
mm / mm 
>    unitname(X) <- c("foot", "feet")
>    summary(X)
Three-dimensional point pattern
42 points
Box: [0, 1] x [0, 1] x [0, 1] feet
Volume 1 cubic foot
Average intensity 42 points per cubic foot
> 
> 
> 
> cleanEx()
> nameEx("methods.rho2hat")
> ### * methods.rho2hat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.rho2hat
> ### Title: Methods for Intensity Functions of Two Spatial Covariates
> ### Aliases: methods.rho2hat predict.rho2hat print.rho2hat plot.rho2hat
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   r2 <- with(bei.extra, rho2hat(bei, elev, grad))
>   r2
Scatterplot intensity estimate (class rho2hat)
for the covariates elev and grad 
Function values are absolute intensities
Call: rho2hat(bei, elev, grad) 
Obtained by transforming to the unit square and smoothing
Smoothing parameters (on unit square) used by density.ppp:
	sigma =  0.125 
Intensity values:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   plot(r2)
>   plot(predict(r2))
> 
> 
> 
> cleanEx()
> nameEx("methods.rhohat")
> ### * methods.rhohat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.rhohat
> ### Title: Methods for Intensity Functions of Spatial Covariate
> ### Aliases: methods.rhohat print.rhohat plot.rhohat predict.rhohat
> ###   simulate.rhohat
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   X <-  rpoispp(function(x,y){exp(3+3*x)})
>   rho <- rhohat(X, function(x,y){x})
>   rho
Intensity function estimate (class rhohat) for the covariate X
Function values are absolute intensities
Estimation method: ratio of fixed-bandwidth kernel smoothers
Smoother: Kernel density estimator
	Actual smoothing bandwidth sigma =  0.081392
Pointwise 95% confidence bands for rho(x)
	 based on asymptotic variance of rhohat(x)
Call: rhohat.ppp(X, function(x, y) {

Function value object (class 'fv')
for the function X -> rho(X)
Warning in sprintf(desc, ylab) : argument not used by format
..........................................................................
    Math.label            Description                                     
X   X                     covariate X                                     
rho hat(rho)(X)           Estimated intensity                             
var bold(Var)~hat(rho)(X) Variance of estimator                           
hi  rho[hi](X)            Upper limit of pointwise 95% confidence interval
lo  rho[lo](X)            Lower limit of pointwise 95% confidence interval
..........................................................................
Default plot formula:  .~X
where "." stands for 'rho', 'hi', 'lo'
Columns 'hi' and 'lo' will be plotted as shading (by default)
Recommended range of argument X: [0.013021, 0.99608]
Available range of argument X: [0.0037508, 0.99623]
>   plot(rho)
Warning in sprintf(legdesc, ylab) : argument not used by format
>   Y <- predict(rho)
>   plot(Y)
>   plot(simulate(rho), add=TRUE)
>   # 
>   fit <- ppm(X, ~x)
>   rho <- rhohat(fit, "y")
>   opa <- par(mfrow=c(1,2))
>   plot(predict(rho))
>   plot(predict(rho, relative=TRUE))
>   par(opa)
>   plot(predict(rho, what="se"))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("methods.slrm")
> ### * methods.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.slrm
> ### Title: Methods for Spatial Logistic Regression Models
> ### Aliases: methods.slrm formula.slrm update.slrm print.slrm terms.slrm
> ###   labels.slrm
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   data(redwood)
>   fit <- slrm(redwood ~ x)
>   coef(fit)
(Intercept)           x 
  3.9763588   0.3016171 
>   formula(fit)
redwood ~ x
>   tf <- terms(fit)  
>   labels(fit)  
[1] "x"
> 
> 
> 
> cleanEx()
> nameEx("methods.ssf")
> ### * methods.ssf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.ssf
> ### Title: Methods for Spatially Sampled Functions
> ### Aliases: methods.ssf marks.ssf marks<-.ssf unmark.ssf as.im.ssf
> ###   as.function.ssf as.ppp.ssf print.ssf summary.ssf range.ssf min.ssf
> ###   max.ssf integral.ssf
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   g <- distfun(cells[1:4])
>   X <- rsyst(Window(cells), 10)
>   f <- ssf(X, g(X))
>   f
Spatially sampled function
Locations:
	Planar point pattern: 100 points
window: rectangle = [0, 1] x [0, 1] units
Scalar valued function
>   summary(f)
Spatially sampled function
Locations:
	Marked planar point pattern:  100 points
Average intensity 100 points per square unit

Coordinates are given to 8 decimal places

marks are numeric, of type 'double'
Summary:
       V1         
 Min.   :0.01651  
 1st Qu.:0.25250  
 Median :0.46157  
 Mean   :0.47373  
 3rd Qu.:0.69481  
 Max.   :0.96689  

Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
>   marks(f)
             [,1]
  [1,] 0.32367960
  [2,] 0.22378261
  [3,] 0.12405173
  [4,] 0.02643869
  [5,] 0.07751889
  [6,] 0.06358520
  [7,] 0.01651385
  [8,] 0.04996460
  [9,] 0.05297768
 [10,] 0.15204212
 [11,] 0.34236087
 [12,] 0.25004227
 [13,] 0.16682718
 [14,] 0.11463630
 [15,] 0.07858360
 [16,] 0.06391835
 [17,] 0.08783613
 [18,] 0.12222495
 [19,] 0.12348730
 [20,] 0.18857170
 [21,] 0.38685067
 [22,] 0.30816167
 [23,] 0.24550720
 [24,] 0.21350401
 [25,] 0.16191930
 [26,] 0.15533201
 [27,] 0.18750377
 [28,] 0.20752792
 [29,] 0.21838404
 [30,] 0.26077148
 [31,] 0.44955080
 [32,] 0.38393501
 [33,] 0.33573243
 [34,] 0.29723756
 [35,] 0.25741083
 [36,] 0.25331899
 [37,] 0.28649727
 [38,] 0.30084932
 [39,] 0.31643968
 [40,] 0.34705078
 [41,] 0.52396412
 [42,] 0.46888012
 [43,] 0.43030076
 [44,] 0.38521766
 [45,] 0.35539107
 [46,] 0.35243863
 [47,] 0.37699226
 [48,] 0.39743275
 [49,] 0.41542333
 [50,] 0.43918871
 [51,] 0.60578946
 [52,] 0.55883007
 [53,] 0.52012013
 [54,] 0.47794887
 [55,] 0.45425246
 [56,] 0.45194631
 [57,] 0.47134450
 [58,] 0.49537387
 [59,] 0.51479998
 [60,] 0.53416215
 [61,] 0.69240404
 [62,] 0.65171583
 [63,] 0.60874250
 [64,] 0.57312965
 [65,] 0.55352305
 [66,] 0.55163207
 [67,] 0.56763379
 [68,] 0.59400147
 [69,] 0.61437896
 [70,] 0.63069143
 [71,] 0.78221853
 [72,] 0.74343778
 [73,] 0.70043551
 [74,] 0.66971642
 [75,] 0.65301627
 [76,] 0.65141417
 [77,] 0.66501925
 [78,] 0.69293634
 [79,] 0.71287474
 [80,] 0.72815806
 [81,] 0.87424728
 [82,] 0.83231136
 [83,] 0.79413625
 [84,] 0.76717831
 [85,] 0.75264383
 [86,] 0.75125422
 [87,] 0.76308130
 [88,] 0.78752984
 [89,] 0.80971160
 [90,] 0.82623037
 [91,] 0.96688909
 [92,] 0.92346342
 [93,] 0.88921024
 [94,] 0.86521964
 [95,] 0.85235861
 [96,] 0.85113182
 [97,] 0.86158897
 [98,] 0.88331519
 [99,] 0.90723501
[100,] 0.92471569
>   as.ppp(f)
Marked planar point pattern: 100 points
marks are numeric, of storage type  'double'
window: rectangle = [0, 1] x [0, 1] units
>   as.im(f)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   integral(f)
[1] 0.4737286
>   integral(f, quadrats(Window(f), 3))
Tile row 1, col 1 Tile row 1, col 2 Tile row 1, col 3 Tile row 2, col 1 
       0.81737199        0.75572316        0.80807854        0.49771869 
Tile row 2, col 2 Tile row 2, col 3 Tile row 3, col 1 Tile row 3, col 2 
       0.41103177        0.46664937        0.22715357        0.09919012 
Tile row 3, col 3 
       0.15288353 
> 
> 
> 
> cleanEx()
> nameEx("methods.zclustermodel")
> ### * methods.zclustermodel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods.zclustermodel
> ### Title: Methods for Cluster Models
> ### Aliases: methods.zclustermodel pcfmodel.zclustermodel
> ###   predict.zclustermodel print.zclustermodel
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   m <- zclustermodel("Thomas", kappa=10, mu=5, scale=0.1)
>   m2 <- zclustermodel("VarGamma", kappa=10, mu=10, scale=0.1, nu=0.7)
>   m
Thomas process
Parent intensity kappa = 10
Cluster scale =  0.1
Mean cluster size mu = 5
>   m2
Variance Gamma process (nu=0.7)
Parent intensity kappa = 10
Cluster scale =  0.1
Mean cluster size mu = 10
Cluster shape parameter: nu=0.7
>   g <- pcfmodel(m)
>   g(0.2)
   scale 
1.072005 
>   g2 <- pcfmodel(m2)
>   g2(1)
   scale 
1.000594 
>   Z <- predict(m, locations=square(2))
>   Z2 <- predict(m2, locations=square(1))
>   varcount(m, square(1))
[1] 155.2406
>   varcount(m2, square(1))
[1] 748.3988
> 
> 
> 
> cleanEx()
> nameEx("midpoints.psp")
> ### * midpoints.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: midpoints.psp
> ### Title: Midpoints of Line Segment Pattern
> ### Aliases: midpoints.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   b <- midpoints.psp(a)   
> 
> 
> 
> cleanEx()
> nameEx("miplot")
> ### * miplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: miplot
> ### Title: Morisita Index Plot
> ### Aliases: miplot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  data(longleaf)
>  miplot(longleaf)
>  opa <- par(mfrow=c(2,3))
>  data(cells)
>  data(japanesepines)
>  data(redwood)
>  plot(cells)
>  plot(japanesepines)
>  plot(redwood)
>  miplot(cells)
>  miplot(japanesepines)
>  miplot(redwood)
>  par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("model.depends")
> ### * model.depends
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model.depends
> ### Title: Identify Covariates Involved in each Model Term
> ### Aliases: model.depends model.is.additive model.covariates
> ###   has.offset.term has.offset
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    x <- 1:10
>    y <- 3*x + 2
>    z <- rep(c(-1,1), 5)
>    fit <- lm(y ~ poly(x,2) + sin(z))
>    model.depends(fit)
                x     z
(Intercept) FALSE FALSE
poly(x, 2)1  TRUE FALSE
poly(x, 2)2  TRUE FALSE
sin(z)      FALSE  TRUE
>    model.covariates(fit)
[1] "x" "z"
>    model.is.additive(fit)
[1] TRUE
> 
>    fitoff1 <- lm(y ~ x + offset(z))
>    fitoff2 <- lm(y ~ x, offset=z)
>    has.offset.term(fitoff1)
[1] TRUE
>    has.offset(fitoff1)
[1] TRUE
>    has.offset.term(fitoff2)
[1] FALSE
>    has.offset(fitoff2)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("model.frame.ppm")
> ### * model.frame.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model.frame.ppm
> ### Title: Extract the Variables in a Point Process Model
> ### Aliases: model.frame.ppm model.frame.kppm model.frame.dppm
> ###   model.frame.lppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- ppm(cells ~ x)
>   mf <- model.frame(fit)
>   kfit <- kppm(redwood ~ x, "Thomas")
>   kmf <- model.frame(kfit)
> 
> 
> 
> cleanEx()
> nameEx("model.images")
> ### * model.images
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model.images
> ### Title: Compute Images of Constructed Covariates
> ### Aliases: model.images model.images.ppm model.images.dppm
> ###   model.images.kppm model.images.lppm model.images.slrm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit <- ppm(cells ~ x)
>    model.images(fit)
List of pixel images

(Intercept):
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units

x:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>    B <- owin(c(0.2, 0.4), c(0.3, 0.8))
>    model.images(fit, B)
List of pixel images

(Intercept):
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0.2, 0.4] x [0.3, 0.8] units

x:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0.2, 0.4] x [0.3, 0.8] units
>    fit2 <- ppm(cells ~ cut(x,3))
>    model.images(fit2)
List of pixel images

(Intercept):
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units

cut(x, 3)(0.335,0.665]:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units

cut(x, 3)(0.665,0.997]:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>    fit3 <- slrm(japanesepines ~ x)
>    model.images(fit3)
List of pixel images

(Intercept):
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units (one unit = 5.7 metres)

x:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units (one unit = 5.7 metres)
>    fit4 <- ppm(amacrine ~ marks + x)
>    model.images(fit4)
Hyperframe:
             off   on
(Intercept) (im) (im)
markson     (im) (im)
x           (im) (im)
> 
> 
> 
> cleanEx()
> nameEx("model.matrix.mppm")
> ### * model.matrix.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model.matrix.mppm
> ### Title: Extract Design Matrix of Point Process Model for Several Point
> ###   Patterns
> ### Aliases: model.matrix.mppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit <- mppm(Points ~ Image + x, demohyper)
>    head(model.matrix(fit))
  (Intercept)      Image        x
1           1 0.02762078 3.686521
2           1 0.02140887 3.522012
3           1 0.27044880 3.106585
4           1 0.22427189 3.508583
5           1 0.13401535 3.645691
6           1 0.17548076 3.357957
>    # matrix with three columns: '(Intercept)', 'x' and 'Image'
> 
> 
> 
> cleanEx()
> nameEx("model.matrix.ppm")
> ### * model.matrix.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model.matrix.ppm
> ### Title: Extract Design Matrix from Point Process Model
> ### Aliases: model.matrix.ppm model.matrix.kppm model.matrix.dppm
> ###   model.matrix.lppm model.matrix.ippm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit <- ppm(cells ~ x)
>    head(model.matrix(fit))
  (Intercept)     x
1           1 0.350
2           1 0.487
3           1 0.637
4           1 0.775
5           1 0.825
6           1 0.087
>    model.matrix(fit, Q=runifpoint(5))
  (Intercept)         x
1           1 0.2655087
2           1 0.3721239
3           1 0.5728534
4           1 0.9082078
5           1 0.2016819
attr(,"assign")
[1] 0 1
>    kfit <- kppm(redwood ~ x, "Thomas")
>    m <- model.matrix(kfit)
> 
> 
> 
> cleanEx()
> nameEx("model.matrix.slrm")
> ### * model.matrix.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model.matrix.slrm
> ### Title: Extract Design Matrix from Spatial Logistic Regression Model
> ### Aliases: model.matrix.slrm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit <- slrm(japanesepines ~x)
>    head(model.matrix(fit))
  (Intercept)          x
1           1 0.00390625
2           1 0.00390625
3           1 0.00390625
4           1 0.00390625
5           1 0.00390625
6           1 0.00390625
>    # matrix with two columns: '(Intercept)' and 'x'
> 
> 
> 
> cleanEx()
> nameEx("mppm")
> ### * mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mppm
> ### Title: Fit Point Process Model to Several Point Patterns
> ### Aliases: mppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
> # Waterstriders data
>  H <- hyperframe(Y = waterstriders)
>  mppm(Y ~ 1,  data=H)
Point process model fitted to 3 point patterns
Call: mppm(Y ~ 1, data = H)
Log trend formula: ~1
Fitted trend coefficients:
(Intercept) 
  -4.131233 

Interaction for all patterns:	Poisson process


>  mppm(Y ~ 1,  data=H, Strauss(7))
Point process model fitted to 3 point patterns
Call: mppm(Y ~ 1, data = H, Strauss(7))
Log trend formula: ~1
Fitted trend coefficients:
(Intercept) 
   -3.64098 

Interaction for all patterns:	Strauss(r = 7, gamma = 0.779)

>  mppm(Y ~ id, data=H)
Point process model fitted to 3 point patterns
Call: mppm(Y ~ id, data = H)
Log trend formula: ~id
Fitted trend coefficients:
(Intercept)         id2         id3 
-4.10897819 -0.08296349  0.01789821 

Interaction for all patterns:	Poisson process


>  mppm(Y ~ x,  data=H)
Point process model fitted to 3 point patterns
Call: mppm(Y ~ x, data = H)
Log trend formula: ~x
Fitted trend coefficients:
 (Intercept)            x 
-4.000768330 -0.005581893 

Interaction for all patterns:	Poisson process


> 
> # Synthetic data from known model
> n <- 10
> H <- hyperframe(V=1:n,
+                 U=runif(n, min=-1, max=1),
+                 M=factor(letters[1 + (1:n) %% 3]))
> H$Z <- setcov(square(1))
> H$U <- with(H, as.im(U, as.rectangle(Z)))
> H$Y <- with(H, rpoispp(eval.im(exp(2+3*Z))))
> 
> fit <- mppm(Y ~Z + U + V, data=H)
> 
> 
> 
> cleanEx()
> nameEx("msr")
> ### * msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: msr
> ### Title: Signed or Vector-Valued Measure
> ### Aliases: msr
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    
>    rp <- residuals(fit, type="pearson")
>    rp
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 10.577   continuous = -10.463   total = 0.11362
> 
>    rs <- residuals(fit, type="score")
>    rs
3-dimensional vector-valued measure
vector components: '(Intercept)', 'x' and 'y'
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
(Intercept):	 discrete = 129   continuous = -129   total = -1.6468e-11
x:	 discrete = 92.592   continuous = -92.592   total = -5.5327e-12
y:	 discrete = 64.064   continuous = -64.064   total = -8.1466e-12
>    colnames(rs)
[1] "(Intercept)" "x"           "y"          
> 
>    # An equivalent way to construct the Pearson residual measure by hand
>    Q <- quad.ppm(fit)
>    lambda <- fitted(fit)
>    slam <- sqrt(lambda)
>    Z <- is.data(Q)
>    m <- msr(Q, discrete=1/slam[Z], density = -slam)
>    m
Scalar-valued measure
Approximated by 1157 quadrature points
window: rectangle = [0, 1] x [0, 1] units
129 atoms
Total mass:
discrete = 10.577   continuous = -10.463   total = 0.11362
> 
> 
> 
> cleanEx()
> nameEx("multiplicity.ppp")
> ### * multiplicity.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: multiplicity.ppp
> ### Title: Count Multiplicity of Duplicate Points
> ### Aliases: multiplicity multiplicity.default multiplicity.data.frame
> ###   multiplicity.ppp multiplicity.ppx
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>    X <- ppp(c(1,1,0.5,1), c(2,2,1,2), window=square(3), check=FALSE)
>    m <- multiplicity(X)
> 
>    # unique points in X, marked by their multiplicity
>    first <- !duplicated(X)
>    Y <- X[first] %mark% m[first]
> 
> 
> 
> cleanEx()
> nameEx("nearest.raster.point")
> ### * nearest.raster.point
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nearest.raster.point
> ### Title: Find Pixel Nearest to a Given Point
> ### Aliases: nearest.raster.point
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   w <- owin(c(0,1), c(0,1), mask=matrix(TRUE, 100,100))  # 100 x 100 grid
>   nearest.raster.point(0.5, 0.3, w)
$row
[1] 30

$col
[1] 51

>   nearest.raster.point(0.5, 0.3, w, indices=FALSE)
$x
[1] 0.505

$y
[1] 0.295

> 
> 
> 
> cleanEx()
> nameEx("nearestValue")
> ### * nearestValue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nearestValue
> ### Title: Image of Nearest Defined Pixel Value
> ### Aliases: nearestValue
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- as.im(function(x,y) { x + y }, letterR)
>   Y <- nearestValue(X)
>   plot(solist("X"=X,"nearestValue(X)"=Y), main="", panel.end=letterR)
> 
> 
> 
> cleanEx()
> nameEx("nearestsegment")
> ### * nearestsegment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nearestsegment
> ### Title: Find Line Segment Nearest to Each Point
> ### Aliases: nearestsegment
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- runifpoint(3)
>   Y <- as.psp(matrix(runif(20), 5, 4), window=owin())
>   v <- nearestsegment(X,Y)
>   plot(Y)
>   plot(X, add=TRUE)
>   plot(X[1], add=TRUE, col="red")
>   plot(Y[v[1]], add=TRUE, lwd=2, col="red") 
> 
> 
> 
> cleanEx()
> nameEx("nestsplit")
> ### * nestsplit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nestsplit
> ### Title: Nested Split
> ### Aliases: nestsplit
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # factor and tessellation
>   Nft <- nestsplit(amacrine, marks(amacrine), quadrats(amacrine, 3, 1))
>   Ntf <- nestsplit(amacrine, quadrats(amacrine, 3, 1), marks(amacrine))
>   Ntf
Hyperframe:
    pts f1  f2
1 (ppp)  1 off
2 (ppp)  1  on
3 (ppp)  2 off
4 (ppp)  2  on
5 (ppp)  3 off
6 (ppp)  3  on
> 
>   # two factors
>   big <- with(marks(betacells), area > 300)
>   Nff <- nestsplit(betacells, "type", factor(big))
> 
>   # two tessellations
>   Tx <- quantess(redwood, "x", 4)
>   Td <- dirichlet(runifpoint(5, Window(redwood)))
>   Ntt <- nestsplit(redwood, Td, Tx)
>   Ntt2 <- nestsplit(redwood, Td, ny=3)
> 
> 
> 
> cleanEx()
> nameEx("nnclean")
> ### * nnclean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnclean
> ### Title: Nearest Neighbour Clutter Removal
> ### Aliases: nnclean nnclean.ppp nnclean.pp3
> ### Keywords: spatial classif
> 
> ### ** Examples
> 
>   # shapley galaxy cluster
>   X <- nnclean(shapley, k=17, plothist=TRUE)
Iteration 1 	logLik = 278639.351265579 	p = 0.7999 
Iteration 2 	logLik = 291807.054056264 	p = 0.6958 
Iteration 3 	logLik = 301159.278584005 	p = 0.599 
Iteration 4 	logLik = 306823.492143299 	p = 0.5188 
Iteration 5 	logLik = 308987.009704574 	p = 0.4717 
Iteration 6 	logLik = 309393.565081773 	p = 0.4474 
Iteration 7 	logLik = 309320.073419838 	p = 0.4342 
Estimated parameters:
p [cluster] = 0.43422 
lambda [cluster] = 177.77 
lambda [noise]   = 12.549 
>   plot(X, which.marks=1, chars=c(".", "+"), cols=1:2,
+        main="Shapley data, cluster and noise")
>   plot(X, which.marks=2, cols=function(x)hsv(0.2+0.8*(1-x),1,1),
+        main="Shapley data, probability of cluster")
>   Y <- split(X, un=TRUE)
>   plot(Y, chars="+", cex=0.5)
>   marks(X) <- marks(X)$prob
>   plot(cut(X, breaks=3), chars=c(".", "+", "+"), cols=1:3)
> 
> 
> 
> cleanEx()
> nameEx("nncorr")
> ### * nncorr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nncorr
> ### Title: Nearest-Neighbour Correlation Indices of Marked Point Pattern
> ### Aliases: nncorr nnmean nnvario
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   nnmean(finpines)
             diameter   height
unnormalised 2.555556 2.871296
normalised   1.009404 1.015247
>   nnvario(finpines)
             diameter   height
unnormalised 3.694444 1.417928
normalised   1.162146 1.084491
>   nncorr(finpines)
               diameter     height
unnormalised  5.8240741  7.9618981
normalised    0.9086290  0.9954150
correlation  -0.2173841 -0.1839798
>   # heights of neighbouring trees are slightly negatively correlated
> 
>   nncorr(amacrine)
unnormalised   normalised 
   0.1338583    0.2674072 
>   # neighbouring cells are usually of different type
> 
> 
> 
> cleanEx()
> nameEx("nncross")
> ### * nncross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nncross
> ### Title: Nearest Neighbours Between Two Patterns
> ### Aliases: nncross nncross.ppp nncross.default
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # two different point patterns
>   X <- runifpoint(15)
>   Y <- runifpoint(20)
>   N <- nncross(X,Y)$which
>   # note that length(N) = 15
>   plot(superimpose(X=X,Y=Y), main="nncross", cols=c("red","blue"))
>   arrows(X$x, X$y, Y[N]$x, Y[N]$y, length=0.15)
> 
>   # third-nearest neighbour
>   NXY <- nncross(X, Y, k=3)
>   NXY[1:3,]
     dist.3 which.3
1 0.2175003       1
2 0.2639883       1
3 0.2450247      18
>   # second and third nearest neighbours
>   NXY <- nncross(X, Y, k=2:3)
>   NXY[1:3,]
     dist.2    dist.3 which.2 which.3
1 0.1717697 0.2175003      10       1
2 0.1711482 0.2639883      15       1
3 0.1672208 0.2450247      20      18
> 
>   # two patterns with some points in common
>   Z <- runifpoint(50)
>   X <- Z[1:30]
>   Y <- Z[20:50]
>   iX <- 1:30
>   iY <- 20:50
>   N <- nncross(X,Y, iX, iY)$which
>   N <- nncross(X,Y, iX, iY, what="which") #faster
>   plot(superimpose(X=X, Y=Y), main="nncross", cols=c("red","blue"))
>   arrows(X$x, X$y, Y[N]$x, Y[N]$y, length=0.15)
> 
>   # point pattern and line segment pattern
>   X <- runifpoint(15)
>   Y <- rpoisline(10)
>   N <- nncross(X,Y)
> 
> 
> 
> cleanEx()
> nameEx("nncross.lpp")
> ### * nncross.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nncross.lpp
> ### Title: Nearest Neighbours on a Linear Network
> ### Aliases: nncross.lpp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # two different point patterns
>   X <- runiflpp(3, simplenet)
>   Y <- runiflpp(5, simplenet)
>   nn <- nncross(X,Y)
>   nn
       dist which
1 0.1854072     2
2 0.2184711     5
3 0.2484920     3
>   plot(simplenet, main="nncross")
>   plot(X, add=TRUE, cols="red")
>   plot(Y, add=TRUE, cols="blue", pch=16)
>   XX <- as.ppp(X)
>   YY <- as.ppp(Y)
>   i <- nn$which
>   arrows(XX$x, XX$y, YY[i]$x, YY[i]$y, length=0.15)
> 
>   # nearest and second-nearest neighbours
>   nncross(X, Y, k=1:2)
     dist.1    dist.2 which.1 which.2
1 0.1854072 0.5281726       2       5
2 0.2184711 0.4951086       5       2
3 0.2484920 0.2770122       3       1
> 
>   # two patterns with some points in common
>   X <- Y[1:2]
>   iX <- 1:2
>   iY <- 1:5
>   nncross(X,Y, iX, iY)
        dist which
1 0.02852014     3
2 0.65781307     4
> 
> 
> 
> cleanEx()
> nameEx("nncross.pp3")
> ### * nncross.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nncross.pp3
> ### Title: Nearest Neighbours Between Two Patterns in 3D
> ### Aliases: nncross.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # two different point patterns
>   X <- pp3(runif(10), runif(10), runif(10), box3(c(0,1)))
>   Y <- pp3(runif(20), runif(20), runif(20), box3(c(0,1)))
>   N <- nncross(X,Y)$which
>   N <- nncross(X,Y, what="which") #faster
>   # note that length(N) = 10
> 
>   # k-nearest neighbours
>   N3 <- nncross(X, Y, k=1:3)
> 
>   # two patterns with some points in common
>   Z <- pp3(runif(20), runif(20), runif(20), box3(c(0,1)))
>   X <- Z[1:15]
>   Y <- Z[10:20]
>   iX <- 1:15
>   iY <- 10:20
>   N <- nncross(X,Y, iX, iY, what="which")
> 
> 
> 
> 
> cleanEx()
> nameEx("nncross.ppx")
> ### * nncross.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nncross.ppx
> ### Title: Nearest Neighbours Between Two Patterns in Any Dimensions
> ### Aliases: nncross.ppx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   B <- boxx(c(0,1), c(0,1), c(0,1), c(0,1))
>   ## two different point patterns
>   X <- runifpointx(5, B)
>   Y <- runifpointx(10, B)
>   nncross(X,Y)
       dist which
1 0.3750805     7
2 0.5795497     7
3 0.3905641     2
4 0.4595534     9
5 0.4328853     8
>   N23 <- nncross(X,Y, k=2:3)
> 
>   ## two patterns with some points in common
>   Z <- runifpointx(20, B)
>   X <- Z[1:15]
>   Y <- Z[10:20]
>   iX <- 1:15
>   iY <- 10:20
>   N <- nncross(X,Y, iX, iY, what="which")
>   N4 <- nncross(X,Y, iX, iY, k=4)
> 
> 
> 
> cleanEx()
> nameEx("nndensity")
> ### * nndensity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nndensity.ppp
> ### Title: Estimate Intensity of Point Pattern Using Nearest Neighbour
> ###   Distances
> ### Aliases: nndensity nndensity.ppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    plot(nndensity(swedishpines))
k= 8 
> 
> 
> 
> cleanEx()
> nameEx("nndist")
> ### * nndist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nndist
> ### Title: Nearest neighbour distances
> ### Aliases: nndist nndist.ppp nndist.default
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(cells)
>    # nearest neighbours
>    d <- nndist(cells)
> 
>    # second nearest neighbours
>    d2 <- nndist(cells, k=2)
> 
>    # first, second and third nearest
>    d1to3 <- nndist(cells, k=1:3)
> 
>    x <- runif(100)
>    y <- runif(100)
>    d <- nndist(x, y)
> 
>    # Stienen diagram
>    plot(cells %mark% nndist(cells), markscale=1)
> 
>    # distance to nearest neighbour of each type
>    nnda <- nndist(ants, by=marks(ants)) 
>    head(nnda)
     Cataglyphis   Messor
[1,]    87.32125 67.77905
[2,]   142.23924 66.03787
[3,]    41.59327 80.06248
[4,]    69.23150 47.16991
[5,]   161.31026 66.03787
[6,]    59.53990 37.33631
>    # For nest number 1, the nearest Cataglyphis nest is 87.32125 units away
> 
>    # minimum distance between each pair of types
>    minnndist(ants, by=marks(ants))
  Cataglyphis   Messor
1     5.00000 12.20656
2    12.20656 18.78829
> 
>    # Use of 'aggregate':
>    # _minimum_ distance between each pair of types
>    aggregate(nnda, by=list(from=marks(ants)), min)
         from Cataglyphis   Messor
1 Cataglyphis     5.00000 12.20656
2      Messor    12.20656 18.78829
>    # _mean_ nearest neighbour distances
>    aggregate(nnda, by=list(from=marks(ants)), mean)
         from Cataglyphis   Messor
1 Cataglyphis    67.47011 36.27306
2      Messor    59.02549 46.12532
>    # The mean distance from a Messor nest to
>    # the nearest Cataglyphis nest is 59.02549 units
> 
> 
> 
> cleanEx()
> nameEx("nndist.lpp")
> ### * nndist.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nndist.lpp
> ### Title: Nearest neighbour distances on a linear network
> ### Aliases: nndist.lpp
> ### Keywords: spatial
> 
> ### ** Examples
> 
>    X <- runiflpp(12, simplenet)
>    nndist(X)
 [1] 0.17293769 0.12643454 0.24849202 0.02852014 0.01246949 0.02852014
 [7] 0.10593261 0.09203659 0.09203659 0.28716521 0.01246949 0.07298492
>    nndist(X, k=2)
 [1] 0.18540719 0.21847113 0.26168571 0.10593261 0.07298492 0.13445275
 [7] 0.13445275 0.21847113 0.12643454 0.32811894 0.08545441 0.08545441
> 
>    marks(X) <- factor(rep(letters[1:3], 4))
>    nndist(X, by=marks(X))
            a          b          c
1  0.28716521 0.17293769 0.25839210
2  0.30970144 0.21847113 0.12643454
3  0.27701216 0.26168571 0.24849202
4  0.10593261 0.53869787 0.02852014
5  0.18540719 0.01246949 0.07298492
6  0.02852014 0.51017774 0.24849202
7  0.10593261 0.64463049 0.13445275
8  0.52817257 0.21847113 0.09203659
9  0.43613599 0.09203659 0.33612102
10 0.28716521 0.32811894 0.41357334
11 0.17293769 0.01246949 0.08545441
12 0.25839210 0.07298492 0.69452809
> 
> 
> 
> cleanEx()
> nameEx("nndist.pp3")
> ### * nndist.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nndist.pp3
> ### Title: Nearest neighbour distances in three dimensions
> ### Aliases: nndist.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- runifpoint3(40)
> 
>    # nearest neighbours
>    d <- nndist(X)
> 
>    # second nearest neighbours
>    d2 <- nndist(X, k=2)
> 
>    # first, second and third nearest
>    d1to3 <- nndist(X, k=1:3)
> 
>    # distance to nearest point in each group
>    marks(X) <- factor(rep(letters[1:4], 10))
>    dby <- nndist(X, by=marks(X))
> 
> 
> 
> cleanEx()
> nameEx("nndist.ppx")
> ### * nndist.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nndist.ppx
> ### Title: Nearest Neighbour Distances in Any Dimensions
> ### Aliases: nndist.ppx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(5),y=runif(5),z=runif(5),w=runif(5))
>    X <- ppx(data=df)
> 
>    # nearest neighbours
>    d <- nndist(X)
> 
>    # second nearest neighbours
>    d2 <- nndist(X, k=2)
> 
>    # first, second and third nearest
>    d1to3 <- nndist(X, k=1:3)
> 
>    # nearest neighbour distances to each group
>    marks(X) <- factor(c("a","a", "b", "b", "b"))
>    nndist(X, by=marks(X))
          a         b
1 0.2504777 0.7287979
2 0.2504777 0.6757870
3 0.6757870 0.7412391
4 0.7287979 0.7613228
5 1.0488960 0.7412391
>    nndist(X, by=marks(X), k=1:2)
   a.dist.1  a.dist.2  b.dist.1  b.dist.2
1 0.2504777       Inf 0.7287979 0.7915545
2 0.2504777       Inf 0.6757870 0.7375656
3 0.6757870 0.7915545 0.7412391 0.7613228
4 0.7287979 0.7375656 0.7613228 1.0619642
5 1.0488960 1.0789390 0.7412391 1.0619642
> 
> 
> 
> cleanEx()
> nameEx("nndist.psp")
> ### * nndist.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nndist.psp
> ### Title: Nearest neighbour distances between line segments
> ### Aliases: nndist.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    L <- psp(runif(10), runif(10), runif(10), runif(10), owin())
>    D <- nndist(L)
>    D <- nndist(L, k=1:3)
> 
> 
> 
> cleanEx()
> nameEx("nnfromvertex")
> ### * nnfromvertex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnfromvertex
> ### Title: Nearest Data Point From Each Vertex in a Network
> ### Aliases: nnfromvertex
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- runiflpp(5, simplenet)
>   nnfromvertex(X)
         dist which
1  0.46664516     1
2  0.38739558     1
3  0.18520291     5
4  0.06599198     1
5  0.02599962     2
6  0.21613855     1
7  0.50346086     4
8  0.06299400     3
9  0.25878302     2
10 0.26664275     4
>   nnfromvertex(X, k=1:3)
       dist.1    dist.2    dist.3 which.1 which.2 which.3
1  0.46664516 0.5200684 0.7763466       1       5       2
2  0.38739558 0.4408188 0.6654410       1       5       4
3  0.18520291 0.3706101 0.6803115       5       1       2
4  0.06599198 0.1194152 0.3756934       1       5       2
5  0.02599962 0.2356861 0.3357011       2       3       1
6  0.21613855 0.2695618 0.4941839       1       5       4
7  0.50346086 0.6804978 0.7339210       4       1       5
8  0.06299400 0.2140182 0.3246797       3       4       2
9  0.25878302 0.4684695 0.5684845       2       3       1
10 0.26664275 0.4436797 0.4971029       4       1       5
> 
> 
> 
> cleanEx()
> nameEx("nnfun")
> ### * nnfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnfun
> ### Title: Nearest Neighbour Index Map as a Function
> ### Aliases: nnfun nnfun.ppp nnfun.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    f <- nnfun(cells)
>    f
Nearest Neighbour Mark function for  point pattern 
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
>    plot(f)
>    f(0.2, 0.3)
[1] 12
> 
>    g <- nnfun(cells, k=2)
>    g(0.2, 0.3)
[1] 13
> 
>    plot(nnfun(amacrine, value="m"))
> 
>    L <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>    h <- nnfun(L)
>    h(0.2, 0.3)
[1] 4
> 
> 
> 
> cleanEx()
> nameEx("nnfun.lpp")
> ### * nnfun.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnfun.lpp
> ### Title: Nearest Neighbour Map on Linear Network
> ### Aliases: nnfun.lpp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- runiflpp(3, simplenet)
>    f <- nnfun(X)
>    f
Nearest-neighbour function for lpp object
Point pattern on linear network
3 points
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
Function returns the index of the neighbour
>    plot(f)
>    plot(nnfun(chicago, value="m"))
> 
> 
> 
> cleanEx()
> nameEx("nnmap")
> ### * nnmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnmap
> ### Title: K-th Nearest Point Map
> ### Aliases: nnmap
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   plot(nnmap(cells, 2, what="which"))
> 
> 
> 
> cleanEx()
> nameEx("nnmark")
> ### * nnmark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnmark
> ### Title: Mark of Nearest Neighbour
> ### Aliases: nnmark
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>   plot(nnmark(ants))
>   v <- nnmark(ants, at="points")
>   v[1:10]
 [1] Messor      Messor      Cataglyphis Messor      Messor      Messor     
 [7] Messor      Messor      Messor      Messor     
Levels: Cataglyphis Messor
>   plot(nnmark(finpines))
>   vf <- nnmark(finpines, at="points")
>   vf[1:5,]
  diameter height
1        1    1.7
2        2    1.8
3        5    4.1
4        3    3.1
5        7    5.4
> 
> 
> 
> cleanEx()
> nameEx("nnorient")
> ### * nnorient
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnorient
> ### Title: Nearest Neighbour Orientation Distribution
> ### Aliases: nnorient
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   rose(nnorient(redwood, adjust=0.6), col="grey")
>   plot(CDF <- nnorient(redwood, cumulative=TRUE))
> 
> 
> 
> cleanEx()
> nameEx("nnwhich")
> ### * nnwhich
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnwhich
> ### Title: Nearest neighbour
> ### Aliases: nnwhich nnwhich.ppp nnwhich.default
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(cells)
>    plot(cells)
>    m <- nnwhich(cells)
>    m2 <- nnwhich(cells, k=2)
> 
>    # plot nearest neighbour links
>    b <- cells[m]
>    arrows(cells$x, cells$y, b$x, b$y, angle=15, length=0.15, col="red")
> 
>    # find points which are the neighbour of their neighbour
>    self <- (m[m] == seq(m))
>    # plot them
>    A <- cells[self]
>    B <- cells[m[self]]
>    plot(cells)
>    segments(A$x, A$y, B$x, B$y)
> 
>    # nearest neighbours of each type
>    head(nnwhich(ants, by=marks(ants)))
     Cataglyphis Messor
[1,]          70      4
[2,]          70      5
[3,]          70      8
[4,]          70      9
[5,]          70      2
[6,]          69      7
> 
> 
> 
> cleanEx()
> nameEx("nnwhich.lpp")
> ### * nnwhich.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnwhich.lpp
> ### Title: Identify Nearest Neighbours on a Linear Network
> ### Aliases: nnwhich.lpp
> ### Keywords: spatial
> 
> ### ** Examples
> 
>    X <- runiflpp(10, simplenet)
>    nnwhich(X)
 [1] 5 9 6 6 1 4 4 9 8 1
>    nnwhich(X, k=2)
 [1] 10  8  2  7 10  7  6  2  2  5
> 
> 
> 
> cleanEx()
> nameEx("nnwhich.pp3")
> ### * nnwhich.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnwhich.pp3
> ### Title: Nearest neighbours in three dimensions
> ### Aliases: nnwhich.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- runifpoint3(30)
>    m <- nnwhich(X)
>    m2 <- nnwhich(X, k=2)
> 
> 
> 
> cleanEx()
> nameEx("nnwhich.ppx")
> ### * nnwhich.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnwhich.ppx
> ### Title: Nearest Neighbours in Any Dimensions
> ### Aliases: nnwhich.ppx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(5),y=runif(5),z=runif(5),w=runif(5))
>    X <- ppx(data=df)
>    m <- nnwhich(X)
>    m2 <- nnwhich(X, k=2)
> 
> 
> 
> cleanEx()
> nameEx("nobjects")
> ### * nobjects
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nobjects
> ### Title: Count Number of Geometrical Objects in a Spatial Dataset
> ### Aliases: nobjects nobjects.ppp nobjects.ppx nobjects.psp nobjects.tess
> ###   nobjects.lintess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    nobjects(redwood)
[1] 62
>    nobjects(edges(letterR))
[1] 34
>    nobjects(dirichlet(cells))
[1] 42
>    nobjects(lineardirichlet(runiflpp(5, simplenet)))
[1] 5
> 
> 
> 
> cleanEx()
> nameEx("npfun")
> ### * npfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: npfun
> ### Title: Dummy Function Returns Number of Points
> ### Aliases: npfun
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   fit0 <- ppm(cells, ~1, nd=10)
>   v <- psst(fit0, npfun)

Processing 142 quadrature points...1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114.116.118.120
.122.124.126.128.130.132.134.136.138.140. 142.
> 
> 
> 
> cleanEx()
> nameEx("npoints")
> ### * npoints
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: npoints
> ### Title: Number of Points in a Point Pattern
> ### Aliases: npoints npoints.ppp npoints.pp3 npoints.ppx
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    data(cells)
>    npoints(cells)
[1] 42
> 
> 
> 
> cleanEx()
> nameEx("nsegments")
> ### * nsegments
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nsegments
> ### Title: Number of Line Segments in a Line Segment Pattern
> ### Aliases: nsegments nsegments.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
> nsegments(copper$Lines)
[1] 146
> nsegments(copper$SouthLines)
[1] 90
> 
> 
> 
> cleanEx()
> nameEx("nvertices")
> ### * nvertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nvertices
> ### Title: Count Number of Vertices
> ### Aliases: nvertices nvertices.owin nvertices.default
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   nvertices(square(2))
[1] 4
>   nvertices(letterR)
[1] 34
> 
> 
> 
> cleanEx()
> nameEx("objsurf")
> ### * objsurf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: objsurf
> ### Title: Objective Function Surface
> ### Aliases: objsurf objsurf.dppm objsurf.kppm objsurf.minconfit
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit <- kppm(redwood ~ 1, "Thomas")
>    os <- objsurf(fit)
Evaluating 1024 function values...Done.
> 
>    if(interactive()) {
+      plot(os)
+      contour(os, add=TRUE)
+      persp(os)
+    }
> 
> 
> 
> cleanEx()
> nameEx("opening")
> ### * opening
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: opening
> ### Title: Morphological Opening
> ### Aliases: opening opening.owin opening.psp opening.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   v <- opening(letterR, 0.3)
>   plot(letterR, type="n", main="opening")
>   plot(v, add=TRUE, col="grey")
>   plot(letterR, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("overlap.owin")
> ### * overlap.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: overlap.owin
> ### Title: Compute Area of Overlap
> ### Aliases: overlap.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   A <- square(1)
>   B <- shift(A, c(0.3, 0.2))
>   overlap.owin(A, B)
[1] 0.56
> 
> 
> 
> cleanEx()
> nameEx("owin")
> ### * owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: owin
> ### Title: Create a Window
> ### Aliases: owin
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   w <- owin()
>   w <- owin(c(0,1), c(0,1))
>   # the unit square
> 
>   w <- owin(c(10,20), c(10,30), unitname=c("foot","feet"))
>   # a rectangle of dimensions 10 x 20 feet
>   # with lower left corner at (10,10)
> 
>   # polygon (diamond shape)
>   w <- owin(poly=list(x=c(0.5,1,0.5,0),y=c(0,1,2,1)))
>   w <- owin(c(0,1), c(0,2), poly=list(x=c(0.5,1,0.5,0),y=c(0,1,2,1)))
> 
>   # polygon with hole
>   ho <- owin(poly=list(list(x=c(0,1,1,0), y=c(0,0,1,1)),
+                        list(x=c(0.6,0.4,0.4,0.6), y=c(0.2,0.2,0.4,0.4))))
>   
>   w <- owin(c(-1,1), c(-1,1), mask=matrix(TRUE, 100,100))
>           # 100 x 100 image, all TRUE
>   X <- raster.x(w)
>   Y <- raster.y(w)
>   wm <- owin(w$xrange, w$yrange, mask=(X^2 + Y^2 <= 1))
>           # discrete approximation to the unit disc
> 
>   ## Not run: 
> ##D   if(FALSE) {
> ##D     plot(c(0,1),c(0,1),type="n")
> ##D     bdry <- locator()
> ##D     # click the vertices of a polygon (anticlockwise)
> ##D   }
> ##D   
> ## End(Not run)
>   ## Don't show: 
>   bdry <- list(x=c(0.1,0.3,0.7,0.4,0.2),
+                y=c(0.1,0.1,0.5,0.7,0.3))
>   
> ## End(Don't show)
>   w <- owin(poly=bdry)
>   ## Not run: plot(w)
>  
>  ## Not run: 
> ##D  im <- as.logical(matrix(scan("myfile"), nrow=128, ncol=128))
> ##D  # read in an arbitrary 128 x 128 digital image from text file
> ##D  rim <- im[, 128:1]
> ##D  # Assuming it was given in row-major order in the file
> ##D  # i.e. scanning left-to-right in rows from top-to-bottom,
> ##D  # the use of matrix() has effectively transposed rows & columns,
> ##D  # so to convert it to our format just reverse the column order.
> ##D  w <- owin(mask=rim)
> ##D  plot(w)
> ##D  # display it to check!
> ##D  
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("owin.object")
> ### * owin.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: owin.object
> ### Title: Class owin
> ### Aliases: owin.object
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
>  w <- owin()
>  w <- owin(c(0,1), c(0,1))
>  # the unit square
>   
>  w <- owin(c(0,1), c(0,2))
>  ## Not run: 
> ##D  if(FALSE) {
> ##D    plot(w)
> ##D    # plots edges of a box 1 unit x 2 units
> ##D    v <- locator() 
> ##D    # click on points in the plot window
> ##D    # to be the vertices of a polygon 
> ##D    # traversed in anticlockwise order 
> ##D    u <- owin(c(0,1), c(0,2), poly=v)
> ##D    plot(u)
> ##D    # plots polygonal boundary using polygon()
> ##D    plot(as.mask(u, eps=0.02))
> ##D    # plots discrete pixel approximation to polygon
> ##D  }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("padimage")
> ### * padimage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: padimage
> ### Title: Pad the Border of a Pixel Image
> ### Aliases: padimage
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  Z <- setcov(owin())
>  plot(padimage(Z, 1, 10))
> 
> 
> 
> cleanEx()
> nameEx("pairdist.default")
> ### * pairdist.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairdist.default
> ### Title: Pairwise distances
> ### Aliases: pairdist.default
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    x <- runif(100)
>    y <- runif(100)
>    d <- pairdist(x, y)
>    d <- pairdist(cbind(x,y))
>    d <- pairdist(x, y, period=c(1,1))
>    d <- pairdist(x, y, squared=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("pairdist.lpp")
> ### * pairdist.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairdist.lpp
> ### Title: Pairwise shortest-path distances between points on a linear
> ###   network
> ### Aliases: pairdist.lpp
> ### Keywords: spatial
> 
> ### ** Examples
> 
>    X <- runiflpp(12, simplenet)
>    d <- pairdist(X)
>    d[1:3, 1:3]
          [,1]      [,2]      [,3]
[1,] 0.0000000 0.3097014 0.5713872
[2,] 0.3097014 0.0000000 0.2616857
[3,] 0.5713872 0.2616857 0.0000000
> 
> 
> 
> cleanEx()
> nameEx("pairdist.pp3")
> ### * pairdist.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairdist.pp3
> ### Title: Pairwise distances in Three Dimensions
> ### Aliases: pairdist.pp3
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    X <- runifpoint3(20)
>    d <- pairdist(X)
>    d <- pairdist(X, periodic=TRUE)
>    d <- pairdist(X, squared=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("pairdist.ppp")
> ### * pairdist.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairdist.ppp
> ### Title: Pairwise distances
> ### Aliases: pairdist.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(cells)
>    d <- pairdist(cells)
>    d <- pairdist(cells, periodic=TRUE)
>    d <- pairdist(cells, squared=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("pairdist.ppx")
> ### * pairdist.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairdist.ppx
> ### Title: Pairwise Distances in Any Dimensions
> ### Aliases: pairdist.ppx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(4),y=runif(4),z=runif(4),w=runif(4))
>    X <- ppx(data=df)
>    pairdist(X)
          1         2         3         4
1 0.0000000 0.9541432 0.9123628 0.9297855
2 0.9541432 0.0000000 0.4604547 0.6082040
3 0.9123628 0.4604547 0.0000000 0.5176638
4 0.9297855 0.6082040 0.5176638 0.0000000
> 
> 
> 
> cleanEx()
> nameEx("pairdist.psp")
> ### * pairdist.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairdist.psp
> ### Title: Pairwise distances between line segments
> ### Aliases: pairdist.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    L <- psp(runif(10), runif(10), runif(10), runif(10), owin())
>    D <- pairdist(L)
>    S <- pairdist(L, type="sep")
> 
> 
> 
> cleanEx()
> nameEx("pairorient")
> ### * pairorient
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairorient
> ### Title: Point Pair Orientation Distribution
> ### Aliases: pairorient
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   rose(pairorient(redwood, 0.05, 0.15, sigma=8), col="grey")
>   plot(CDF <- pairorient(redwood, 0.05, 0.15, cumulative=TRUE))
>   plot(f <- deriv(CDF, spar=0.6, Dperiodic=TRUE))
> 
> 
> 
> cleanEx()
> nameEx("pairs.im")
> ### * pairs.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairs.im
> ### Title: Scatterplot Matrix for Pixel Images
> ### Aliases: pairs.im
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   X <- density(rpoispp(30))
>   Y <- density(rpoispp(40))
>   Z <- density(rpoispp(30))
>   p <- pairs(X,Y,Z)
>   p
Object of class plotpairsim
contains pixel data for 'X', 'Y' and 'Z' 
>   plot(p)
> 
> 
> 
> cleanEx()
> nameEx("pairs.linim")
> ### * pairs.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairs.linim
> ### Title: Scatterplot Matrix for Pixel Images on a Linear Network
> ### Aliases: pairs.linim
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   fit <- lppm(chicago ~ marks * (x+y))
>   lam <- predict(fit)
>   do.call(pairs, lam)
> 
> 
> 
> cleanEx()
> nameEx("panel.contour")
> ### * panel.contour
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.contour
> ### Title: Panel Plots using Colour Image or Contour Lines
> ### Aliases: panel.contour panel.image panel.histogram
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   pairs(bei.extra,
+         panel      = panel.contour,
+         diag.panel = panel.histogram)
>   with(bei.extra,
+         pairs(grad, elev, 
+               panel      = panel.image,
+               diag.panel = panel.histogram))
>   pairs(marks(finpines), panel=panel.contour, diag.panel=panel.histogram)
> 
> 
> 
> cleanEx()
> nameEx("parameters")
> ### * parameters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parameters
> ### Title: Extract Model Parameters in Understandable Form
> ### Aliases: parameters parameters.dppm parameters.kppm parameters.ppm
> ###   parameters.profilepl parameters.interact parameters.fii
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   parameters(Strauss(0.1))
$r
[1] 0.1

>   fit1 <- ppm(cells ~ x, Strauss(0.1))
>   parameters(fit1)
$trend
(Intercept)           x 
  7.1860741  -0.2810884 

$r
[1] 0.1

$gamma
[1] 0.004926111

>   fit2 <- kppm(redwood ~ x, "Thomas")
>   parameters(fit2)
$trend
(Intercept)           x 
  3.9745791   0.2976994 

$kappa
[1] 22.92087

$scale
[1] 0.04635311

$mu
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [-1, 0] units

> 
> 
> 
> cleanEx()
> nameEx("parres")
> ### * parres
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parres
> ### Title: Partial Residuals for Point Process Model
> ### Aliases: parres
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <-  rpoispp(function(x,y){exp(3+x+2*x^2)})
>   model <- ppm(X ~x+y)
>   tra <- parres(model, "x")
>   plot(tra)
Warning in sprintf(legdesc, ylab) : argument not used by format
>   tra
Transformation diagnostic (class parres)
for the canonical covariate 'x' in the fitted model  ppm.formula(X ~ x + y) 
Call: parres(model, "x") 
Actual smoothing bandwidth sigma = 0.093019 
Algorithm: effect + smooth(residual)

Function value object (class 'fv')
for the function x -> h(x)
Warning in sprintf(desc, ylab) : argument not used by format
........................................................................
     Math.label Description                                             
x    x          covariate 'x'                                           
h    h(x)       Smoothed partial residual                               
varh var(x)     Variance                                                
hi   hi(x)      Upper limit of pointwise 5% significance band (integral)
lo   lo(x)      Lower limit of pointwise 5% significance band (integral)
hiX  hiX(x)     Upper limit of pointwise 5% significance band (sum)     
loX  loX(x)     Lower limit of pointwise 5% significance band (sum)     
fit  fit(x)     Parametric fitted effect of 'x'                         
........................................................................
Default plot formula:  .~x
where "." stands for 'h', 'hi', 'lo', 'fit'
Columns 'hi' and 'lo' will be plotted as shading (by default)
Recommended range of argument x: [0, 1]
Available range of argument x: [0, 1]
>   plot(parres(model, "x", subregion=square(0.5)))
Warning in sprintf(legdesc, ylab) : argument not used by format
>   model2 <- ppm(X ~x+I(x^2)+y)
>   plot(parres(model2, "x"))
Warning in sprintf(legdesc, ylab) : argument not used by format
>   Z <- setcov(owin())
>   plot(parres(model2, Z))
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
>   #' when the model involves only one covariate
>   modelb <- ppm(bei ~ elev + I(elev^2), data=bei.extra)
>   plot(parres(modelb))
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("pcf")
> ### * pcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcf
> ### Title: Pair Correlation Function
> ### Aliases: pcf
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   # ppp object
>   X <- simdat
>   ## Don't show: 
>     X <- X[seq(1,npoints(X), by=4)]
>   
> ## End(Don't show)
>   p <- pcf(X)
>   plot(p)
> 
>   # fv object
>   K <- Kest(X)
>   p2 <- pcf(K, spar=0.8, method="b")
>   plot(p2)
> 
>   # multitype pattern; fasp object
>   amaK <- alltypes(amacrine, "K")
>   amap <- pcf(amaK, spar=1, method="b")
>   plot(amap)
> 
> 
> 
> cleanEx()
> nameEx("pcf.fasp")
> ### * pcf.fasp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcf.fasp
> ### Title: Pair Correlation Function obtained from array of K functions
> ### Aliases: pcf.fasp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   # multitype point pattern
>   KK <- alltypes(amacrine, "K")
>   p <- pcf.fasp(KK, spar=0.5, method="b")
>   plot(p)
>   # strong inhibition between points of the same type
> 
> 
> 
> cleanEx()
> nameEx("pcf.fv")
> ### * pcf.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcf.fv
> ### Title: Pair Correlation Function obtained from K Function
> ### Aliases: pcf.fv
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   # univariate point pattern
>   X <- simdat
>   ## Don't show: 
>     X <- X[seq(1,npoints(X), by=4)]
>   
> ## End(Don't show)
>   K <- Kest(X)
>   p <- pcf.fv(K, spar=0.5, method="b")
>   plot(p, main="pair correlation function for simdat")
>   # indicates inhibition at distances r < 0.3
> 
> 
> 
> cleanEx()
> nameEx("pcf.ppp")
> ### * pcf.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcf.ppp
> ### Title: Pair Correlation Function of Point Pattern
> ### Aliases: pcf.ppp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- simdat
>   ## Don't show: 
>     X <- X[seq(1,npoints(X), by=4)]
>   
> ## End(Don't show)
>   p <- pcf(X)
>   plot(p, main="pair correlation function for X")
>   # indicates inhibition at distances r < 0.3
> 
>   pd <- pcf(X, divisor="d")
> 
>   # compare estimates
>   plot(p, cbind(iso, theo) ~ r, col=c("blue", "red"),
+          ylim.covers=0, main="", lwd=c(2,1), lty=c(1,3), legend=FALSE)
>   plot(pd, iso ~ r, col="green", lwd=2, add=TRUE)
>   legend("center", col=c("blue", "green"), lty=1, lwd=2,
+          legend=c("divisor=r","divisor=d"))
> 
>   # calculate approximate variance and show POINTWISE confidence bands
>   pv <- pcf(X, var.approx=TRUE)
>   plot(pv, cbind(iso, iso+2*sqrt(v), iso-2*sqrt(v)) ~ r)
> 
> 
> 
> cleanEx()
> nameEx("pcf3est")
> ### * pcf3est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcf3est
> ### Title: Pair Correlation Function of a Three-Dimensional Point Pattern
> ### Aliases: pcf3est
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   X <- rpoispp3(250)
>   Z <- pcf3est(X)
>   Zbias <- pcf3est(X, biascorrect=FALSE)
>   if(interactive()) {
+     opa <- par(mfrow=c(1,2))
+     plot(Z,     ylim.covers=c(0, 1.2))
+     plot(Zbias, ylim.covers=c(0, 1.2))
+     par(opa)
+   }
>   attr(Z, "delta")
[1] 0.04183787
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("pcfcross")
> ### * pcfcross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcfcross
> ### Title: Multitype pair correlation function (cross-type)
> ### Aliases: pcfcross
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  data(amacrine)
>  p <- pcfcross(amacrine, "off", "on")
>  p <- pcfcross(amacrine, "off", "on", stoyan=0.1)
>  plot(p)
> 
> 
> 
> cleanEx()
> nameEx("pcfcross.inhom")
> ### * pcfcross.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcfcross.inhom
> ### Title: Inhomogeneous Multitype Pair Correlation Function (Cross-Type)
> ### Aliases: pcfcross.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(amacrine)
>   plot(pcfcross.inhom(amacrine, "on", "off", stoyan=0.1),
+        legendpos="bottom")
> 
> 
> 
> cleanEx()
> nameEx("pcfdot")
> ### * pcfdot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcfdot
> ### Title: Multitype pair correlation function (i-to-any)
> ### Aliases: pcfdot
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>  data(amacrine)
>  p <- pcfdot(amacrine, "on")
>  p <- pcfdot(amacrine, "on", stoyan=0.1)
>  plot(p)
> 
> 
> 
> cleanEx()
> nameEx("pcfdot.inhom")
> ### * pcfdot.inhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcfdot.inhom
> ### Title: Inhomogeneous Multitype Pair Correlation Function
> ###   (Type-i-To-Any-Type)
> ### Aliases: pcfdot.inhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(amacrine)
>   plot(pcfdot.inhom(amacrine, "on", stoyan=0.1), legendpos="bottom")
> 
> 
> 
> cleanEx()
> nameEx("pcfinhom")
> ### * pcfinhom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcfinhom
> ### Title: Inhomogeneous Pair Correlation Function
> ### Aliases: pcfinhom
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   data(residualspaper)
>   X <- residualspaper$Fig4b
>   plot(pcfinhom(X, stoyan=0.2, sigma=0.1))
>   fit <- ppm(X, ~polynom(x,y,2))
>   plot(pcfinhom(X, lambda=fit, normpower=2))
Warning: The behaviour of pcfinhom when lambda is a ppm object has changed (in spatstat 1.45-0 and later). See help(pcfinhom)
> 
> 
> 
> cleanEx()
> nameEx("pcfmulti")
> ### * pcfmulti
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcfmulti
> ### Title: Marked pair correlation function
> ### Aliases: pcfmulti
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   adult <- (marks(longleaf) >= 30)
>   juvenile <- !adult
>   p <- pcfmulti(longleaf, adult, juvenile)
> 
> 
> 
> cleanEx()
> nameEx("perimeter")
> ### * perimeter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: perimeter
> ### Title: Perimeter Length of Window
> ### Aliases: perimeter
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   perimeter(square(3))
[1] 12
>   data(letterR)
>   perimeter(letterR)
[1] 12.48771
>   if(interactive()) print(perimeter(as.mask(letterR)))
> 
> 
> 
> cleanEx()
> nameEx("periodify")
> ### * periodify
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: periodify
> ### Title: Make Periodic Copies of a Spatial Pattern
> ### Aliases: periodify periodify.owin periodify.ppp periodify.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(cells)
>   plot(periodify(cells))
>   a <- lapply(periodify(Window(cells), combine=FALSE),
+         plot, add=TRUE,lty=2)
> 
> 
> 
> 
> cleanEx()
> nameEx("persp.im")
> ### * persp.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: persp.im
> ### Title: Perspective Plot of Pixel Image
> ### Aliases: persp.im
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    # an image
>    Z <- setcov(owin())
>    persp(Z, colmap=terrain.colors(128))
>    co <- colourmap(range=c(0,1), col=rainbow(128))
>    persp(Z, colmap=co, axes=FALSE, shade=0.3)
> 
>    ## Terrain elevation
>    persp(bei.extra$elev, colmap=terrain.colors(128),
+          apron=TRUE, theta=-30, phi=20,
+          zlab="Elevation", main="", ticktype="detailed",
+          expand=6)
> 
> 
> 
> cleanEx()
> nameEx("perspPoints")
> ### * perspPoints
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: perspPoints
> ### Title: Draw Points or Lines on a Surface Viewed in Perspective
> ### Aliases: perspPoints perspSegments perspLines perspContour
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   M <- persp(bei.extra$elev, colmap=terrain.colors(128),
+              apron=TRUE, theta=-30, phi=20,
+              zlab="Elevation", main="", 
+              expand=6, visible=TRUE, shade=0.3)
> 
>   perspContour(bei.extra$elev, M=M, col="pink", nlevels=12)
>   perspPoints(bei, Z=bei.extra$elev, M=M, pch=16, cex=0.3, col="chartreuse")
> 
> 
> 
> cleanEx()
> nameEx("pixelcentres")
> ### * pixelcentres
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pixelcentres
> ### Title: Extract Pixel Centres as Point Pattern
> ### Aliases: pixelcentres
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   pixelcentres(letterR, dimyx=5)
Planar point pattern: 19 points
window: rectangle = [2.017, 3.93] x [0.645, 3.278] units
> 
> 
> 
> cleanEx()
> nameEx("pixellate.owin")
> ### * pixellate.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pixellate.owin
> ### Title: Convert Window to Pixel Image
> ### Aliases: pixellate.owin
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    data(letterR)
>    plot(pixellate(letterR, dimyx=15))
>    W <- grow.rectangle(as.rectangle(letterR), 0.2)
>    plot(pixellate(letterR, W, dimyx=15))
> 
> 
> 
> cleanEx()
> nameEx("pixellate.ppp")
> ### * pixellate.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pixellate.ppp
> ### Title: Convert Point Pattern to Pixel Image
> ### Aliases: pixellate.ppp as.im.ppp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   plot(pixellate(humberside))
>   plot(pixellate(humberside, fractional=TRUE))
> 
> 
> 
> cleanEx()
> nameEx("pixellate.psp")
> ### * pixellate.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pixellate.psp
> ### Title: Convert Line Segment Pattern to Pixel Image
> ### Aliases: pixellate.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- psp(runif(10),runif(10), runif(10), runif(10), window=owin())
>   plot(pixellate(X))
>   plot(X, add=TRUE)
>   sum(lengths_psp(X))
[1] 5.560367
>   sum(pixellate(X))
[1] 5.560367
>   plot(pixellate(X, what="n"))
> 
> 
> 
> cleanEx()
> nameEx("pixelquad")
> ### * pixelquad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pixelquad
> ### Title: Quadrature Scheme Based on Pixel Grid
> ### Aliases: pixelquad
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   W <- owin(c(0,1),c(0,1))
>   X <- runifpoint(42, W)
>   W <- as.mask(W,dimyx=128)
>   pixelquad(X,W)
Quadrature scheme (Berman-Turner)
42 data points, 16384 dummy points
     (provided manually)
     Total weight 1
> 
> 
> 
> cleanEx()
> nameEx("plot.anylist")
> ### * plot.anylist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.anylist
> ### Title: Plot a List of Things
> ### Aliases: plot.anylist
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>  trichotomy <- list(regular=cells,
+                     random=japanesepines,
+                     clustered=redwood)
>  K <- lapply(trichotomy, Kest)
>  K <- as.anylist(K)
>  plot(K, main="")
> 
> # list of 3D point patterns
>  ape1 <- osteo[osteo$shortid==4, "pts", drop=TRUE]
>  class(ape1)
[1] "anylist" "listof"  "list"   
>  plot(ape1, main.panel="", mar.panel=0.1, hsep=0.7, vsep=1,
+       cex=1.5, pch=21, bg='white')
> 
> 
> 
> cleanEx()
> nameEx("plot.bermantest")
> ### * plot.bermantest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.bermantest
> ### Title: Plot Result of Berman Test
> ### Aliases: plot.bermantest
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    # synthetic data: nonuniform Poisson process
>    X <- rpoispp(function(x,y) { 100 * exp(-x) }, win=square(1))
> 
>    # fit uniform Poisson process
>    fit0 <- ppm(X, ~1)
> 
>    # test covariate = x coordinate
>    xcoord <- function(x,y) { x }
> 
>    # test wrong model
>    k <- berman.test(fit0, xcoord, "Z1")
>    
>    # plot result of test
>    plot(k, col="red", col0="green")
> 
>    # Z2 test
>    k2 <- berman.test(fit0, xcoord, "Z2")
>    plot(k2, col="red", col0="green")
> 
> 
> 
> cleanEx()
> nameEx("plot.cdftest")
> ### * plot.cdftest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.cdftest
> ### Title: Plot a Spatial Distribution Test
> ### Aliases: plot.cdftest
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    op <- options(useFancyQuotes=FALSE)
> 
>    # synthetic data: nonuniform Poisson process
>    X <- rpoispp(function(x,y) { 100 * exp(x) }, win=square(1))
> 
>    # fit uniform Poisson process
>    fit0 <- ppm(X, ~1)
> 
>    # test covariate = x coordinate
>    xcoord <- function(x,y) { x }
> 
>    # test wrong model
>    k <- cdf.test(fit0, xcoord)
> 
>    # plot result of test
>    plot(k, lwd0=3)
> 
>    plot(k, style="PP")
> 
>    plot(k, style="QQ")
> 
>    options(op)
> 
> 
> 
> cleanEx()
> nameEx("plot.colourmap")
> ### * plot.colourmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.colourmap
> ### Title: Plot a Colour Map
> ### Aliases: plot.colourmap
> ### Keywords: spatial color hplot
> 
> ### ** Examples
> 
>   co <- colourmap(rainbow(100), breaks=seq(-1,1,length=101))
>   plot(co)
>   plot(co, col.ticks="pink")
>   ca <- colourmap(rainbow(8), inputs=letters[1:8])
>   plot(ca, vertical=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("plot.dppm")
> ### * plot.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.dppm
> ### Title: Plot a fitted determinantal point process
> ### Aliases: plot.dppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- dppm(swedishpines ~ x + y, dppGauss())
>   plot(fit)
> 
> 
> 
> cleanEx()
> nameEx("plot.envelope")
> ### * plot.envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.envelope
> ### Title: Plot a Simulation Envelope
> ### Aliases: plot.envelope
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    data(cells)
>    E <- envelope(cells, Kest, nsim=19)
Generating 19 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,  19.

Done.
>    plot(E)
>    plot(E, sqrt(./pi) ~ r)
> 
> 
> 
> cleanEx()
> nameEx("plot.fasp")
> ### * plot.fasp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.fasp
> ### Title: Plot a Function Array
> ### Aliases: plot.fasp
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    ## Not run: 
> ##D    # Bramble Canes data.
> ##D    data(bramblecanes)
> ##D 
> ##D    X.G <- alltypes(bramblecanes,"G",dataname="Bramblecanes",verb=TRUE)
> ##D    plot(X.G)
> ##D    plot(X.G,subset="r<=0.2")
> ##D    plot(X.G,formule=asin(sqrt(cbind(km,theo))) ~ asin(sqrt(theo)))
> ##D    plot(X.G,fo=cbind(km,theo) - theo~r,subset="r<=0.2")
> ##D 
> ##D    # Simulated data.
> ##D    pp <- runifpoint(350, owin(c(0,1),c(0,1)))
> ##D    pp <- pp %mark% factor(c(rep(1,50),rep(2,100),rep(3,200)))
> ##D    X.K <- alltypes(pp,"K",verb=TRUE,dataname="Fake Data")
> ##D    plot(X.K,fo=cbind(border,theo)~theo,subset="theo<=0.75")
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot.fv")
> ### * plot.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.fv
> ### Title: Plot Function Values
> ### Aliases: plot.fv
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    K <- Kest(cells)
>    # K is an object of class "fv"
> 
>    plot(K, iso ~ r)                # plots iso against r
> 
>    plot(K, sqrt(iso/pi) ~ r)   # plots sqrt(iso/r)  against r
> 
>    plot(K, cbind(iso,theo) ~ r)   # plots iso against r  AND theo against r
> 
>    plot(K, .  ~ r)            # plots all available estimates of K against r
> 
>    plot(K, sqrt(./pi) ~ r)   # plots all estimates of L-function
>                              # L(r) = sqrt(K(r)/pi)
> 
>    plot(K, cbind(iso,theo) ~ r, col=c(2,3))
>                                    # plots iso against r  in colour 2
>                                    # and theo against r in colour 3
> 
>    plot(K, iso ~ r, subset=quote(r < 0.2))
>                                    # plots iso against r for r < 10
> 
>    # Can't remember the names of the columns? No problem..
>    plot(K, sqrt(./pi) ~ .x)
> 
>    # making a legend by hand
>    v <- plot(K, . ~ r, legend=FALSE)
>    legend("topleft", legend=v$meaning, lty=v$lty, col=v$col)
> 
>    # significance bands
>    KE <- envelope(cells, Kest, nsim=19)
Generating 19 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,  19.

Done.
>    plot(KE, shade=c("hi", "lo"))
> 
>    # how to display two functions on a common scale
>    Kr <- Kest(redwood)
>    a <- plot(K, limitsonly=TRUE)
>    b <- plot(Kr, limitsonly=TRUE)
>    xlim <- range(a$xlim, b$xlim)
>    ylim <- range(a$ylim, b$ylim)
>    opa <- par(mfrow=c(1,2))
>    plot(K, xlim=xlim, ylim=ylim)
>    plot(Kr, xlim=xlim, ylim=ylim)
>    par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("plot.hyperframe")
> ### * plot.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.hyperframe
> ### Title: Plot Entries in a Hyperframe
> ### Aliases: plot.hyperframe
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    H <- hyperframe(id=1:10)
>    H$X <- with(H, rpoispp(100))
>    H$D <- with(H, distmap(X))
>    # points only
>    plot(H[,"X"])
>    plot(H, quote(plot(X, main=id)))
>    # points superimposed on images
>    plot(H, quote({plot(D, main=id); plot(X, add=TRUE)}))
> 
> 
> 
> cleanEx()
> nameEx("plot.im")
> ### * plot.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.im
> ### Title: Plot a Pixel Image
> ### Aliases: plot.im image.im
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    # an image
>    Z <- setcov(owin())
>    plot(Z)
>    plot(Z, ribside="bottom")
>    # stretchable colour map
>    plot(Z, col=rainbow)
>    plot(Z, col=terrain.colors(128), axes=FALSE)
>    # fixed colour map
>    tc <- colourmap(rainbow(128), breaks=seq(-1,2,length=129))
>    plot(Z, col=tc)
>    # colour map function, with argument 'range'
>    plot(Z, col=beachcolours, colargs=list(sealevel=0.5))
>    # tweaking the plot
>    plot(Z, main="La vie en bleu", col.main="blue", cex.main=1.5,
+         box=FALSE,
+         ribargs=list(col.axis="blue", col.ticks="blue", cex.axis=0.75))
>    # add axes and axis labels
>    plot(Z, axes=TRUE, ann=TRUE, xlab="Easting", ylab="Northing")
>    # log scale
>    V <- eval.im(exp(exp(Z+2))/1e4)
>    plot(V, log=TRUE, main="Log scale")
>    # it's complex
>    Y <- exp(Z + V * 1i)
>    plot(Y)
> 
> 
> 
> cleanEx()
> nameEx("plot.imlist")
> ### * plot.imlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.imlist
> ### Title: Plot a List of Images
> ### Aliases: plot.imlist image.imlist image.listof
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>  D <- density(split(amacrine))
>  image(D, equal.ribbon=TRUE, main="", col.ticks="red", col.axis="red")
> 
> 
> 
> cleanEx()
> nameEx("plot.influence.ppm")
> ### * plot.influence.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.influence.ppm
> ### Title: Plot Influence Measure
> ### Aliases: plot.influence.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    plot(influence(fit))
> 
> 
> 
> cleanEx()
> nameEx("plot.kppm")
> ### * plot.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.kppm
> ### Title: Plot a fitted cluster point process
> ### Aliases: plot.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   data(redwood)
>   fit <- kppm(redwood~1, "Thomas")
>   plot(fit)
> 
> 
> 
> cleanEx()
> nameEx("plot.laslett")
> ### * plot.laslett
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.laslett
> ### Title: Plot Laslett Transform
> ### Aliases: plot.laslett
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   b <- laslett(heather$coarse, plotit=FALSE)
>   plot(b, main="Heather Data")
> 
> 
> 
> cleanEx()
> nameEx("plot.layered")
> ### * plot.layered
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.layered
> ### Title: Layered Plot
> ### Aliases: plot.layered
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    data(cells)
>    D <- distmap(cells)
>    L <- layered(D, cells)
>    plot(L)
>    plot(L, which = 2)
>    plot(L, plotargs=list(list(ribbon=FALSE), list(pch=3, cols="white")))
>    # plot a subregion
>    plot(L[, square(0.5)])
> 
> 
> 
> cleanEx()
> nameEx("plot.leverage.ppm")
> ### * plot.leverage.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.leverage.ppm
> ### Title: Plot Leverage Function
> ### Aliases: plot.leverage.ppm contour.leverage.ppm persp.leverage.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X ~x+y)
>    lef <- leverage(fit)
>    plot(lef)
>    contour(lef)
>    persp(lef)
> 
> 
> 
> cleanEx()
> nameEx("plot.linim")
> ### * plot.linim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.linim
> ### Title: Plot Pixel Image on Linear Network
> ### Aliases: plot.linim
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   X <- linfun(function(x,y,seg,tp){y^2+x}, simplenet)
>   X <- as.linim(X)
>   
>   plot(X, main="Colour represents function value")
>   plot(X, fatten=0.02, main="fattened")
> 
>   plot(X, style="width", main="Width proportional to function value")
> 
>   # signed values
>   f <- linfun(function(x,y,seg,tp){y-x}, simplenet)
>   plot(f, style="w", main="Negative values in red")
> 
>   plot(f, style="w", negative.args=list(density=10),
+        main="Negative values are hatched")
> 
> 
> 
> 
> cleanEx()
> nameEx("plot.linnet")
> ### * plot.linnet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.linnet
> ### Title: Plot a linear network
> ### Aliases: plot.linnet
> ### Keywords: spatial
> 
> ### ** Examples
> 
>    plot(simplenet)
> 
> 
> 
> cleanEx()
> nameEx("plot.lintess")
> ### * plot.lintess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.lintess
> ### Title: Plot a Tessellation on a Linear Network
> ### Aliases: plot.lintess
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    X <- runiflpp(7, simplenet)
>    Z <- divide.linnet(X)
>    plot(Z, main="tessellation on network")
>    points(as.ppp(X))
>    plot(Z, main="tessellation on network",
+            values=1:nobjects(Z), style="w")
> 
> 
> 
> cleanEx()
> nameEx("plot.listof")
> ### * plot.listof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.listof
> ### Title: Plot a List of Things
> ### Aliases: plot.listof
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
> # Intensity estimate of multitype point pattern
>  plot(D <- density(split(amacrine)))
>  plot(D, main="", equal.ribbon=TRUE,
+       panel.end=function(i,y,...){contour(y, ...)})
> 
> # list of 3D point patterns
>  ape1 <- osteo[osteo$shortid==4, "pts", drop=TRUE]
>  class(ape1)
[1] "anylist" "listof"  "list"   
>  plot(ape1, main.panel="", mar.panel=0.1, hsep=0.7, vsep=1,
+       cex=1.5, pch=21, bg='white')
> 
> 
> 
> cleanEx()
> nameEx("plot.lpp")
> ### * plot.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.lpp
> ### Title: Plot Point Pattern on Linear Network
> ### Aliases: plot.lpp
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   plot(chicago, cols=1:6)
> 
> 
> 
> cleanEx()
> nameEx("plot.lppm")
> ### * plot.lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.lppm
> ### Title: Plot a Fitted Point Process Model on a Linear Network
> ### Aliases: plot.lppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <- runiflpp(10, simplenet)  
>   fit <- lppm(X ~x)
>   plot(fit)
>   plot(fit, style="width")
> 
> 
> 
> cleanEx()
> nameEx("plot.mppm")
> ### * plot.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.mppm
> ### Title: plot a Fitted Multiple Point Process Model
> ### Aliases: plot.mppm
> ### Keywords: spatial hplot models
> 
> ### ** Examples
> 
>   # Synthetic data from known model
>   n <- 9
>   H <- hyperframe(V=1:n,
+                   U=runif(n, min=-1, max=1))
>   H$Z <- setcov(square(1))
>   H$U <- with(H, as.im(U, as.rectangle(Z)))
>   H$Y <- with(H, rpoispp(eval.im(exp(2+3*Z))))
> 
>   fit <- mppm(Y ~Z + U + V, data=H)
> 
>   plot(fit)
> 
> 
> 
> cleanEx()
> nameEx("plot.msr")
> ### * plot.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.msr
> ### Title: Plot a Signed or Vector-Valued Measure
> ### Aliases: plot.msr
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    rp <- residuals(fit, type="pearson")
>    rs <- residuals(fit, type="score")
> 
>    plot(rp)
>    plot(rs)
>    plot(rs, how="contour")
> 
> 
> 
> cleanEx()
> nameEx("plot.onearrow")
> ### * plot.onearrow
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.onearrow
> ### Title: Plot an Arrow
> ### Aliases: plot.onearrow
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   oa <- onearrow(cells[c(1, 42)])
>   oa
Single arrow from (0.35, 0.025) to (0.625, 0.95)
>   plot(oa)
>   plot(oa, zap=TRUE, do.points=TRUE, col.head="pink", col="red")
> 
> 
> 
> cleanEx()
> nameEx("plot.owin")
> ### * plot.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.owin
> ### Title: Plot a Spatial Window
> ### Aliases: plot.owin
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   # rectangular window
>    plot(Window(nztrees))
>    abline(v=148, lty=2)
> 
>   # polygonal window
>   w <- Window(demopat)
>   plot(w)
>   plot(w, col="red", border="green", lwd=2)
>   plot(w, hatch=TRUE, lwd=2)
> 
>   # binary mask
>   we <- as.mask(w)
>   plot(we)
>   op <- spatstat.options(par.binary=list(col=grey(c(0.5,1))))
>   plot(we)
>   spatstat.options(op)
> 
>   ## axis annotation
>   plot(letterR, axes=TRUE, ann=TRUE, xlab="Easting", ylab="Northing")
>   plot(letterR,            ann=TRUE, xlab="Declination", ylab="Right Ascension")
> 
> 
> 
> cleanEx()
> nameEx("plot.plotppm")
> ### * plot.plotppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.plotppm
> ### Title: Plot a plotppm Object Created by plot.ppm
> ### Aliases: plot.plotppm
> ### Keywords: spatial hplot models
> 
> ### ** Examples
> 
>  ## Not run: 
> ##D  m <- ppm(cells ~ 1, Strauss(0.05))
> ##D  mpic <- plot(m)
> ##D  # Perspective plot only, with altered parameters:
> ##D   plot(mpic,how="persp", theta=-30,phi=40,d=4)
> ##D  # All plots, with altered parameters for perspective plot:
> ##D  op <- spatstat.options(par.persp=list(theta=-30,phi=40,d=4))
> ##D  plot(mpic)
> ##D  # Revert
> ##D  spatstat.options(op)
> ##D  
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot.pp3")
> ### * plot.pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.pp3
> ### Title: Plot a Three-Dimensional Point Pattern
> ### Aliases: plot.pp3
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   X <- osteo$pts[[1]]
>   plot(X, main="Osteocyte lacunae, animal 1, brick 1",
+        cex=1.5, pch=16)
>   plot(X, type="h", main="", box.back=list(lty=3))
> 
> 
> 
> cleanEx()
> nameEx("plot.ppm")
> ### * plot.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.ppm
> ### Title: plot a Fitted Point Process Model
> ### Aliases: plot.ppm
> ### Keywords: spatial hplot models
> 
> ### ** Examples
> 
>  m <- ppm(cells ~1, Strauss(0.05))
>  pm <- plot(m) # The object ``pm'' will be plotted as well as saved
>                # for future plotting.
>  pm
Object of class 'plotppm' 
Computed for an unmarked point process
Contains the following components:

$cif:	Fitted conditional intensity.
A list containing 1 image
real-valued pixel image
40 x 40 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("plot.ppp")
> ### * plot.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.ppp
> ### Title: plot a Spatial Point Pattern
> ### Aliases: plot.ppp
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    plot(cells)
> 
>    plot(cells, pch=16)
> 
>    # make the plotting symbols larger (for publication at reduced scale)
>    plot(cells, cex=2)
> 
>    # set it in spatstat.options
>    oldopt <- spatstat.options(par.points=list(cex=2))
>    plot(cells)
>    spatstat.options(oldopt)
> 
>    # multitype 
>    plot(lansing)
> 
>    # marked by a real number
>    plot(longleaf)
> 
>    # just plot the points
>    plot(longleaf, use.marks=FALSE)
>    plot(unmark(longleaf)) # equivalent
> 
>    # point pattern with multiple marks
>    plot(finpines)
>    plot(finpines, which.marks="height")
> 
>    # controlling COLOURS of points
>    plot(cells, cols="blue")
>    plot(lansing, cols=c("black", "yellow", "green", 
+                         "blue","red","pink"))
>    plot(longleaf, fg="blue")
> 
>    # make window purple
>    plot(lansing, border="purple")
>    # make everything purple
>    plot(lansing, border="purple", cols="purple", col.main="purple",
+                  leg.args=list(col.axis="purple"))
>  
>    # controlling PLOT CHARACTERS for multitype pattern
>    plot(lansing, chars = 11:16)
>    plot(lansing, chars = c("o","h","m",".","o","o"))
> 
>    ## multitype pattern mapped to symbols
>    plot(amacrine, shape=c("circles", "squares"), size=0.04)
>    plot(amacrine, shape="arrows", direction=c(0,90), size=0.07)
> 
>    ## plot trees as trees!
>    plot(lansing, shape="arrows", direction=90, cols=1:6)
> 
>    # controlling MARK SCALE for pattern with numeric marks
>    plot(longleaf, markscale=0.1)
>    plot(longleaf, maxsize=5)
>    plot(longleaf, meansize=2)
> 
>    # draw circles of diameter equal to nearest neighbour distance
>    plot(cells %mark% nndist(cells), markscale=1, legend=FALSE)
> 
>    # inspecting the symbol map
>    v <- plot(amacrine)
>    v
Symbol map for discrete inputs:
[1] "off" "on" 
chars: [1] 1 2
> 
>    ## variable colours ('cols' not 'col')
>    plot(longleaf, cols=function(x) ifelse(x < 30, "red", "black"))
> 
>    ## re-using the same mark scale
>    a <- plot(longleaf)
>    juveniles <- longleaf[marks(longleaf) < 30]
>    plot(juveniles, symap=a)
> 
>    ## numerical marks mapped to symbols of fixed size with variable colour
>    ra <- range(marks(longleaf))
>    colmap <- colourmap(terrain.colors(20), range=ra)
>    ## filled plot characters are the codes 21-25
>    ## fill colour is indicated by 'bg'
>    sy <- symbolmap(pch=21, bg=colmap, range=ra)
>    plot(longleaf, symap=sy)
> 
>    ## or more compactly..
>    plot(longleaf, bg=terrain.colors(20), pch=21, cex=1)
> 
>    ## clipping
>    plot(humberside)
>    B <- owin(c(4810, 5190), c(4180, 4430))
>    plot(B, add=TRUE, border="red")
>    plot(humberside, clipwin=B, main="Humberside (clipped)")
> 
>    ## coordinate axes and labels
>    plot(humberside, axes=TRUE)
>    plot(humberside,            ann=TRUE, xlab="Easting", ylab="Northing")
>    plot(humberside, axes=TRUE, ann=TRUE, xlab="Easting", ylab="Northing")
> 
> 
> 
> cleanEx()
> nameEx("plot.pppmatching")
> ### * plot.pppmatching
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.pppmatching
> ### Title: Plot a Point Matching
> ### Aliases: plot.pppmatching
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   X <- runifpoint(7)
>   Y <- runifpoint(7)
>   am <- r2dtable(1, rep(10,7), rep(10,7))[[1]]/10
>   m2 <- pppmatching(X, Y, am)
>   plot(m2, adjust=0.3)
> 
> 
> 
> cleanEx()
> nameEx("plot.profilepl")
> ### * plot.profilepl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.profilepl
> ### Title: Plot Profile Likelihood
> ### Aliases: plot.profilepl
> ### Keywords: spatial hplot models
> 
> ### ** Examples
> 
>   rstep <- if(interactive()) 0.005 else 0.02
> 
>   # one irregular parameter
>   rr <- data.frame(r=seq(0.05,0.15, by=rstep))
>   ps <- profilepl(rr, Strauss, cells)
(computing rbord)
comparing 6 models...
1, 2, 3, 4, 5,  6.
fitting optimal model...
done.
>   plot(ps)                      # profile pseudolikelihood 
>   plot(ps, coeff="Interaction") # fitted interaction coefficient log(gamma)
> 
>   # two irregular parameters
>   rs <- expand.grid(r=seq(0.05,0.15, by=rstep),sat=1:3)
>   pg <- profilepl(rs, Geyer, cells)
(computing rbord)
comparing 18 models...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,  18.
fitting optimal model...
done.
>   plot(pg) # profile pseudolikelihood against r for each value of 'sat'
>   plot(pg, coeff="Interaction")
>   plot(pg, xvariable="sat", col=ifelse(r < 0.1, "red", "green"))
> 
> 
> 
> cleanEx()
> nameEx("plot.psp")
> ### * plot.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.psp
> ### Title: plot a Spatial Line Segment Pattern
> ### Aliases: plot.psp
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   X <- psp(runif(20), runif(20), runif(20), runif(20), window=owin())
>   plot(X)
>   plot(X, lwd=3)
>   lettuce <- sample(letters[1:4], 20, replace=TRUE)
>   marks(X) <- data.frame(A=1:20, B=factor(lettuce))
>   plot(X)
>   plot(X, which.marks="B")
>   plot(X, style="width", col="grey")
> 
> 
> 
> cleanEx()
> nameEx("plot.quad")
> ### * plot.quad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.quad
> ### Title: Plot a Spatial Quadrature Scheme
> ### Aliases: plot.quad
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    data(nztrees)
>    Q <- quadscheme(nztrees)
> 
>    plot(Q, main="NZ trees: quadrature scheme")
> 
>    oldpar <- par(mfrow=c(2,1))
>    plot(Q, main="NZ trees", dum=list(add=FALSE))
>    par(oldpar)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("plot.quadratcount")
> ### * plot.quadratcount
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.quadratcount
> ### Title: Plot Quadrat Counts
> ### Aliases: plot.quadratcount
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    plot(quadratcount(swedishpines, 5))
> 
> 
> 
> cleanEx()
> nameEx("plot.quadrattest")
> ### * plot.quadrattest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.quadrattest
> ### Title: Display the result of a quadrat counting test.
> ### Aliases: plot.quadrattest
> ### Keywords: spatial htest hplot
> 
> ### ** Examples
> 
>    plot(quadrat.test(swedishpines, 3))
> 
> 
> 
> cleanEx()
> nameEx("plot.rppm")
> ### * plot.rppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.rppm
> ### Title: Plot a Recursively Partitioned Point Process Model
> ### Aliases: plot.rppm
> ### Keywords: spatial hplot models
> 
> ### ** Examples
> 
>     # Murchison gold data
>     mur <- solapply(murchison, rescale, s=1000, unitname="km")
>     mur$dfault <- distfun(mur$faults)
>     # 
>     fit <- rppm(gold ~ dfault + greenstone, data=mur)
>     #
>     opa <- par(mfrow=c(1,2))
>     plot(fit)
>     plot(fit, what="spatial")
>     par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("plot.scan.test")
> ### * plot.scan.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.scan.test
> ### Title: Plot Result of Scan Test
> ### Aliases: plot.scan.test as.im.scan.test
> ### Keywords: htest spatial
> 
> ### ** Examples
> 
>    if(interactive()) {
+      a <- scan.test(redwood, seq(0.04, 0.1, by=0.01),
+                     method="poisson", nsim=19)
+    } else {
+      a <- scan.test(redwood, c(0.05, 0.1), method="poisson", nsim=2)
+    }
Simulating...1,  2.
>    plot(a)
>    as.im(a)
real-valued pixel image
157 x 157 pixel array (ny, nx)
enclosing rectangle: [-0.10153, 1.1015] x [-1.1015, 0.10153] units
>    plot(a, what="radius")
> 
> 
> 
> cleanEx()
> nameEx("plot.slrm")
> ### * plot.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.slrm
> ### Title: Plot a Fitted Spatial Logistic Regression
> ### Aliases: plot.slrm
> ### Keywords: spatial hplot models
> 
> ### ** Examples
> 
>    data(copper)
>    X <- copper$SouthPoints
>    Y <- copper$SouthLines
>    Z <- distmap(Y)
>    fit <- slrm(X ~ Z)
>    plot(fit)
>    plot(fit, type="link")
> 
> 
> 
> cleanEx()
> nameEx("plot.solist")
> ### * plot.solist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.solist
> ### Title: Plot a List of Spatial Objects
> ### Aliases: plot.solist
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
> # Intensity estimate of multitype point pattern
>  plot(D <- density(split(amacrine)))
>  plot(D, main="", equal.ribbon=TRUE,
+       panel.end=function(i,y,...){contour(y, ...)})
> 
> 
> 
> cleanEx()
> nameEx("plot.splitppp")
> ### * plot.splitppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.splitppp
> ### Title: Plot a List of Point Patterns
> ### Aliases: plot.splitppp
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
> # Multitype point pattern
>  plot(split(amacrine))
>  plot(split(amacrine), main="", 
+      panel.begin=function(i, y, ...) { plot(density(y), ribbon=FALSE, ...) })
> 
> 
> 
> cleanEx()
> nameEx("plot.ssf")
> ### * plot.ssf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.ssf
> ### Title: Plot a Spatially Sampled Function
> ### Aliases: plot.ssf image.ssf contour.ssf
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   a <- ssf(cells, nndist(cells, k=1:3))
>   plot(a, how="points")
[[1]]
Symbol map for real numbers in [0.0836301381082204, 0.154495954639596]
shape: circles
size: function (x, scal = 1.28152157248453) 
{
    scal * x
}
<environment: 0x00000000226aef00>

[[2]]
Symbol map for real numbers in [0.106976632962531, 0.182002747232013]
shape: circles
size: function (x, scal = 1.08784016584014) 
{
    scal * x
}
<environment: 0x0000000023a6ef58>

[[3]]
Symbol map for real numbers in [0.130361037123828, 0.215378736183496]
shape: circles
size: function (x, scal = 0.91926390803757) 
{
    scal * x
}
<environment: 0x0000000024fb6d10>

>   plot(a, how="smoothed")
>   plot(a, how="nearest")
> 
> 
> 
> cleanEx()
> nameEx("plot.studpermutest")
> ### * plot.studpermutest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.studpermutest
> ### Title: Plot a Studentised Permutation Test
> ### Aliases: plot.studpermutest
> ### Keywords: hplot htest
> 
> ### ** Examples
> 
>   np <- if(interactive()) 99 else 19
>   testpyramidal <- studpermu.test(pyramidal, Neurons ~ group, nperm=np)
Warning: 5 patterns have been discarded because they contained fewer than 20 points
>   plot(testpyramidal)
>   plot(testpyramidal, meanonly=TRUE)
>   plot(testpyramidal, col.theo=8, lwd.theo=4, lty.theo=1)
>   plot(testpyramidal, . ~ pi * r^2)
>   op <- par(mfrow=c(1,3))
>   plot(testpyramidal, separately=TRUE)
>   plot(testpyramidal, separately=TRUE, col=2, lty=1, lwd.mean=2, col.mean=4)
>   par(op)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("plot.symbolmap")
> ### * plot.symbolmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.symbolmap
> ### Title: Plot a Graphics Symbol Map
> ### Aliases: plot.symbolmap
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   g <- symbolmap(inputs=letters[1:10], pch=11:20)
>   plot(g)
> 
>   g2 <- symbolmap(range=c(-1,1),
+                     shape=function(x) ifelse(x > 0, "circles", "squares"),
+                     size=function(x) sqrt(ifelse(x > 0, x/pi, -x)),
+                     bg = function(x) ifelse(abs(x) < 1, "red", "black"))
>   plot(g2, vertical=TRUE, side="left", col.axis="blue", cex.axis=2)
> 
> 
> 
> cleanEx()
> nameEx("plot.tess")
> ### * plot.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.tess
> ### Title: Plot a Tessellation
> ### Aliases: plot.tess
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   Rect <- tess(xgrid=0:4,ygrid=0:4)
>   Diri <- dirichlet(runifpoint(7))
>   plot(Diri)
>   plot(Rect, border="blue", lwd=2, lty=2)
>   plot(Rect, do.col=TRUE, border="white")
>   plot(Rect, do.col=TRUE, values=runif(16), border="white")
>   B <- Rect[c(1, 2, 5, 7, 9)]
>   plot(B, hatch=TRUE)
>   plot(Diri, do.col=TRUE)
>   plot(Diri, do.col=TRUE, do.labels=TRUE, labelargs=list(col="white"),
+              ribbon=FALSE)
>   v <- as.im(function(x,y){factor(round(5 * (x^2 + y^2)))}, W=owin())
>   levels(v) <- letters[seq(length(levels(v)))]
>   Img <- tess(image=v)
>   plot(Img)
>   plot(Img, col=rainbow(11), ribargs=list(las=1))
>   a <- tile.areas(Diri)
>   marks(Diri) <- data.frame(area=a, random=runif(7, max=max(a)))
>   plot(Diri, do.col=TRUE, equal.ribbon=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("plot.textstring")
> ### * plot.textstring
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.textstring
> ### Title: Plot a Text String
> ### Aliases: plot.textstring
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   W <- Window(humberside)
>   te <- textstring(centroid.owin(W), txt="Humberside", cex=2.5)
>   te
Text string object
Text: "Humberside"
Coordinates: (5043.48287584704, 4453.46534009497)
>   plot(layered(W, te), main="")
> 
> 
> 
> cleanEx()
> nameEx("plot.texturemap")
> ### * plot.texturemap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.texturemap
> ### Title: Plot a Texture Map
> ### Aliases: plot.texturemap
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    tm <- texturemap(c("First", "Second", "Third"), 2:4, col=2:4)
>    plot(tm, vertical=FALSE)
>    ## abbreviate the labels
>    plot(tm, labelmap=function(x) substr(x, 1, 2))
> 
> 
> 
> cleanEx()
> nameEx("plot.yardstick")
> ### * plot.yardstick
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.yardstick
> ### Title: Plot a Yardstick or Scale Bar
> ### Aliases: plot.yardstick
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   plot(owin(), main="Yardsticks")
>   ys <- yardstick(as.psp(list(xmid=0.5, ymid=0.1, length=0.4, angle=0),
+                          window=owin(c(0.2, 0.8), c(0, 0.2))),
+                   txt="1 km")
>   plot(ys)
>   ys <- shift(ys, c(0, 0.3))
>   plot(ys, angle=90, frac=0.08)
>   ys <- shift(ys, c(0, 0.3))
>   plot(ys, split=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("points.lpp")
> ### * points.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: points.lpp
> ### Title: Draw Points on Existing Plot
> ### Aliases: points.lpp
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>  plot(Frame(spiders), main="Spiders on a Brick Wall")
>  points(spiders)
> 
> 
> 
> cleanEx()
> nameEx("pointsOnLines")
> ### * pointsOnLines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pointsOnLines
> ### Title: Place Points Evenly Along Specified Lines
> ### Aliases: pointsOnLines
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- psp(runif(20), runif(20), runif(20), runif(20),  window=owin())
>   Y <- pointsOnLines(X, eps=0.05)
>   plot(X, main="")
>   plot(Y, add=TRUE, pch="+")
> 
> 
> 
> cleanEx()
> nameEx("polartess")
> ### * polartess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polartess
> ### Title: Tessellation Using Polar Coordinates
> ### Aliases: polartess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   Y <- c(2.8, 1.5)
>   plot(polartess(letterR, nangular=6, radii=(0:4)/2, origin=Y),
+        do.col=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("polynom")
> ### * polynom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polynom
> ### Title: Polynomial in One or Two Variables
> ### Aliases: polynom
> ### Keywords: arith
> 
> ### ** Examples
> 
>    x <- 1:4
>    y <- 10 * (0:3)
>    polynom(x, 3)
     [x] [x^2] [x^3]
[1,]   1     1     1
[2,]   2     4     8
[3,]   3     9    27
[4,]   4    16    64
>    polynom(x, y, 3)
     [x] [y] [x^2] [x.y] [y^2] [x^3] [x^2.y] [x.y^2] [y^3]
[1,]   1   0     1     0     0     1       0       0     0
[2,]   2  10     4    20   100     8      40     200  1000
[3,]   3  20     9    60   400    27     180    1200  8000
[4,]   4  30    16   120   900    64     480    3600 27000
> 
> 
> 
> cleanEx()
> nameEx("pool.anylist")
> ### * pool.anylist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool.anylist
> ### Title: Pool Data from a List of Objects
> ### Aliases: pool.anylist
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    Keach <- anylapply(waterstriders, Kest, ratio=TRUE, correction="iso")
>    K <- pool(Keach)
> 
> 
> 
> cleanEx()
> nameEx("pool.envelope")
> ### * pool.envelope
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool.envelope
> ### Title: Pool Data from Several Envelopes
> ### Aliases: pool.envelope
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>    E1 <- envelope(cells, Kest, nsim=10, savefuns=TRUE)
Generating 10 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9,  10.

Done.
>    E2 <- envelope(cells, Kest, nsim=20, savefuns=TRUE)
Generating 20 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  20.

Done.
>    pool(E1, E2)
Pointwise critical envelopes for K(r)
and observed value for 'cells'
Obtained from 30 simulations of CSR
Alternative: two.sided
Significance level of pointwise Monte Carlo test: 2/31 = 0.0645
.....................................................................
     Math.label     Description                                      
r    r              distance argument r                              
obs  hat(K)[obs](r) observed value of K(r) for data pattern          
theo K[theo](r)     theoretical value of K(r) for CSR                
lo   hat(K)[lo](r)  lower pointwise envelope of K(r) from simulations
hi   hat(K)[hi](r)  upper pointwise envelope of K(r) from simulations
.....................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'theo', 'hi', 'lo'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
>    V1 <- envelope(E1, VARIANCE=TRUE)
>    V2 <- envelope(E2, VARIANCE=TRUE)
>    pool(V1, V2)
Pointwise 2 sigma critical envelopes for K(r)
and observed value for 'cells'
Obtained from 30 simulations of CSR
Alternative: two.sided
................................................................................
       Math.label            
r      r                     
obs    hat(K)[obs](r)        
theo   K[theo](r)            
lo     hat(K)[lo](r)         
hi     hat(K)[hi](r)         
mmean  bar(K)(r)             
var    bold(var)~hat(K)(r)   
res    bold(res)~hat(K)(r)   
stdres bold(stdres)~hat(K)(r)
loCI   K[loCI](r)            
hiCI   K[hiCI](r)            
       Description                                              
r      distance argument r                                      
obs    observed value of K(r) for data pattern                  
theo   theoretical value of K(r) for CSR                        
lo     lower 2 sigma critical limit for K(r)                    
hi     upper 2 sigma critical limit for K(r)                    
mmean  sample mean of K(r) from simulations                     
var    sample variance of K(r) from simulations                 
res    raw residual                                             
stdres standardised residual                                    
loCI   lower 2 sigma confidence bound for mean of simulated K(r)
hiCI   upper 2 sigma confidence bound for mean of simulated K(r)
................................................................................
Default plot formula:  .~r
where "." stands for 'obs', 'theo', 'hi', 'lo', 'mmean'
Columns 'lo' and 'hi' will be plotted as shading (by default)
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]
> 
> 
> 
> cleanEx()
> nameEx("pool.fasp")
> ### * pool.fasp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool.fasp
> ### Title: Pool Data from Several Function Arrays
> ### Aliases: pool.fasp
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>    data(amacrine)
>    A1 <- alltypes(amacrine,"K",nsim=9,envelope=TRUE,savefuns=TRUE)
>    A2 <- alltypes(amacrine,"K",nsim=10,envelope=TRUE,savefuns=TRUE)
>    pool(A1, A2)
Function array (class 'fasp' )
Dimensions:  2 x 2 
Title: array of envelopes of K functions for amacrine. 
> 
> 
> 
> cleanEx()
> nameEx("pool.fv")
> ### * pool.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool.fv
> ### Title: Pool Several Functions
> ### Aliases: pool.fv
> ### Keywords: spatial htest hplot iteration
> 
> ### ** Examples
> 
>    K <- lapply(waterstriders, Kest, correction="iso")
>    Kall <- pool(K[[1]], K[[2]], K[[3]])
>    Kall <- pool(as.anylist(K))
>    plot(Kall, cbind(pooliso, pooltheo) ~ r,
+               shade=c("loiso", "hiiso"),
+               main="Pooled K function of waterstriders")
> 
> 
> 
> cleanEx()
> nameEx("pool.quadrattest")
> ### * pool.quadrattest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool.quadrattest
> ### Title: Pool Several Quadrat Tests
> ### Aliases: pool.quadrattest
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   Y <- split(humberside)
>   test1 <- quadrat.test(Y[[1]])
Warning: Some expected counts are small; chi^2 approximation may be inaccurate
>   test2 <- quadrat.test(Y[[2]])
Warning: Some expected counts are small; chi^2 approximation may be inaccurate
>   pool(test1, test2, Xname="Humberside")
Warning: Some expected counts are small; chi^2 approximation may be inaccurate

	Chi-squared test of CSR using quadrat counts

data:  Humberside
X2 = 747.2, df = 38, p-value < 2.2e-16
alternative hypothesis: two.sided

Pooled test
Quadrats of component tests:
List of spatial objects

Component 1:
20 tiles (irregular windows)

Component 2:
20 tiles (irregular windows)
> 
> 
> 
> cleanEx()
> nameEx("pool.rat")
> ### * pool.rat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool.rat
> ### Title: Pool Data from Several Ratio Objects
> ### Aliases: pool.rat
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    K1 <- Kest(runifpoint(42), ratio=TRUE, correction="iso")   
>    K2 <- Kest(runifpoint(42), ratio=TRUE, correction="iso")   
>    K3 <- Kest(runifpoint(42), ratio=TRUE, correction="iso")
>    K <- pool(K1, K2, K3)
>    plot(K, pooliso ~ r, shade=c("hiiso", "loiso"))
> 
> 
> 
> cleanEx()
> nameEx("pp3")
> ### * pp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pp3
> ### Title: Three Dimensional Point Pattern
> ### Aliases: pp3
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- pp3(runif(10), runif(10), runif(10),
+             box3(c(0,1)),
+             marks=rnorm(10))
>    X
Marked three-dimensional point pattern: 10 points
marks are numeric, of storage type  'double'
Box: [0, 1] x [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("ppm")
> ### * ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppm
> ### Title: Fit Point Process Model to Data
> ### Aliases: ppm ppm.formula
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>  # fit the stationary Poisson process
>  # to point pattern 'nztrees'
> 
>  ppm(nztrees ~ 1)
Stationary Poisson process
Intensity: 0.005916753
             Estimate      S.E.   CI95.lo   CI95.hi Ztest      Zval
log(lambda) -5.129968 0.1078328 -5.341316 -4.918619   *** -47.57336
> 
>  ## Not run: 
> ##D  Q <- quadscheme(nztrees) 
> ##D  ppm(Q ~ 1) 
> ##D  # equivalent.
> ##D  
> ## End(Not run)
> 
> fit1 <- ppm(nztrees ~ x)
>  # fit the nonstationary Poisson process 
>  # with intensity function lambda(x,y) = exp(a + bx)
>  # where x,y are the Cartesian coordinates
>  # and a,b are parameters to be estimated
> 
> fit1
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-5.334710638  0.002590672 

                Estimate        S.E.      CI95.lo      CI95.hi Ztest       Zval
(Intercept) -5.334710638 0.227156239 -5.779928685 -4.889492591   *** -23.484764
x            0.002590672 0.002451731 -0.002214633  0.007395976         1.056671
> coef(fit1)
 (Intercept)            x 
-5.334710638  0.002590672 
> coef(summary(fit1))
                Estimate        S.E.      CI95.lo      CI95.hi Ztest       Zval
(Intercept) -5.334710638 0.227156239 -5.779928685 -4.889492591   *** -23.484764
x            0.002590672 0.002451731 -0.002214633  0.007395976         1.056671
> 
> ## Not run: 
> ##D  ppm(nztrees ~ polynom(x,2))
> ## End(Not run)
> ## Don't show: 
>  ppm(nztrees ~ polynom(x,2), nd=16)
Nonstationary Poisson process

Log intensity:  ~x + I(x^2)

Fitted trend coefficients:
  (Intercept)             x        I(x^2) 
-4.8895765803 -0.0147730179  0.0001107221 

                 Estimate         S.E.       CI95.lo       CI95.hi Ztest
(Intercept) -4.8895765803 3.078052e-01 -5.492864e+00 -4.2862895689   ***
x           -0.0147730179 9.437881e-03 -3.327093e-02  0.0037248893      
I(x^2)       0.0001107221 5.866441e-05 -4.257988e-06  0.0002257023      
                  Zval
(Intercept) -15.885298
x            -1.565290
I(x^2)        1.887382
> ## End(Don't show)
> 
>  # fit the nonstationary Poisson process 
>  # with intensity function lambda(x,y) = exp(a + bx + cx^2)
> 
>  ## Not run: 
> ##D  library(splines)
> ##D  ppm(nztrees ~ bs(x,df=3))
> ##D  
> ## End(Not run)
>  #       WARNING: do not use predict.ppm() on this result
>  # Fits the nonstationary Poisson process 
>  # with intensity function lambda(x,y) = exp(B(x))
>  # where B is a B-spline with df = 3
> 
> ## Not run: 
> ##D  ppm(nztrees ~ 1, Strauss(r=10), rbord=10)
> ## End(Not run)
> ## Don't show: 
>  ppm(nztrees ~ 1, Strauss(r=10), rbord=10, nd=16)
Stationary Strauss process

First order term:  beta = 0.005128441

Interaction distance:	10
Fitted interaction parameter gamma:	 1.0580601

Relevant coefficients:
Interaction 
 0.05643711 

For standard errors, type coef(summary(x))

*** Model is not valid ***
*** Interaction parameters are outside valid range ***
> ## End(Don't show)
>  # Fit the stationary Strauss process with interaction range r=10
>  # using the border method with margin rbord=10
> 
> ## Not run: 
> ##D  ppm(nztrees ~ x, Strauss(13), correction="periodic")
> ## End(Not run)
> ## Don't show: 
>  ppm(nztrees ~ x, Strauss(13), correction="periodic", nd=16)
Nonstationary Strauss process

Log trend:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-5.581856032  0.001800151 

Interaction distance:	13
Fitted interaction parameter gamma:	 1.1028477

Relevant coefficients:
Interaction 
 0.09789567 

For standard errors, type coef(summary(x))

*** Model is not valid ***
*** Interaction parameters are outside valid range ***
> ## End(Don't show)
>  # Fit the nonstationary Strauss process with interaction range r=13
>  # and exp(first order potential) =  activity = beta(x,y) = exp(a+bx)
>  # using the periodic correction.
> 
> 
> # Compare Maximum Pseudolikelihood, Huang-Ogata and Variational Bayes fits:
> ## Not run: ppm(swedishpines ~ 1, Strauss(9))
> 
> ## Not run: ppm(swedishpines ~ 1, Strauss(9), method="ho")
> ## Don't show: 
> ppm(swedishpines ~ 1, Strauss(9), method="ho", nd=16, nsim=8)
Simulating... 1, 2, 3, 4, 5, 6, 7,  8.
Done.

Stationary Strauss process

First order term:  beta = 0.1286367

Interaction distance:	9
Fitted interaction parameter gamma:	 0.3227439

Relevant coefficients:
Interaction 
  -1.130896 

For standard errors, type coef(summary(x))
> ## End(Don't show)
> 
> ppm(swedishpines ~ 1, Strauss(9), method="VBlogi")
Stationary Strauss process

First order term:  beta = 0.05878658

Interaction distance:	9
Fitted interaction parameter gamma:	 0.2549567

Relevant coefficients:
Interaction 
  -1.366661 

> 
>  # COVARIATES
>  #
>  X <- rpoispp(42)
>  weirdfunction <- function(x,y){ 10 * x^2 + 5 * sin(10 * y) }
>  #
>  # (a) covariate values as function
>  ppm(X ~ y + weirdfunction)
Nonstationary Poisson process

Log intensity:  ~y + weirdfunction

Fitted trend coefficients:
  (Intercept)             y weirdfunction 
   3.26841823    0.49081700    0.08430789 

                Estimate       S.E.    CI95.lo   CI95.hi Ztest     Zval
(Intercept)   3.26841823 0.34453033  2.5931512 3.9436853   *** 9.486591
y             0.49081700 0.46389580 -0.4184021 1.4000361       1.058033
weirdfunction 0.08430789 0.03152996  0.0225103 0.1461055    ** 2.673898
>  #
>  # (b) covariate values in pixel image
>  Zimage <- as.im(weirdfunction, unit.square())
>  ppm(X ~ y + Z, covariates=list(Z=Zimage))
Nonstationary Poisson process

Log intensity:  ~y + Z

Fitted trend coefficients:
(Intercept)           y           Z 
 3.27338387  0.49914154  0.08229736 

              Estimate       S.E.     CI95.lo   CI95.hi Ztest     Zval
(Intercept) 3.27338387 0.34519962  2.59680505 3.9499627   *** 9.482583
y           0.49914154 0.46476415 -0.41177946 1.4100625       1.073967
Z           0.08229736 0.03136968  0.02081391 0.1437808    ** 2.623468
>  #
>  # (c) covariate values in data frame
>  Q <- quadscheme(X)
>  xQ <- x.quad(Q)
>  yQ <- y.quad(Q)
>  Zvalues <- weirdfunction(xQ,yQ)
>  ppm(Q ~  y + Z, data=data.frame(Z=Zvalues))
Nonstationary Poisson process

Log intensity:  ~y + Z

Fitted trend coefficients:
(Intercept)           y           Z 
 3.26841823  0.49081700  0.08430789 

              Estimate       S.E.    CI95.lo   CI95.hi Ztest     Zval
(Intercept) 3.26841823 0.34453033  2.5931512 3.9436853   *** 9.486591
y           0.49081700 0.46389580 -0.4184021 1.4000361       1.058033
Z           0.08430789 0.03152996  0.0225103 0.1461055    ** 2.673898
>  # Note Q not X
> 
>  # COVARIATE FUNCTION WITH EXTRA ARGUMENTS
>  #
> f <- function(x,y,a){ y - a }
> ppm(X ~ x + f, covfunargs=list(a=1/2))
Nonstationary Poisson process

Log intensity:  ~x + f

Fitted trend coefficients:
(Intercept)           x           f 
  3.1221965   1.4646306   0.4630457 

Covariate function arguments (covfunargs) provided:
a = 0.5 
             Estimate      S.E.    CI95.lo  CI95.hi Ztest      Zval
(Intercept) 3.1221965 0.3425452  2.4508203 3.793573   *** 9.1146995
x           1.4646306 0.5060461  0.4727984 2.456463    ** 2.8942631
f           0.4630457 0.4831510 -0.4839128 1.410004       0.9583872
> 
>  # COVARIATE: inside/outside window
>  b <- owin(c(0.1, 0.6), c(0.1, 0.9))
>  ppm(X ~ b)
Nonstationary Poisson process

Log intensity:  ~b

Fitted trend coefficients:
(Intercept)       bTRUE 
 3.92331701  0.06731079 

              Estimate      S.E.   CI95.lo   CI95.hi Ztest       Zval
(Intercept) 3.92331701 0.1825742  3.565478 4.2811558   *** 21.4888923
bTRUE       0.06731079 0.2806918 -0.482835 0.6174566        0.2398032
> 
>  ## MULTITYPE POINT PROCESSES ### 
>  # fit stationary marked Poisson process
>  # with different intensity for each species
> ## Not run: ppm(lansing ~  marks, Poisson())
> ## Don't show: 
>   ama <- amacrine[square(0.7)]
>   a <- ppm(ama ~  marks, Poisson(), nd=16)
> ## End(Don't show)
> 
>  # fit nonstationary marked Poisson process
>  # with different log-cubic trend for each species
> ## Not run: ppm(lansing ~  marks * polynom(x,y,3), Poisson())
> ## Don't show: 
> b <- ppm(ama ~  marks * polynom(x,y,2), Poisson(), nd=16)
> ## End(Don't show)
> 
> 
> 
> 
> cleanEx()
> nameEx("ppm.object")
> ### * ppm.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppm.object
> ### Title: Class of Fitted Point Process Models
> ### Aliases: ppm.object methods.ppm
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
>   fit <- ppm(cells ~ x, Strauss(0.1), correction="periodic")
>   fit
Nonstationary Strauss process

Log trend:  ~x

Fitted trend coefficients:
(Intercept)           x 
  5.8121998   0.1307123 

Interaction distance:	0.1
Fitted interaction parameter gamma:	 0.021335

Relevant coefficients:
Interaction 
  -3.847409 

For standard errors, type coef(summary(x))
>   coef(fit)
(Intercept)           x Interaction 
  5.8121998   0.1307123  -3.8474086 
>   ## Not run: 
> ##D   pred <- predict(fit)
> ##D   
> ## End(Not run)
>   pred <- predict(fit, ngrid=20, type="trend")
>   ## Not run: 
> ##D   plot(fit)
> ##D   
> ## End(Not run)  
> 
> 
> 
> cleanEx()
> nameEx("ppm.ppp")
> ### * ppm.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppm.ppp
> ### Title: Fit Point Process Model to Point Pattern Data
> ### Aliases: ppm.ppp ppm.quad
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>  # fit the stationary Poisson process
>  # to point pattern 'nztrees'
> 
>  ppm(nztrees)
Stationary Poisson process
Intensity: 0.005916753
             Estimate      S.E.   CI95.lo   CI95.hi Ztest      Zval
log(lambda) -5.129968 0.1078328 -5.341316 -4.918619   *** -47.57336
>  ppm(nztrees ~ 1)
Stationary Poisson process
Intensity: 0.005916753
             Estimate      S.E.   CI95.lo   CI95.hi Ztest      Zval
log(lambda) -5.129968 0.1078328 -5.341316 -4.918619   *** -47.57336
> 
>  ## Not run: 
> ##D  Q <- quadscheme(nztrees) 
> ##D  ppm(Q) 
> ##D  # equivalent.
> ##D  
> ## End(Not run)
> 
>  ## Not run: 
> ##D   ppm(nztrees, nd=128)
> ##D  
> ## End(Not run)
>  ## Don't show: 
>    ppm(nztrees, nd=16)
Stationary Poisson process
Intensity: 0.005916753
             Estimate      S.E.   CI95.lo   CI95.hi Ztest      Zval
log(lambda) -5.129968 0.1078328 -5.341316 -4.918619   *** -47.57336
>  
> ## End(Don't show)
> 
> fit1 <- ppm(nztrees, ~ x)
>  # fit the nonstationary Poisson process 
>  # with intensity function lambda(x,y) = exp(a + bx)
>  # where x,y are the Cartesian coordinates
>  # and a,b are parameters to be estimated
> 
> fit1
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-5.334710638  0.002590672 

                Estimate        S.E.      CI95.lo      CI95.hi Ztest       Zval
(Intercept) -5.334710638 0.227156239 -5.779928685 -4.889492591   *** -23.484764
x            0.002590672 0.002451731 -0.002214633  0.007395976         1.056671
> coef(fit1)
 (Intercept)            x 
-5.334710638  0.002590672 
> coef(summary(fit1))
                Estimate        S.E.      CI95.lo      CI95.hi Ztest       Zval
(Intercept) -5.334710638 0.227156239 -5.779928685 -4.889492591   *** -23.484764
x            0.002590672 0.002451731 -0.002214633  0.007395976         1.056671
> 
> ## Not run: 
> ##D  ppm(nztrees, ~ polynom(x,2))
> ## End(Not run)
> ## Don't show: 
>  ppm(nztrees, ~ polynom(x,2), nd=16)
Nonstationary Poisson process

Log intensity:  ~x + I(x^2)

Fitted trend coefficients:
  (Intercept)             x        I(x^2) 
-4.8895765803 -0.0147730179  0.0001107221 

                 Estimate         S.E.       CI95.lo       CI95.hi Ztest
(Intercept) -4.8895765803 3.078052e-01 -5.492864e+00 -4.2862895689   ***
x           -0.0147730179 9.437881e-03 -3.327093e-02  0.0037248893      
I(x^2)       0.0001107221 5.866441e-05 -4.257988e-06  0.0002257023      
                  Zval
(Intercept) -15.885298
x            -1.565290
I(x^2)        1.887382
> ## End(Don't show)
> 
>  # fit the nonstationary Poisson process 
>  # with intensity function lambda(x,y) = exp(a + bx + cx^2)
> 
>  ## Not run: 
> ##D  library(splines)
> ##D  ppm(nztrees, ~ bs(x,df=3))
> ##D  
> ## End(Not run)
>  #       WARNING: do not use predict.ppm() on this result
>  # Fits the nonstationary Poisson process 
>  # with intensity function lambda(x,y) = exp(B(x))
>  # where B is a B-spline with df = 3
> 
> ## Not run: 
> ##D  ppm(nztrees, ~1, Strauss(r=10), rbord=10)
> ## End(Not run)
> ## Don't show: 
>  ppm(nztrees, ~1, Strauss(r=10), rbord=10, nd=16)
Stationary Strauss process

First order term:  beta = 0.005128441

Interaction distance:	10
Fitted interaction parameter gamma:	 1.0580601

Relevant coefficients:
Interaction 
 0.05643711 

For standard errors, type coef(summary(x))

*** Model is not valid ***
*** Interaction parameters are outside valid range ***
> ## End(Don't show)
>  # Fit the stationary Strauss process with interaction range r=10
>  # using the border method with margin rbord=10
> 
> ## Not run: 
> ##D  ppm(nztrees, ~ x, Strauss(13), correction="periodic")
> ## End(Not run)
> ## Don't show: 
>  ppm(nztrees, ~ x, Strauss(13), correction="periodic", nd=16)
Nonstationary Strauss process

Log trend:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-5.581856032  0.001800151 

Interaction distance:	13
Fitted interaction parameter gamma:	 1.1028477

Relevant coefficients:
Interaction 
 0.09789567 

For standard errors, type coef(summary(x))

*** Model is not valid ***
*** Interaction parameters are outside valid range ***
> ## End(Don't show)
>  # Fit the nonstationary Strauss process with interaction range r=13
>  # and exp(first order potential) =  activity = beta(x,y) = exp(a+bx)
>  # using the periodic correction.
> 
> 
> # Compare Maximum Pseudolikelihood, Huang-Ogata and VB fits:
> ## Not run: ppm(swedishpines, ~1, Strauss(9))
> 
> ## Not run: ppm(swedishpines, ~1, Strauss(9), method="ho")
> ## Don't show: 
> ppm(swedishpines, ~1, Strauss(9), method="ho", nd=16, nsim=8)
Simulating... 1, 2, 3, 4, 5, 6, 7,  8.
Done.

Stationary Strauss process

First order term:  beta = 0.1286367

Interaction distance:	9
Fitted interaction parameter gamma:	 0.3227439

Relevant coefficients:
Interaction 
  -1.130896 

For standard errors, type coef(summary(x))
> ## End(Don't show)
> 
> ppm(swedishpines, ~1, Strauss(9), method="VBlogi")
Stationary Strauss process

First order term:  beta = 0.05878658

Interaction distance:	9
Fitted interaction parameter gamma:	 0.2549567

Relevant coefficients:
Interaction 
  -1.366661 

> 
>  # COVARIATES
>  #
>  X <- rpoispp(42)
>  weirdfunction <- function(x,y){ 10 * x^2 + 5 * sin(10 * y) }
>  #
>  # (a) covariate values as function
>  ppm(X, ~ y + Z, covariates=list(Z=weirdfunction))
Nonstationary Poisson process

Log intensity:  ~y + Z

Fitted trend coefficients:
(Intercept)           y           Z 
 3.26841823  0.49081700  0.08430789 

              Estimate       S.E.    CI95.lo   CI95.hi Ztest     Zval
(Intercept) 3.26841823 0.34453033  2.5931512 3.9436853   *** 9.486591
y           0.49081700 0.46389580 -0.4184021 1.4000361       1.058033
Z           0.08430789 0.03152996  0.0225103 0.1461055    ** 2.673898
>  #
>  # (b) covariate values in pixel image
>  Zimage <- as.im(weirdfunction, unit.square())
>  ppm(X, ~ y + Z, covariates=list(Z=Zimage))
Nonstationary Poisson process

Log intensity:  ~y + Z

Fitted trend coefficients:
(Intercept)           y           Z 
 3.27338387  0.49914154  0.08229736 

              Estimate       S.E.     CI95.lo   CI95.hi Ztest     Zval
(Intercept) 3.27338387 0.34519962  2.59680505 3.9499627   *** 9.482583
y           0.49914154 0.46476415 -0.41177946 1.4100625       1.073967
Z           0.08229736 0.03136968  0.02081391 0.1437808    ** 2.623468
>  #
>  # (c) covariate values in data frame
>  Q <- quadscheme(X)
>  xQ <- x.quad(Q)
>  yQ <- y.quad(Q)
>  Zvalues <- weirdfunction(xQ,yQ)
>  ppm(Q, ~ y + Z, covariates=data.frame(Z=Zvalues))
Nonstationary Poisson process

Log intensity:  ~y + Z

Fitted trend coefficients:
(Intercept)           y           Z 
 3.26841823  0.49081700  0.08430789 

              Estimate       S.E.    CI95.lo   CI95.hi Ztest     Zval
(Intercept) 3.26841823 0.34453033  2.5931512 3.9436853   *** 9.486591
y           0.49081700 0.46389580 -0.4184021 1.4000361       1.058033
Z           0.08430789 0.03152996  0.0225103 0.1461055    ** 2.673898
>  # Note Q not X
> 
>  # COVARIATE FUNCTION WITH EXTRA ARGUMENTS
>  #
> f <- function(x,y,a){ y - a }
> ppm(X, ~x + f, covariates=list(f=f), covfunargs=list(a=1/2))
Nonstationary Poisson process

Log intensity:  ~x + f

Fitted trend coefficients:
(Intercept)           x           f 
  3.1221965   1.4646306   0.4630457 

Covariate function arguments (covfunargs) provided:
a = 0.5 
             Estimate      S.E.    CI95.lo  CI95.hi Ztest      Zval
(Intercept) 3.1221965 0.3425452  2.4508203 3.793573   *** 9.1146995
x           1.4646306 0.5060461  0.4727984 2.456463    ** 2.8942631
f           0.4630457 0.4831510 -0.4839128 1.410004       0.9583872
> 
>  # COVARIATE: inside/outside window
>  b <- owin(c(0.1, 0.6), c(0.1, 0.9))
>  ppm(X, ~w, covariates=list(w=b))
Nonstationary Poisson process

Log intensity:  ~w

Fitted trend coefficients:
(Intercept)       wTRUE 
 3.92331701  0.06731079 

              Estimate      S.E.   CI95.lo   CI95.hi Ztest       Zval
(Intercept) 3.92331701 0.1825742  3.565478 4.2811558   *** 21.4888923
wTRUE       0.06731079 0.2806918 -0.482835 0.6174566        0.2398032
> 
>  ## MULTITYPE POINT PROCESSES ### 
>  # fit stationary marked Poisson process
>  # with different intensity for each species
> ## Not run: ppm(lansing, ~ marks, Poisson())
> ## Don't show: 
>    ama <- amacrine[square(0.7)]
>    a <- ppm(ama, ~ marks, Poisson(), nd=16)
> ## End(Don't show)
> 
>  # fit nonstationary marked Poisson process
>  # with different log-cubic trend for each species
> ## Not run: ppm(lansing, ~ marks * polynom(x,y,3), Poisson())
> ## Don't show: 
> b <- ppm(ama, ~ marks * polynom(x,y,2), Poisson(), nd=16)
> ## End(Don't show)
> 
> 
> 
> 
> cleanEx()
> nameEx("ppmInfluence")
> ### * ppmInfluence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppmInfluence
> ### Title: Leverage and Influence Measures for Spatial Point Process Model
> ### Aliases: ppmInfluence
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X ~ x+y)
>    fI <- ppmInfluence(fit)
> 
>    fitlev <- fI$leverage
>    fitlev <- leverage(fI)
> 
>    fitinf <- fI$influence
>    fitinf <- influence(fI)
> 
>    fitdfb <- fI$dfbetas
>    fitdfb <- dfbetas(fI) 
> 
> 
> 
> cleanEx()
> nameEx("ppp")
> ### * ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppp
> ### Title: Create a Point Pattern
> ### Aliases: ppp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   # some arbitrary coordinates in [0,1]
>   x <- runif(20)
>   y <- runif(20)
> 
>   # the following are equivalent
>   X <- ppp(x, y, c(0,1), c(0,1))
>   X <- ppp(x, y)
>   X <- ppp(x, y, window=owin(c(0,1),c(0,1)))
> 
>   # specify that the coordinates are given in metres
>   X <- ppp(x, y, c(0,1), c(0,1), unitname=c("metre","metres"))
> 
>   ## Not run: plot(X)
> 
>   # marks
>   m <- sample(1:2, 20, replace=TRUE)
>   m <- factor(m, levels=1:2)
>   X <- ppp(x, y, c(0,1), c(0,1), marks=m)
>   ## Not run: plot(X)
> 
>   # polygonal window
>   X <- ppp(x, y, poly=list(x=c(0,10,0), y=c(0,0,10)))
>   ## Not run: plot(X)
> 
>   # circular window of radius 2
>   X <- ppp(x, y, window=disc(2))
> 
>   # copy the window from another pattern
>   data(cells)
>   X <- ppp(x, y, window=Window(cells))
> 
> 
> 
> cleanEx()
> nameEx("ppp.object")
> ### * ppp.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppp.object
> ### Title: Class of Point Patterns
> ### Aliases: ppp.object
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
>   x <- runif(100)
>   y <- runif(100)
>   X <- ppp(x, y, c(0,1),c(0,1))
>   X
Planar point pattern: 100 points
window: rectangle = [0, 1] x [0, 1] units
>   ## Not run: plot(X)
>   mar <- sample(1:3, 100, replace=TRUE)
>   mm <- ppp(x, y, c(0,1), c(0,1), marks=mar)
>   ## Not run: plot(mm)
>   # points with mark equal to 2
>   ss <- mm[ mm$marks == 2 , ]
>   ## Not run: plot(ss)
>   # left half of pattern 'mm'
>   lu <- owin(c(0,0.5),c(0,1))
>   mmleft <- mm[ , lu]
>   ## Not run: plot(mmleft)
>   ## Not run: 
> ##D   if(FALSE) {
> ##D   # input data from file
> ##D   qq <- scanpp("my.table", unit.square())
> ##D 
> ##D   # interactively build a point pattern
> ##D   plot(unit.square())
> ##D   X <- as.ppp(locator(10), unit.square())
> ##D   plot(X)
> ##D   }
> ##D  
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("pppdist")
> ### * pppdist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pppdist
> ### Title: Distance Between Two Point Patterns
> ### Aliases: pppdist
> ### Keywords: spatial math
> 
> ### ** Examples
> 
> # equal cardinalities
> set.seed(140627)
> X <- runifpoint(500)
> Y <- runifpoint(500)
> m <- pppdist(X, Y)
> m
spa-1 matching of two planar point patterns (cutoff = 1)
pp1: 500 points
pp2: 500 points
window: rectangle = [0, 1] x [0, 1] units
point matching, 500 lines
distance: 0.0455915251234318
> ## Not run: 
> ##D plot(m)
> ## End(Not run)
>   
> # differing cardinalities
> X <- runifpoint(14)
> Y <- runifpoint(10)
> m1 <- pppdist(X, Y, type="spa")
> m2 <- pppdist(X, Y, type="ace")
> m3 <- pppdist(X, Y, type="mat", auction=FALSE)
> summary(m1)
spa-1 matching of two planar point patterns (cutoff = 1)
pp1: 14 points
pp2: 10 points
window: rectangle = [0, 1] x [0, 1] units
point matching, 10 lines
matching is left-unique right-total right-unique
distance: 0.399779301206966
> summary(m2)
ace-1 matching of two planar point patterns (cutoff = 1)
pp1: 14 points
pp2: 10 points
window: rectangle = [0, 1] x [0, 1] units
matching is empty
distance: 1
> summary(m3)
mat-1 matching of two planar point patterns (cutoff = 1)
pp1: 14 points
pp2: 10 points
window: rectangle = [0, 1] x [0, 1] units
fractional matching, 23 flows
distance: 0.2103687637759
> ## Not run: 
> ##D m1$matrix
> ##D m2$matrix
> ##D m3$matrix
> ## End(Not run)
> 
> # q = Inf
> X <- runifpoint(10)
> Y <- runifpoint(10)
> mx1 <- pppdist(X, Y, q=Inf, matching=FALSE)
Warning in pppdist.prohorov(X, Y, n, d, type, cutoff, matching, ccode, auction,  :
  distance with parameter q = Inf is approximated by distance with parameter q = 10
Warning in pppdist.prohorov(X, Y, n, d, type, cutoff, matching, ccode, auction,  :
  6 zeroes introduced, while rounding distances
> mx2 <- pppdist(X, Y, q=Inf, matching=FALSE, ccode=FALSE, approximation=50)
Warning in pppdist.prohorov(X, Y, n, d, type, cutoff, matching, ccode, auction,  :
  distance with parameter q = Inf is approximated by distance with parameter q = 50
Warning in pppdist.prohorov(X, Y, n, d, type, cutoff, matching, ccode, auction,  :
  54 pseudo-zeroes introduced, while taking the q-th powers of distances
> mx3 <- pppdist(X, Y, q=Inf, matching=FALSE, approximation=Inf)
> all.equal(mx1,mx2,mx3)
[1] TRUE
> # sometimes TRUE
> all.equal(mx2,mx3)
[1] TRUE
> # very often TRUE
> 
> 
> 
> cleanEx()
> nameEx("pppmatching")
> ### * pppmatching
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pppmatching
> ### Title: Create a Point Matching
> ### Aliases: pppmatching
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   # a random unweighted complete matching
>   X <- runifpoint(10)
>   Y <- runifpoint(10)
>   am <- r2dtable(1, rep(1,10), rep(1,10))[[1]]
>         # generates a random permutation matrix
>   m <- pppmatching(X, Y, am)
>   summary(m)
Generic matching of two planar point patterns
pp1: 10 points
pp2: 10 points
window: rectangle = [0, 1] x [0, 1] units
point matching, 10 lines
matching is 1-1
>   m$matrix
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    0    0    0    0    0    0    0    0     1
 [2,]    0    0    1    0    0    0    0    0    0     0
 [3,]    0    0    0    0    0    0    0    1    0     0
 [4,]    0    0    0    0    1    0    0    0    0     0
 [5,]    1    0    0    0    0    0    0    0    0     0
 [6,]    0    0    0    0    0    0    1    0    0     0
 [7,]    0    1    0    0    0    0    0    0    0     0
 [8,]    0    0    0    0    0    0    0    0    1     0
 [9,]    0    0    0    1    0    0    0    0    0     0
[10,]    0    0    0    0    0    1    0    0    0     0
>   plot(m)
> 
>   # a random weighted complete matching
>   X <- runifpoint(7)
>   Y <- runifpoint(7)
>   am <- r2dtable(1, rep(10,7), rep(10,7))[[1]]/10
>         # generates a random doubly stochastic matrix
>   m2 <- pppmatching(X, Y, am)
>   summary(m2)
Generic matching of two planar point patterns
pp1: 7 points
pp2: 7 points
window: rectangle = [0, 1] x [0, 1] units
fractional matching, 37 flows
>   m2$matrix
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]  0.0  0.2  0.0  0.1  0.3  0.2  0.2
[2,]  0.3  0.2  0.1  0.2  0.1  0.1  0.0
[3,]  0.1  0.1  0.4  0.1  0.0  0.0  0.3
[4,]  0.3  0.1  0.1  0.0  0.2  0.3  0.0
[5,]  0.0  0.0  0.2  0.4  0.0  0.1  0.3
[6,]  0.1  0.3  0.0  0.1  0.2  0.1  0.2
[7,]  0.2  0.1  0.2  0.1  0.2  0.2  0.0
>   plot(m2)
>   m3 <- pppmatching(X, Y, am, "ace")
>   m4 <- pppmatching(X, Y, am, "mat")
> 
> 
> 
> cleanEx()
> nameEx("pppmatching.object")
> ### * pppmatching.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pppmatching.object
> ### Title: Class of Point Matchings
> ### Aliases: pppmatching.object
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
>   # a random complete unweighted matching
>   X <- runifpoint(10)
>   Y <- runifpoint(10)
>   am <- r2dtable(1, rep(1,10), rep(1,10))[[1]]
>         # generates a random permutation matrix
>   m <- pppmatching(X, Y, am)
>   summary(m)
Generic matching of two planar point patterns
pp1: 10 points
pp2: 10 points
window: rectangle = [0, 1] x [0, 1] units
point matching, 10 lines
matching is 1-1
>   m$matrix
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    0    0    0    0    0    0    0    0     1
 [2,]    0    0    1    0    0    0    0    0    0     0
 [3,]    0    0    0    0    0    0    0    1    0     0
 [4,]    0    0    0    0    1    0    0    0    0     0
 [5,]    1    0    0    0    0    0    0    0    0     0
 [6,]    0    0    0    0    0    0    1    0    0     0
 [7,]    0    1    0    0    0    0    0    0    0     0
 [8,]    0    0    0    0    0    0    0    0    1     0
 [9,]    0    0    0    1    0    0    0    0    0     0
[10,]    0    0    0    0    0    1    0    0    0     0
>   ## Not run: 
> ##D     plot(m)
> ##D   
> ## End(Not run)
> 
>   # an optimal complete unweighted matching
>   m2 <- pppdist(X,Y)
>   summary(m2)
spa-1 matching of two planar point patterns (cutoff = 1)
pp1: 10 points
pp2: 10 points
window: rectangle = [0, 1] x [0, 1] units
point matching, 10 lines
matching is 1-1
distance: 0.173089998911717
>   m2$matrix
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    0    0    1    0    0    0    0    0     0
 [2,]    0    0    0    0    0    0    0    1    0     0
 [3,]    0    0    0    0    0    1    0    0    0     0
 [4,]    0    0    1    0    0    0    0    0    0     0
 [5,]    0    1    0    0    0    0    0    0    0     0
 [6,]    1    0    0    0    0    0    0    0    0     0
 [7,]    0    0    0    0    0    0    0    0    1     0
 [8,]    0    0    0    0    1    0    0    0    0     0
 [9,]    0    0    0    0    0    0    0    0    0     1
[10,]    0    0    0    0    0    0    1    0    0     0
>   ## Not run: 
> ##D     plot(m2)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ppx")
> ### * ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppx
> ### Title: Multidimensional Space-Time Point Pattern
> ### Aliases: ppx
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(4),y=runif(4),t=runif(4),
+                     age=rep(c("old", "new"), 2),
+                     size=runif(4))
>    X <- ppx(data=df, coord.type=c("s","s","t","m","m"))
>    X
Multidimensional point pattern
4 points 
2-dimensional space coordinates (x,y)
1-dimensional time coordinates (t)
2 columns of marks: 'age' and 'size' 
> 
>    val <- 20 * runif(4)
>    E <- lapply(val, function(s) { rpoispp(s) })
>    hf <- hyperframe(t=val, e=as.listof(E))
>    Z <- ppx(data=hf, domain=c(0,1))
>    Z
Multidimensional point pattern
4 points 
1-dimensional space coordinates (t)
1 column of marks: 'e' 
Domain:
	[1] 0 1
> 
> 
> 
> cleanEx()
> nameEx("predict.dppm")
> ### * predict.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.dppm
> ### Title: Prediction from a Fitted Determinantal Point Process Model
> ### Aliases: predict.dppm fitted.dppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- dppm(swedishpines ~ x + y, dppGauss())
>   predict(fit)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 96] x [0, 100] units (one unit = 0.1 metres)
> 
> 
> 
> cleanEx()
> nameEx("predict.kppm")
> ### * predict.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.kppm
> ### Title: Prediction from a Fitted Cluster Point Process Model
> ### Aliases: predict.kppm fitted.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   data(redwood)
>   fit <- kppm(redwood ~ x, "Thomas")
>   predict(fit)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [-1, 0] units
> 
> 
> 
> cleanEx()
> nameEx("predict.lppm")
> ### * predict.lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.lppm
> ### Title: Predict Point Process Model on Linear Network
> ### Aliases: predict.lppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <- runiflpp(12, simplenet)
>   fit <- lppm(X ~ x)
>   v <- predict(fit, type="trend")
>   plot(v)
> 
> 
> 
> cleanEx()
> nameEx("predict.mppm")
> ### * predict.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.mppm
> ### Title: Prediction for Fitted Multiple Point Process Model
> ### Aliases: predict.mppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   h <- hyperframe(Bugs=waterstriders)
>   fit <- mppm(Bugs ~ x, data=h, interaction=Strauss(7))
>   # prediction on a grid
>   p <- predict(fit)
>   plot(p$trend)
>   # prediction at specified locations
>   loc <- with(h, runifpoint(20, Window(Bugs)))
>   p2 <- predict(fit, locations=loc)
>   plot(p2$trend)
> 
> 
> 
> cleanEx()
> nameEx("predict.ppm")
> ### * predict.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.ppm
> ### Title: Prediction from a Fitted Point Process Model
> ### Aliases: predict.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   ## Don't show: 
> op <- spatstat.options(npixel=32)
> ## End(Don't show)
>   m <- ppm(cells ~ polynom(x,y,2), Strauss(0.05))
>   trend <- predict(m, type="trend")
>   ## Not run: 
> ##D   image(trend)
> ##D   points(cells)
> ##D   
> ## End(Not run)
>   cif <- predict(m, type="cif")
>   ## Not run: 
> ##D   persp(cif)
> ##D   
> ## End(Not run)
>   mj <- ppm(japanesepines ~ harmonic(x,y,2))
>   se <- predict(mj, se=TRUE) # image of standard error
>   ci <- predict(mj, interval="c") # two images, confidence interval
> 
>   # prediction interval for total number of points
>   predict(mj, type="count", interval="p")
 2.5% 97.5% 
   43    87 
> 
>   # prediction intervals for counts in tiles
>   predict(mj, window=quadrats(japanesepines, 3), type="count", interval="p")
                  2.5% 97.5%
Tile row 1, col 1    2    18
Tile row 1, col 2    2    17
Tile row 1, col 3    0    12
Tile row 2, col 1    0    12
Tile row 2, col 2    1    12
Tile row 2, col 3    0    10
Tile row 3, col 1    0    11
Tile row 3, col 2    1    14
Tile row 3, col 3    0    13
> 
>   # prediction at arbitrary locations
>   predict(mj, locations=data.frame(x=0.3, y=0.4))
[1] 58.75601
> 
>   X <- runifpoint(5, Window(japanesepines))
>   predict(mj, locations=X, se=TRUE)
$estimate
[1] 103.50504 111.61844  67.01643  43.70797  57.28181

$se
[1] 26.249902 31.771742  9.766044 14.343154 21.040187

> 
>   # multitype
>   rr <- matrix(0.06, 2, 2)
>   ma <- ppm(amacrine ~ marks,  MultiStrauss(rr))
>   Z <- predict(ma)
>   Z <- predict(ma, type="cif")
>   predict(ma, locations=data.frame(x=0.8, y=0.5,marks="on"), type="cif")
[1] 33.69773
attr(,"isZero")
[1] FALSE
> 
>   ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("predict.rppm")
> ### * predict.rppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.rppm
> ### Title: Make Predictions From a Recursively Partitioned Point Process
> ###   Model
> ### Aliases: fitted.rppm predict.rppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     fit <- rppm(unmark(gorillas) ~ vegetation, data=gorillas.extra)
>     plot(predict(fit))
>     lambdaX <- fitted(fit)
>     lambdaX[1:5]
           1            2            3            4            5 
9.602489e-06 8.262760e-05 8.262760e-05 9.602489e-06 9.602489e-06 
>     # Mondriaan pictures
>     plot(predict(rppm(redwoodfull ~ x + y)))
>     points(redwoodfull)
> 
> 
> 
> cleanEx()
> nameEx("predict.slrm")
> ### * predict.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.slrm
> ### Title: Predicted or Fitted Values from Spatial Logistic Regression
> ### Aliases: predict.slrm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>   X <- rpoispp(42)
>   fit <- slrm(X ~ x+y)
>   plot(predict(fit))
> 
>   data(copper)
>   X <- copper$SouthPoints
>   Y <- copper$SouthLines
>   Z <- distmap(Y)
>   fitc <- slrm(X ~ Z)
>   pc <- predict(fitc)
> 
>   Znew <- distmap(copper$Lines)[copper$SouthWindow]
>   pcnew <- predict(fitc, newdata=list(Z=Znew))
> 
> 
> 
> cleanEx()
> nameEx("print.im")
> ### * print.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.im
> ### Title: Print Brief Details of an Image
> ### Aliases: print.im
> ### Keywords: spatial print
> 
> ### ** Examples
> 
>   data(letterR)
>   U <- as.im(letterR)
>   U
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
> 
> 
> 
> cleanEx()
> nameEx("print.owin")
> ### * print.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.owin
> ### Title: Print Brief Details of a Spatial Window
> ### Aliases: print.owin
> ### Keywords: spatial print
> 
> ### ** Examples
> 
>   owin()  # the unit square
window: rectangle = [0, 1] x [0, 1] units
> 
>   data(demopat)
>   W <- Window(demopat)
>   W                    # just says it is polygonal
window: polygonal boundary
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
>   as.mask(W)           # just says it is a binary image 
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
> 
> 
> 
> 
> cleanEx()
> nameEx("print.ppm")
> ### * print.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.ppm
> ### Title: Print a Fitted Point Process Model
> ### Aliases: print.ppm
> ### Keywords: spatial print models
> 
> ### ** Examples
> 
>  ## Not run: 
> ##D  m <- ppm(cells, ~1, Strauss(0.05))
> ##D  m
> ##D  
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("print.ppp")
> ### * print.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.ppp
> ### Title: Print Brief Details of a Point Pattern Dataset
> ### Aliases: print.ppp
> ### Keywords: spatial print
> 
> ### ** Examples
> 
>   data(cells)      # plain vanilla point pattern
>   cells
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
> 
>   data(lansing)    # multitype point pattern
>   lansing          
Marked planar point pattern: 2251 points
Multitype, with levels = blackoak, hickory, maple, misc, redoak, whiteoak 
window: rectangle = [0, 1] x [0, 1] units (one unit = 924 feet)
>   
>   data(longleaf)    # numeric marks
>   longleaf          
Marked planar point pattern: 584 points
marks are numeric, of storage type  'double'
window: rectangle = [0, 200] x [0, 200] metres
> 
>   data(demopat)     # weird polygonal window
>   demopat
Marked planar point pattern: 112 points
Multitype, with levels = A, B 
window: polygonal boundary
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
> 
> 
> 
> cleanEx()
> nameEx("print.psp")
> ### * print.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.psp
> ### Title: Print Brief Details of a Line Segment Pattern Dataset
> ### Aliases: print.psp
> ### Keywords: spatial print
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   a
planar line segment pattern: 10 line segments
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("print.quad")
> ### * print.quad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.quad
> ### Title: Print a Quadrature Scheme
> ### Aliases: print.quad
> ### Keywords: spatial print
> 
> ### ** Examples
> 
>  data(cells)
>  Q <- quadscheme(cells)
>  Q
Quadrature scheme (Berman-Turner)
42 data points, 1028 dummy points
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units
     Total weight 1
> 
> 
> 
> cleanEx()
> nameEx("profilepl")
> ### * profilepl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: profilepl
> ### Title: Fit Models by Profile Maximum Pseudolikelihood or AIC
> ### Aliases: profilepl
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     # one irregular parameter
>     rr <- data.frame(r=seq(0.05,0.15, by=0.01))
>     ## Don't show: 
>       rr <- data.frame(r=c(0.05,0.1,0.15))
>     
> ## End(Don't show)
>     ps <- profilepl(rr, Strauss, cells)
(computing rbord)
comparing 3 models...
1, 2,  3.
fitting optimal model...
done.
>     ps
profile log pseudolikelihood
for model:  ppm(cells,  interaction = Strauss)
fitted with rbord = 0.15
interaction: Strauss process
irregular parameter: r in [0.05, 0.15]
optimum value of irregular parameter:  r = 0.1
>     plot(ps)
> 
>     # two irregular parameters
>     rs <- expand.grid(r=seq(0.05,0.15, by=0.01),sat=1:3)
>     ## Don't show: 
>       rs <- expand.grid(r=c(0.07,0.12),sat=1:2)
>     
> ## End(Don't show)
>     pg <- profilepl(rs, Geyer, cells)
(computing rbord)
comparing 4 models...
1, 2, 3,  4.
fitting optimal model...
done.
>     pg
profile log pseudolikelihood
for model:  ppm(cells,  interaction = Geyer)
fitted with rbord = 0.24
interaction: Geyer saturation process
irregular parameters:
 r in [0.07, 0.12]
sat in [1, 2]
optimum values of irregular parameters:
 r = 0.12 and sat = 2
>     as.ppm(pg)
Stationary Geyer saturation process

First order term:  beta = 1682.51

Interaction distance:	0.12
Saturation parameter:	2
Fitted interaction parameter gamma:	 0.2301066

Relevant coefficients:
Interaction 
  -1.469213 

For standard errors, type coef(summary(x))
> 
>     # multitype pattern with a common interaction radius
>     ## Not run: 
> ##D      RR <- data.frame(R=seq(0.03,0.05,by=0.01))
> ##D      MS <- function(R) { MultiStrauss(radii=diag(c(R,R))) }
> ##D      pm <- profilepl(RR, MS, amacrine ~marks)
> ##D     
> ## End(Not run)
>     ## more information 
>     summary(pg)
profile log pseudolikelihood
for model:  ppm(cells,  interaction = Geyer)
fitted with rbord = 0.24
interaction: Geyer saturation process
irregular parameters:
 r in [0.07, 0.12]
sat in [1, 2]
optimum values of irregular parameters:
 r = 0.12 and sat = 2


optimal model:
Stationary Geyer saturation process

First order term:  beta = 1682.51

Interaction distance:	0.12
Saturation parameter:	2
Fitted interaction parameter gamma:	 0.2301066

Relevant coefficients:
Interaction 
  -1.469213 

For standard errors, type coef(summary(x))
> 
> 
> 
> cleanEx()
> nameEx("progressreport")
> ### * progressreport
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: progressreport
> ### Title: Print Progress Reports
> ### Aliases: progressreport
> ### Keywords: print
> 
> ### ** Examples
> 
>   for(i in 1:40) {
+      #
+      # code that does something...
+      # 
+      progressreport(i, 40)
+   }
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,  40.
> 
>   # saving internal state: *recommended*
>   sta <- list()
>   for(i in 1:20) {
+      # some code ...
+      sta <- progressreport(i, 20, state=sta)
+   }
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  20.
> 
>   #' use text progress bar
>   sta <- list()
>   for(i in 1:10) {
+      # some code ...
+      sta <- progressreport(i, 10, state=sta, style="txtbar")
+   }
  |                                                                              |                                                                      |   0%  |                                                                              |========                                                              |  11%  |                                                                              |================                                                      |  22%  |                                                                              |=======================                                               |  33%  |                                                                              |===============================                                       |  44%  |                                                                              |=======================================                               |  56%  |                                                                              |===============================================                       |  67%  |                                                                              |======================================================                |  78%  |                                                                              |==============================================================        |  89%  |                                                                              |======================================================================| 100%
> 
> 
> 
> 
> cleanEx()
> nameEx("project2segment")
> ### * project2segment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: project2segment
> ### Title: Move Point To Nearest Line
> ### Aliases: project2segment
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   X <- rstrat(square(1), 5)
>   Y <- as.psp(matrix(runif(20), 5, 4), window=owin())
>   plot(Y, lwd=3, col="green")
>   plot(X, add=TRUE, col="red", pch=16)
>   v <- project2segment(X,Y)
>   Xproj <- v$Xproj
>   plot(Xproj, add=TRUE, pch=16)
>   arrows(X$x, X$y, Xproj$x, Xproj$y, angle=10, length=0.15, col="red")
> 
> 
> 
> cleanEx()
> nameEx("project2set")
> ### * project2set
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: project2set
> ### Title: Find Nearest Point in a Region
> ### Aliases: project2set
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   He <- heather$fine[owin(c(2.8, 7.4), c(4.0, 7.8))]
>   plot(He, main="project2set")
>   X <- runifpoint(4, erosion(complement.owin(He), 0.2))
>   points(X, col="red")
>   Y <- project2set(X, He)
>   points(Y, col="green")
>   arrows(X$x, X$y, Y$x, Y$y, angle=15, length=0.2)
> 
> 
> 
> cleanEx()
> nameEx("prune.rppm")
> ### * prune.rppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prune.rppm
> ### Title: Prune a Recursively Partitioned Point Process Model
> ### Aliases: prune.rppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   # Murchison gold data
>   mur <- solapply(murchison, rescale, s=1000, unitname="km")
>   mur$dfault <- distfun(mur$faults)
>   fit <- rppm(gold ~ dfault + greenstone, data=mur)
>   fit
Point process model with recursive partitioning
Data: 'gold'
Covariates: 'dfault' and 'greenstone'
Regression tree:
n= 1859 

node), split, n, deviance, yval
      * denotes terminal node

1) root 1859 1643.178000 1.924569e-03  
  2) greenstone< 0.5 1490  373.333200 3.096288e-04  
    4) dfault>=6.291182 1209  114.392900 9.063533e-05  
      8) dfault>=16.78887 842    1.985145 1.429462e-05 *
      9) dfault< 16.78887 367   94.949200 3.013843e-04 *
    5) dfault< 6.291182 281  194.885500 1.399714e-03 *
  3) greenstone>=0.5 369  470.246600 1.567124e-02 *
>   prune(fit, cp=0.1)
Point process model with recursive partitioning
Data: 'gold'
Covariates: 'dfault' and 'greenstone'
Regression tree:
n= 1859 

node), split, n, deviance, yval
      * denotes terminal node

1) root 1859 1643.1780 0.0019245690  
  2) greenstone< 0.5 1490  373.3332 0.0003096288 *
  3) greenstone>=0.5 369  470.2466 0.0156712400 *
> 
> 
> 
> cleanEx()
> nameEx("pseudoR2")
> ### * pseudoR2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pseudoR2
> ### Title: Calculate Pseudo-R-Squared for Point Process Model
> ### Aliases: pseudoR2 pseudoR2.ppm pseudoR2.lppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- ppm(swedishpines ~ x+y)
>   pseudoR2(fit)
[1] 0.002394265
> 
>   xcoord <- as.im(function(x,y) x, Window(swedishpines))
>   fut <- ppm(swedishpines ~ offset(xcoord/200) + y)
>   pseudoR2(fut)
[1] 5.916464e-06
> 
> 
> 
> cleanEx()
> nameEx("psib")
> ### * psib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psib
> ### Title: Sibling Probability of Cluster Point Process
> ### Aliases: psib psib.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- kppm(redwood ~1, "Thomas")
>   psib(fit)
[1] 0.6042143
> 
> 
> 
> cleanEx()
> nameEx("psp")
> ### * psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psp
> ### Title: Create a Line Segment Pattern
> ### Aliases: psp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   m <- data.frame(A=1:10, B=letters[1:10])
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin(), marks=m)
> 
> 
> 
> cleanEx()
> nameEx("psp.object")
> ### * psp.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psp.object
> ### Title: Class of Line Segment Patterns
> ### Aliases: psp.object
> ### Keywords: spatial attribute
> 
> ### ** Examples
> 
> # creating 
>     a <- psp(runif(20),runif(20),runif(20),runif(20), window=owin())
> # converting from other formats
>     a <- as.psp(matrix(runif(80), ncol=4), window=owin())
>     a <- as.psp(data.frame(x0=runif(20), y0=runif(20),
+                             x1=runif(20), y1=runif(20)), window=owin())
> # clipping
>     w <- owin(c(0.1,0.7), c(0.2, 0.8))
>     b <- clip.psp(a, w)
>     b <- a[w]
> # the last two lines are equivalent.
> 
> 
> 
> cleanEx()
> nameEx("psst")
> ### * psst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psst
> ### Title: Pseudoscore Diagnostic For Fitted Model against General
> ###   Alternative
> ### Aliases: psst
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(cells)
>     fit0 <- ppm(cells, ~1) # uniform Poisson
>     ## Don't show: 
> fit0 <- ppm(cells, ~1, nd=8)
> ## End(Don't show)
>     G0 <- psst(fit0, Gest)

Processing 106 quadrature points...1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34.36.38.40
.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74.76.78.80
.82.84.86.88.90.92.94.96.98.100.102.104. 106.
>     G0
Function value object (class 'fv')
for the function r -> bold(R)~Delta~S(r)
................................................................................
       Math.label                
r      r                         
theo   bold(R)~Delta~S[theo](r)  
dat    Sigma~Delta~S(r)          
com    bold(C)~Delta~S(r)        
var    bold(C)^2~Delta~S(r)      
sd     sqrt(bold(C)^2~Delta~S(r))
hi     bold(R)~Delta~S[hi](r)    
lo     bold(R)~Delta~S[lo](r)    
res    bold(R)~Delta~S(r)        
stdres bold(T)~Delta~S(r)        
       Description                                            
r      distance argument r                                    
theo   value 0 corresponding to perfect fit                   
dat    data pseudosum (contribution to bold(R)~Delta~S(r))    
com    model compensator (contribution to bold(R)~Delta~S(r)) 
var    pseudovariance of bold(R)~Delta~S(r)                   
sd     sqrt(pseudovariance) of bold(R)~Delta~S(r)             
hi     upper 2 sigma critical band for bold(R)~Delta~S(r)     
lo     lower 2 sigma critical band for bold(R)~Delta~S(r)     
res    pseudoresidual function bold(R)~Delta~S(r)             
stdres standardised pseudoresidual function bold(R)~Delta~S(r)
................................................................................
Default plot formula:  .~r
where "." stands for 'res', 'hi', 'lo', 'theo'
Recommended range of argument r: [0, 0.29539]
Available range of argument r: [0, 0.29539]
>     if(interactive()) plot(G0)
> 
> 
> 
> cleanEx()
> nameEx("psstA")
> ### * psstA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psstA
> ### Title: Pseudoscore Diagnostic For Fitted Model against Area-Interaction
> ###   Alternative
> ### Aliases: psstA
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    pso <- spatstat.options(psstA.ngrid=16,psstA.nr=10)
>    X <- rStrauss(200,0.1,0.05)
>    plot(psstA(X))
>    plot(psstA(X, interaction=Strauss(0.05)))
>    spatstat.options(pso)
> 
> 
> 
> cleanEx()
> nameEx("psstG")
> ### * psstG
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psstG
> ### Title: Pseudoscore Diagnostic For Fitted Model against Saturation
> ###   Alternative
> ### Aliases: psstG
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    X <- rStrauss(200,0.1,0.05)
>    plot(psstG(X))
>    plot(psstG(X, interaction=Strauss(0.05)))
> 
> 
> 
> cleanEx()
> nameEx("qqplot.ppm")
> ### * qqplot.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qqplot.ppm
> ### Title: Q-Q Plot of Residuals from Fitted Point Process Model
> ### Aliases: qqplot.ppm
> ### Keywords: spatial models hplot
> 
> ### ** Examples
> 
>     data(cells)
> 
>     fit <- ppm(cells, ~1, Poisson())
>     diagnose.ppm(fit)  # no suggestion of departure from stationarity
Model diagnostics (raw residuals)
Diagnostics available:
	four-panel plot
	mark plot 
	smoothed residual field
	x cumulative residuals
	y cumulative residuals
	sum of all residuals
sum of raw residuals in entire window = -6.96e-15
area of entire window = 1
quadrature area = 1
range of smoothed field =  [-28.15, 15.33]
>     ## Not run: qqplot.ppm(fit, 80)  # strong evidence of non-Poisson interaction
>     ## Don't show: 
> qqplot.ppm(fit, 4)
Extracting model information...Evaluating trend...done.
Simulating 4 realisations... 1, 2, 3,  4.

Diagnostic info:
 simulated patterns contained an average of 38.25 points.
Calculating quantiles...averaging.....Done.
> ## End(Don't show)
> 
>     ## Not run: 
> ##D      diagnose.ppm(fit, type="pearson")  
> ##D      qqplot.ppm(fit, type="pearson")
> ##D     
> ## End(Not run)
>     ## Don't show: 
> qqplot.ppm(fit, 4, type="pearson")
Extracting model information...Evaluating trend...done.
Simulating 4 realisations... 1, 2, 3,  4.

Diagnostic info:
 simulated patterns contained an average of 38.75 points.
Calculating quantiles...averaging.....Done.
> ## End(Don't show)
> 
>     ###########################################
>     ## oops, I need the plot coordinates
>     mypreciousdata <- .Last.value
>     ## Not run: mypreciousdata <- qqplot.ppm(fit, type="pearson")
>     ## Don't show: 
> mypreciousdata <- qqplot.ppm(fit, 4, type="pearson")
Extracting model information...Evaluating trend...done.
Simulating 4 realisations... 1, 2, 3,  4.

Diagnostic info:
 simulated patterns contained an average of 48.25 points.
Calculating quantiles...averaging.....Done.
> ## End(Don't show)
>     plot(mypreciousdata)
> 
>     ######################################################
>     # Q-Q plots based on fixed n
>     # The above QQ plots used simulations from the (fitted) Poisson process.
>     # But I want to simulate conditional on n, instead of Poisson
>     # Do this by setting rmhcontrol(p=1)
>     fixit <- list(p=1)
>     ## Not run: qqplot.ppm(fit, 100, control=fixit)
>     ## Don't show: 
> qqplot.ppm(fit, 4, control=fixit)
Extracting model information...Evaluating trend...done.
Simulating 4 realisations... 1, 2, 3,  4.

Diagnostic info:
 simulated patterns contained an average of 42 points.
Calculating quantiles...averaging.....Done.
> ## End(Don't show)
> 
>     ######################################################
>     # Inhomogeneous Poisson data
>     X <- rpoispp(function(x,y){1000 * exp(-3*x)}, 1000)
>     plot(X)
>     # Inhomogeneous Poisson model
>     fit <- ppm(X, ~x, Poisson())
>     ## Not run: qqplot.ppm(fit, 100)
>     ## Don't show: 
> qqplot.ppm(fit, 4)
Extracting model information...Evaluating trend...done.
Simulating 4 realisations... 1, 2, 3,  4.

Diagnostic info:
 simulated patterns contained an average of 341.25 points.
Calculating quantiles...averaging.....Done.
> ## End(Don't show)
>     # conclusion: fitted inhomogeneous Poisson model looks OK
> 
>     ######################################################
>     # Advanced use of 'expr' argument
>     # 
>     # set the initial conditions in Metropolis-Hastings algorithm
>     # 
>     expr <- expression(rmh(fit, start=list(n.start=42), verbose=FALSE))
>     ## Not run: qqplot.ppm(fit, 100, expr)
>     ## Don't show: 
> qqplot.ppm(fit, 4, expr)
Simulating 4 realisations... 1, 2, 3,  4.

Diagnostic info:
 simulated patterns contained an average of 325.25 points.
Calculating quantiles...averaging.....Done.
> ## End(Don't show)
> 
> 
> 
> 
> cleanEx()
> nameEx("quad.ppm")
> ### * quad.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quad.ppm
> ### Title: Extract Quadrature Scheme Used to Fit a Point Process Model
> ### Aliases: quad.ppm
> ### Keywords: spatial manip models
> 
> ### ** Examples
> 
>  fit <- ppm(cells ~1, Strauss(r=0.1))
>  Q <- quad.ppm(fit)
>  ## Not run: plot(Q)
>  npoints(Q$data)
[1] 42
>  npoints(Q$dummy)
[1] 1028
> 
> 
> 
> cleanEx()
> nameEx("quadrat.test")
> ### * quadrat.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadrat.test
> ### Title: Dispersion Test for Spatial Point Pattern Based on Quadrat
> ###   Counts
> ### Aliases: quadrat.test quadrat.test.ppp quadrat.test.ppm
> ###   quadrat.test.quadratcount
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   quadrat.test(simdat)

	Chi-squared test of CSR using quadrat counts

data:  simdat
X2 = 32.822, df = 24, p-value = 0.2158
alternative hypothesis: two.sided

Quadrats: 5 by 5 grid of tiles
>   quadrat.test(simdat, 4, 3)

	Chi-squared test of CSR using quadrat counts

data:  simdat
X2 = 15.65, df = 11, p-value = 0.3093
alternative hypothesis: two.sided

Quadrats: 4 by 3 grid of tiles
> 
>   quadrat.test(simdat, alternative="regular")

	Chi-squared test of CSR using quadrat counts

data:  simdat
X2 = 32.822, df = 24, p-value = 0.8921
alternative hypothesis: regular

Quadrats: 5 by 5 grid of tiles
>   quadrat.test(simdat, alternative="clustered")

	Chi-squared test of CSR using quadrat counts

data:  simdat
X2 = 32.822, df = 24, p-value = 0.1079
alternative hypothesis: clustered

Quadrats: 5 by 5 grid of tiles
> 
>   ## Likelihood ratio test
>   quadrat.test(simdat, CR=0)

	Likelihood ratio test of CSR using quadrat counts
	Test statistic: likelihood ratio test statistic G2
	(p-value obtained from chi-squared distribution)

data:  simdat
G2 = 37.144, df = 24, p-value = 0.08467
alternative hypothesis: two.sided

Quadrats: 5 by 5 grid of tiles
>   ## Power divergence tests
>   quadrat.test(simdat, CR=-1)$p.value
[1] 0.007573415
>   quadrat.test(simdat, CR=-2)$p.value
[1] 1.571774e-05
> 
>   # Using Monte Carlo p-values
>   quadrat.test(swedishpines) # Get warning, small expected values.
Warning: Some expected counts are small; chi^2 approximation may be inaccurate

	Chi-squared test of CSR using quadrat counts

data:  swedishpines
X2 = 18.085, df = 24, p-value = 0.4022
alternative hypothesis: two.sided

Quadrats: 5 by 5 grid of tiles
>   ## Not run: 
> ##D     quadrat.test(swedishpines, method="M", nsim=4999)
> ##D     quadrat.test(swedishpines, method="M", nsim=4999, conditional=FALSE)
> ##D   
> ## End(Not run)
>   ## Don't show: 
>     quadrat.test(swedishpines, method="M", nsim=19)

	Conditional Monte Carlo test of CSR using quadrat counts
	Test statistic: Pearson X2 statistic

data:  swedishpines
X2 = 18.085, p-value = 0.8
alternative hypothesis: two.sided

Quadrats: 5 by 5 grid of tiles
>     quadrat.test(swedishpines, method="M", nsim=19, conditional=FALSE)

	Unconditional Monte Carlo test of CSR using quadrat counts
	Test statistic: Pearson X2 statistic

data:  swedishpines
X2 = 18.085, p-value = 0.6
alternative hypothesis: two.sided

Quadrats: 5 by 5 grid of tiles
>   
> ## End(Don't show)
> 
>   # quadrat counts
>   qS <- quadratcount(simdat, 4, 3)
>   quadrat.test(qS)

	Chi-squared test of CSR using quadrat counts

data:  
X2 = 15.65, df = 11, p-value = 0.3093
alternative hypothesis: two.sided

Quadrats: 4 by 3 grid of tiles
> 
>   # fitted model: inhomogeneous Poisson
>   fitx <- ppm(simdat ~ x)
>   quadrat.test(fitx)

	Chi-squared test of fitted Poisson model 'fitx' using quadrat counts

data:  data from fitx
X2 = 29.215, df = 23, p-value = 0.3466
alternative hypothesis: two.sided

Quadrats: 5 by 5 grid of tiles
> 
>   # an equivalent test (results differ due to discretisation effects):
>   quadrat.test(simdat, lambda=predict(fitx), df.est=length(coef(fitx)))

	Chi-squared test of Poisson process with given intensity using quadrat
	counts

data:  simdat
X2 = 34.064, df = 23, p-value = 0.1285
alternative hypothesis: two.sided

Quadrats: 5 by 5 grid of tiles
> 
>   te <- quadrat.test(simdat, 4)
>   residuals(te)  # Pearson residuals
 [1]  0.76590579  0.76590579  0.76590579 -1.22901161 -1.22901161  1.90585859
 [7]  1.33588219 -0.65903521 -1.22901161 -0.37404701 -0.08905881 -1.22901161
[13] -1.22901161  0.76590579  1.33588219 -0.37404701
> 
>   plot(te)
> 
>   plot(simdat, pch="+", cols="green", lwd=2)
>   plot(te, add=TRUE, col="red", cex=1.4, lty=2, lwd=3)
> 
>   sublab <- eval(substitute(expression(p[chi^2]==z),
+                        list(z=signif(te$p.value,3))))
>   title(sub=sublab, cex.sub=3)
> 
>   # quadrats of irregular shape
>   B <- dirichlet(runifpoint(6, Window(simdat)))
>   qB <- quadrat.test(simdat, tess=B)
>   plot(simdat, main="quadrat.test(simdat, tess=B)", pch="+")
>   plot(qB, add=TRUE, col="red", lwd=2, cex=1.2)
> 
> 
> 
> 
> cleanEx()
> nameEx("quadrat.test.mppm")
> ### * quadrat.test.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadrat.test.mppm
> ### Title: Chi-Squared Test for Multiple Point Process Model Based on
> ###   Quadrat Counts
> ### Aliases: quadrat.test.mppm
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   H <- hyperframe(X=waterstriders)
>   # Poisson with constant intensity for all patterns
>   fit1 <- mppm(X~1, H)
>   quadrat.test(fit1, nx=2)

	Chi-squared test of fitted Poisson model 'fit1' using quadrat counts

data:  fit1
X2 = 1.8596, df = 11, p-value = 0.002137
alternative hypothesis: two.sided

Pooled test
Quadrats of component tests:
List of spatial objects

X1:
2 by 2 grid of tiles

X2:
2 by 2 grid of tiles

X3:
2 by 2 grid of tiles
> 
>   # uniform Poisson with different intensity for each pattern
>   fit2 <- mppm(X ~ id, H)
>   quadrat.test(fit2, nx=2)

	Chi-squared test of fitted Poisson model 'fit2' using quadrat counts

data:  fit2
X2 = 1.8596, df = 9, p-value = 0.01301
alternative hypothesis: two.sided

Pooled test
Quadrats of component tests:
List of spatial objects

X1:
2 by 2 grid of tiles

X2:
2 by 2 grid of tiles

X3:
2 by 2 grid of tiles
> 
> 
> 
> cleanEx()
> nameEx("quadrat.test.splitppp")
> ### * quadrat.test.splitppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadrat.test.splitppp
> ### Title: Dispersion Test of CSR for Split Point Pattern Based on Quadrat
> ###   Counts
> ### Aliases: quadrat.test.splitppp
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>  data(humberside)
>  qH <- quadrat.test(split(humberside), 2, 3)
Warning: Some expected counts are small; chi^2 approximation may be inaccurate
Warning: Some expected counts are small; chi^2 approximation may be inaccurate
>  plot(qH)
>  qH

	Chi-squared test of CSR using quadrat counts

data:  split(humberside)
X2 = 285.41, df = 10, p-value < 2.2e-16
alternative hypothesis: two.sided

Pooled test
Quadrats of component tests:
List of spatial objects

case:
6 tiles (irregular windows)

control:
6 tiles (irregular windows)
> 
> 
> 
> cleanEx()
> nameEx("quadratcount")
> ### * quadratcount
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadratcount
> ### Title: Quadrat counting for a point pattern
> ### Aliases: quadratcount quadratcount.ppp quadratcount.splitppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>  X <- runifpoint(50)
>  quadratcount(X)
           x
y           [0,0.2) [0.2,0.4) [0.4,0.6) [0.6,0.8) [0.8,1]
  [0.8,1]         1         5         1         2       0
  [0.6,0.8)       0         0         2         6       3
  [0.4,0.6)       2         2         3         3       0
  [0.2,0.4)       3         2         2         3       4
  [0,0.2)         1         2         1         1       1
>  quadratcount(X, 4, 5)
           x
y           [0,0.25) [0.25,0.5) [0.5,0.75) [0.75,1]
  [0.8,1]          3          3          2        1
  [0.6,0.8)        0          0          4        7
  [0.4,0.6)        2          4          4        0
  [0.2,0.4)        3          4          3        4
  [0,0.2)          2          2          1        1
>  quadratcount(X, xbreaks=c(0, 0.3, 1), ybreaks=c(0, 0.4, 0.8, 1))
           x
y           [0,0.3) [0.3,1]
  [0.8,1]         3       6
  [0.4,0.8)       4      17
  [0,0.4)         5      15
>  qX <-  quadratcount(X, 4, 5)
> 
>  # plotting:
>  plot(X, pch="+")
>  plot(qX, add=TRUE, col="red", cex=1.5, lty=2)
> 
>  # irregular window
>  data(humberside)
>  plot(humberside)
>  qH <- quadratcount(humberside, 2, 3)
>  plot(qH, add=TRUE, col="blue", cex=1.5, lwd=2)
> 
>  # multitype - split
>  plot(quadratcount(split(humberside), 2, 3))
>  
>  # quadrats determined by tessellation:
>  B <- dirichlet(runifpoint(6))
>  qX <- quadratcount(X, tess=B)
>  plot(X, pch="+")
>  plot(qX, add=TRUE, col="red", cex=1.5, lty=2)
> 
> 
> 
> cleanEx()
> nameEx("quadratresample")
> ### * quadratresample
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadratresample
> ### Title: Resample a Point Pattern by Resampling Quadrats
> ### Aliases: quadratresample
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   data(bei)
>   quadratresample(bei, 6, 3)
Planar point pattern: 3604 points
window: rectangle = [0, 1000] x [0, 500] metres
> 
> 
> 
> cleanEx()
> nameEx("quadrats")
> ### * quadrats
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadrats
> ### Title: Divide Region into Quadrats
> ### Aliases: quadrats
> ### Keywords: utilities datagen
> 
> ### ** Examples
> 
>  W <- square(10)
>  Z <- quadrats(W, 4, 5)
>  plot(Z)
> 
>  data(letterR)
>  plot(quadrats(letterR, 5, 7))
> 
> 
> 
> cleanEx()
> nameEx("quadscheme")
> ### * quadscheme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadscheme
> ### Title: Generate a Quadrature Scheme from a Point Pattern
> ### Aliases: quadscheme
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   data(simdat)
> 
>   # grid weights
>   Q <- quadscheme(simdat)
>   Q <- quadscheme(simdat, method="grid")
>   Q <- quadscheme(simdat, eps=0.5)         # dummy point spacing 0.5 units
> 
>   Q <- quadscheme(simdat, nd=50)           # 1 dummy point per tile
>   Q <- quadscheme(simdat, ntile=25, nd=50) # 4 dummy points per tile
> 
>   # Dirichlet weights
>   Q <- quadscheme(simdat, method="dirichlet", exact=FALSE)
> 
>   # random dummy pattern
>   ## Not run: 
> ##D   D <- runifpoint(250, Window(simdat))
> ##D   Q <- quadscheme(simdat, D, method="dirichlet", exact=FALSE)
> ##D   
> ## End(Not run)
> 
>   # polygonal window
>   data(demopat)
>   X <- unmark(demopat)
>   Q <- quadscheme(X)
> 
>   # mask window
>   Window(X) <- as.mask(Window(X))
>   Q <- quadscheme(X)
>   
> 
> 
> 
> cleanEx()
> nameEx("quadscheme.logi")
> ### * quadscheme.logi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadscheme.logi
> ### Title: Generate a Logistic Regression Quadrature Scheme from a Point
> ###   Pattern
> ### Aliases: quadscheme.logi
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   data(simdat)
> 
>   Q <- quadscheme.logi(simdat)
> 
> 
> 
> cleanEx()
> nameEx("quantess")
> ### * quantess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quantess
> ### Title: Quantile Tessellation
> ### Aliases: quantess quantess.owin quantess.ppp quantess.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   plot(quantess(letterR, "x", 5))
> 
>   plot(quantess(bronzefilter, "x", 6))
>   points(unmark(bronzefilter))
> 
>   plot(quantess(letterR, "rad", 7, origin=c(2.8, 1.5)))
>   plot(quantess(letterR, "ang", 7, origin=c(2.8, 1.5)))
> 
>   opa <- par(mar=c(0,0,2,5))
>   A <- quantess(Window(bei), bei.extra$elev, 4)
>   plot(A, ribargs=list(las=1))
>   
>   B <- quantess(bei, bei.extra$elev, 4)
>   tilenames(B) <- paste(spatstat.utils::ordinal(1:4), "quartile")
>   plot(B, ribargs=list(las=1))
>   points(bei, pch=".", cex=2, col="white")
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("quantile.density")
> ### * quantile.density
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quantile.density
> ### Title: Quantiles of a Density Estimate
> ### Aliases: quantile.density
> ### Keywords: methods univar nonparametric
> 
> ### ** Examples
> 
>    dd <- density(runif(10))
>    quantile(dd)
        0%        25%        50%        75%       100% 
-0.4759594  0.2828651  0.5664661  0.8232401  1.4824209 
> 
> 
> 
> cleanEx()
> nameEx("quantile.ewcdf")
> ### * quantile.ewcdf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quantile.ewcdf
> ### Title: Quantiles of Weighted Empirical Cumulative Distribution Function
> ### Aliases: quantile.ewcdf
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   z <- rnorm(50)
>   w <- runif(50)
>   Fun <- ewcdf(z, w)
>   quantile(Fun, c(0.95,0.99))
     95%      99% 
1.511781 1.595281 
> 
> 
> 
> cleanEx()
> nameEx("quantile.im")
> ### * quantile.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quantile.im
> ### Title: Sample Quantiles of Pixel Image
> ### Aliases: quantile.im
> ### Keywords: spatial methods univar
> 
> ### ** Examples
> 
> # artificial image data
> Z <- setcov(square(1))
> 
> # find the quartiles
> quantile(Z)
       0%       25%       50%       75%      100% 
0.0000000 0.0657959 0.1845703 0.3803711 1.0000000 
> 
> # find the deciles
> quantile(Z, probs=(0:10)/10)
        0%        10%        20%        30%        40%        50%        60% 
0.00000000 0.01867676 0.04785156 0.08496094 0.13012695 0.18457031 0.24993896 
       70%        80%        90%       100% 
0.33154297 0.43603516 0.58593750 1.00000000 
> 
> 
> 
> cleanEx()
> nameEx("quasirandom")
> ### * quasirandom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quasirandom
> ### Title: Quasirandom Patterns
> ### Aliases: quasirandom vdCorput Halton Hammersley
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    vdCorput(10, 2)
 [1] 0.5000 0.2500 0.7500 0.1250 0.6250 0.3750 0.8750 0.0625 0.5625 0.3125
> 
>    plot(Halton(256, c(2,3)))
> 
>    plot(Hammersley(256, 3))
> 
> 
> 
> cleanEx()
> nameEx("rCauchy")
> ### * rCauchy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rCauchy
> ### Title: Simulate Neyman-Scott Point Process with Cauchy cluster kernel
> ### Aliases: rCauchy
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # homogeneous
>  X <- rCauchy(30, 0.01, 5)
>  # inhomogeneous
>  ff <- function(x,y){ exp(2 - 3 * abs(x)) }
>  Z <- as.im(ff, W= owin())
>  Y <- rCauchy(50, 0.01, Z)
>  YY <- rCauchy(ff, 0.01, 5)
> 
> 
> 
> cleanEx()
> nameEx("rDGS")
> ### * rDGS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rDGS
> ### Title: Perfect Simulation of the Diggle-Gates-Stibbard Process
> ### Aliases: rDGS
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rDGS(50, 0.05)
>    Z <- rDGS(50, 0.03, nsim=2)
> 
> 
> 
> cleanEx()
> nameEx("rDiggleGratton")
> ### * rDiggleGratton
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rDiggleGratton
> ### Title: Perfect Simulation of the Diggle-Gratton Process
> ### Aliases: rDiggleGratton
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rDiggleGratton(50, 0.02, 0.07)
>    Z <- rDiggleGratton(50, 0.02, 0.07, 2, nsim=2)
> 
> 
> 
> cleanEx()
> nameEx("rGaussPoisson")
> ### * rGaussPoisson
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rGaussPoisson
> ### Title: Simulate Gauss-Poisson Process
> ### Aliases: rGaussPoisson
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  pp <- rGaussPoisson(30, 0.07, 0.5)
> 
> 
> 
> cleanEx()
> nameEx("rHardcore")
> ### * rHardcore
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rHardcore
> ### Title: Perfect Simulation of the Hardcore Process
> ### Aliases: rHardcore
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rHardcore(0.05,1.5,square(141.4))
>    Z <- rHardcore(100,0.05, nsim=2)
> 
> 
> 
> cleanEx()
> nameEx("rLGCP")
> ### * rLGCP
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rLGCP
> ### Title: Simulate Log-Gaussian Cox Process
> ### Aliases: rLGCP
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   if(require(RandomFields)) {
+   # homogeneous LGCP with exponential covariance function
+   X <- rLGCP("exp", 3, var=0.2, scale=.1)
+ 
+   # inhomogeneous LGCP with Gaussian covariance function
+   m <- as.im(function(x, y){5 - 1.5 * (x - 0.5)^2 + 2 * (y - 0.5)^2}, W=owin())
+   X <- rLGCP("gauss", m, var=0.15, scale =0.5)
+   plot(attr(X, "Lambda"))
+   points(X)
+ 
+   # inhomogeneous LGCP with Matern covariance function
+   X <- rLGCP("matern", function(x, y){ 1 - 0.4 * x},
+              var=2, scale=0.7, nu=0.5,
+              win = owin(c(0, 10), c(0, 10)))
+   plot(X)
+   }
Loading required package: RandomFields
Loading required package: sp
Loading required package: RandomFieldsUtils

Attaching package: 'RandomFields'

The following object is masked from 'package:RandomFieldsUtils':

    RFoptions

The following object is masked from 'package:nlme':

    Variogram

> 
> 
> 
> cleanEx()

detaching 'package:RandomFields', 'package:RandomFieldsUtils',
  'package:sp'

> nameEx("rMatClust")
> ### * rMatClust
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rMatClust
> ### Title: Simulate Matern Cluster Process
> ### Aliases: rMatClust
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # homogeneous
>  X <- rMatClust(10, 0.05, 4)
>  # inhomogeneous
>  ff <- function(x,y){ 4 * exp(2 * abs(x) - 1) }
>  Z <- as.im(ff, owin())
>  Y <- rMatClust(10, 0.05, Z)
>  YY <- rMatClust(ff, 0.05, 3)
> 
> 
> 
> cleanEx()
> nameEx("rMaternI")
> ### * rMaternI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rMaternI
> ### Title: Simulate Matern Model I
> ### Aliases: rMaternI
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  X <- rMaternI(20, 0.05)
>  Y <- rMaternI(20, 0.05, stationary=FALSE)
> 
> 
> 
> cleanEx()
> nameEx("rMaternII")
> ### * rMaternII
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rMaternII
> ### Title: Simulate Matern Model II
> ### Aliases: rMaternII
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  X <- rMaternII(20, 0.05)
>  Y <- rMaternII(20, 0.05, stationary=FALSE)
> 
> 
> 
> cleanEx()
> nameEx("rMosaicField")
> ### * rMosaicField
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rMosaicField
> ### Title: Mosaic Random Field
> ### Aliases: rMosaicField
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rpoislinetess(3)
>    plot(rMosaicField(X, runif))
>    plot(rMosaicField(X, runif, dimyx=256))
>    plot(rMosaicField(X, rnorm, rgenargs=list(mean=10, sd=2)))
> 
>    plot(rMosaicField(dirichlet(runifpoint(30)), rnorm))
> 
> 
> 
> cleanEx()
> nameEx("rMosaicSet")
> ### * rMosaicSet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rMosaicSet
> ### Title: Mosaic Random Set
> ### Aliases: rMosaicSet
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    # Switzer's random set
>    X <- rpoislinetess(3)
>    plot(rMosaicSet(X, 0.5), col="green", border=NA)
> 
>    # another example
>    plot(rMosaicSet(dirichlet(runifpoint(30)), 0.4))
> 
> 
> 
> cleanEx()
> nameEx("rNeymanScott")
> ### * rNeymanScott
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rNeymanScott
> ### Title: Simulate Neyman-Scott Process
> ### Aliases: rNeymanScott
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   # each cluster consist of 10 points in a disc of radius 0.2
>   nclust <- function(x0, y0, radius, n) {
+               return(runifdisc(n, radius, centre=c(x0, y0)))
+             }
>   plot(rNeymanScott(10, 0.2, nclust, radius=0.2, n=5))
> 
>   # multitype Neyman-Scott process (each cluster is a multitype process)
>   nclust2 <- function(x0, y0, radius, n, types=c("a", "b")) {
+      X <- runifdisc(n, radius, centre=c(x0, y0))
+      M <- sample(types, n, replace=TRUE)
+      marks(X) <- M
+      return(X)
+   }
>   plot(rNeymanScott(15,0.1,nclust2, radius=0.1, n=5))
> 
> 
> 
> cleanEx()
> nameEx("rPenttinen")
> ### * rPenttinen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rPenttinen
> ### Title: Perfect Simulation of the Penttinen Process
> ### Aliases: rPenttinen
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rPenttinen(50, 0.5, 0.02)
>    Z <- rPenttinen(50, 0.5, 0.01, nsim=2)
> 
> 
> 
> cleanEx()
> nameEx("rPoissonCluster")
> ### * rPoissonCluster
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rPoissonCluster
> ### Title: Simulate Poisson Cluster Process
> ### Aliases: rPoissonCluster
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   # each cluster consist of 10 points in a disc of radius 0.2
>   nclust <- function(x0, y0, radius, n) {
+               return(runifdisc(n, radius, centre=c(x0, y0)))
+             }
>   plot(rPoissonCluster(10, 0.2, nclust, radius=0.2, n=5))
> 
>   # multitype Neyman-Scott process (each cluster is a multitype process)
>   nclust2 <- function(x0, y0, radius, n, types=c("a", "b")) {
+      X <- runifdisc(n, radius, centre=c(x0, y0))
+      M <- sample(types, n, replace=TRUE)
+      marks(X) <- M
+      return(X)
+   }
>   plot(rPoissonCluster(15,0.1,nclust2, radius=0.1, n=5))
> 
> 
> 
> cleanEx()
> nameEx("rQuasi")
> ### * rQuasi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rQuasi
> ### Title: Generate Quasirandom Point Pattern in Given Window
> ### Aliases: rQuasi
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    plot(rQuasi(256, letterR))
> 
> 
> 
> cleanEx()
> nameEx("rSSI")
> ### * rSSI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rSSI
> ### Title: Simulate Simple Sequential Inhibition
> ### Aliases: rSSI
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  Vinf <- rSSI(0.07)
> 
>  V100 <- rSSI(0.07, 100)
> 
>  X <- runifpoint(100)
>  Y <- rSSI(0.03,142,x.init=X) # Y consists of X together with
>                               # 42 added points.
>  plot(Y, main="rSSI")
>  plot(X,add=TRUE,chars=20,cols="red")
> 
>  ## inhomogeneous
>  Z <- rSSI(0.07, 50, f=function(x,y){x})
>  plot(Z)
> 
> 
> 
> cleanEx()
> nameEx("rStrauss")
> ### * rStrauss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rStrauss
> ### Title: Perfect Simulation of the Strauss Process
> ### Aliases: rStrauss
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rStrauss(0.05,0.2,1.5,square(141.4))
>    Z <- rStrauss(100,0.7,0.05, nsim=2)
> 
> 
> 
> cleanEx()
> nameEx("rStraussHard")
> ### * rStraussHard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rStraussHard
> ### Title: Perfect Simulation of the Strauss-Hardcore Process
> ### Aliases: rStraussHard
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    Z <- rStraussHard(100,0.7,0.05,0.02)
>    Y <- rStraussHard(100,0.7,0.05,0.01, nsim=2)
> 
> 
> 
> cleanEx()
> nameEx("rSwitzerlpp")
> ### * rSwitzerlpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rSwitzerlpp
> ### Title: Switzer-type Point Process on Linear Network
> ### Aliases: rSwitzerlpp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    plot(rSwitzerlpp(domain(spiders), 0.01, rate=100))
> 
>    plot(rSwitzerlpp(domain(spiders), 0.0005, rate=100, cuts="l"))
> 
> 
> 
> cleanEx()
> nameEx("rThomas")
> ### * rThomas
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rThomas
> ### Title: Simulate Thomas Process
> ### Aliases: rThomas
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   #homogeneous
>   X <- rThomas(10, 0.2, 5)
>   #inhomogeneous
>   Z <- as.im(function(x,y){ 5 * exp(2 * x - 1) }, owin())
>   Y <- rThomas(10, 0.2, Z)
> 
> 
> 
> cleanEx()
> nameEx("rVarGamma")
> ### * rVarGamma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rVarGamma
> ### Title: Simulate Neyman-Scott Point Process with Variance Gamma cluster
> ###   kernel
> ### Aliases: rVarGamma
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # homogeneous
>  X <- rVarGamma(30, 2, 0.02, 5)
>  # inhomogeneous
>  ff <- function(x,y){ exp(2 - 3 * abs(x)) }
>  Z <- as.im(ff, W= owin())
>  Y <- rVarGamma(30, 2, 0.02, Z)
>  YY <- rVarGamma(ff, 2, 0.02, 3)
> 
> 
> 
> cleanEx()
> nameEx("rags")
> ### * rags
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rags
> ### Title: Alternating Gibbs Sampler for Multitype Point Processes
> ### Aliases: rags
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   mo <- list(beta=c(30, 20),
+              hradii = 0.05 * matrix(c(0,1,1,0), 2, 2))
>   rags(mo, ncycles=10)
Marked planar point pattern: 43 points
Multitype, with levels = 1, 2 
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("ragsAreaInter")
> ### * ragsAreaInter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ragsAreaInter
> ### Title: Alternating Gibbs Sampler for Area-Interaction Process
> ### Aliases: ragsAreaInter
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    plot(ragsAreaInter(100, 2, 0.07, ncycles=15))
> 
> 
> 
> cleanEx()
> nameEx("ragsMultiHard")
> ### * ragsMultiHard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ragsMultiHard
> ### Title: Alternating Gibbs Sampler for Multitype Hard Core Process
> ### Aliases: ragsMultiHard
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   b <- c(30,20)
>   h <- 0.05 * matrix(c(0,1,1,0), 2, 2)
>   ragsMultiHard(b, h, ncycles=10)
Marked planar point pattern: 43 points
Multitype, with levels = 1, 2 
window: rectangle = [0, 1] x [0, 1] units
>   ragsMultiHard(b, h, ncycles=5, periodic=TRUE)
Marked planar point pattern: 39 points
Multitype, with levels = 1, 2 
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("ranef.mppm")
> ### * ranef.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ranef.mppm
> ### Title: Extract Random Effects from Point Process Model
> ### Aliases: ranef.mppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>  H <- hyperframe(Y = waterstriders)
>  # Tweak data to exaggerate differences
>  H$Y[[1]] <- rthin(H$Y[[1]], 0.3)
> 
>  m1 <- mppm(Y ~ id,  data=H, Strauss(7))
>  ranef(m1)
data frame with 0 columns and 3 rows
>  m2 <- mppm(Y ~ 1,  random=~1|id, data=H, Strauss(7))
iteration 1 
iteration 2 
iteration 3 
>  ranef(m2)
  (Intercept)
1  -0.5817398
2   0.2447232
3   0.3370166
> 
> 
> 
> cleanEx()
> nameEx("range.fv")
> ### * range.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: range.fv
> ### Title: Range of Function Values
> ### Aliases: range.fv max.fv min.fv
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    G <- Gest(cells)
>    range(G)
[1] 0 1
>    max(G)
[1] 1
>    min(G)
[1] 0
> 
> 
> 
> cleanEx()
> nameEx("raster.x")
> ### * raster.x
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: raster.x
> ### Title: Cartesian Coordinates for a Pixel Raster
> ### Aliases: raster.x raster.y raster.xy
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   u <- owin(c(-1,1),c(-1,1)) # square of side 2
>   w <- as.mask(u, eps=0.01) # 200 x 200 grid
>   X <- raster.x(w)
>   Y <- raster.y(w)
>   disc <- owin(c(-1,1), c(-1,1), mask=(X^2 + Y^2 <= 1))
>   ## Not run: plot(disc)
>   # approximation to the unit disc
> 
> 
> 
> cleanEx()
> nameEx("rcell")
> ### * rcell
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rcell
> ### Title: Simulate Baddeley-Silverman Cell Process
> ### Aliases: rcell
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   X <- rcell(nx=15)
>   plot(X)
>   plot(Kest(X))
> 
> 
> 
> cleanEx()
> nameEx("rcelllpp")
> ### * rcelllpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rcelllpp
> ### Title: Simulate Cell Process on Linear Network
> ### Aliases: rcelllpp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rcelllpp(domain(spiders), 0.01)
>    plot(X)
>    plot(linearK(X))
> 
> 
> 
> cleanEx()
> nameEx("rcellnumber")
> ### * rcellnumber
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rcellnumber
> ### Title: Generate Random Numbers of Points for Cell Process
> ### Aliases: rcellnumber
> ### Keywords: datagen
> 
> ### ** Examples
> 
>    rcellnumber(30, 3)
 [1] 0 1 1 3 0 3 3 1 1 0 0 0 1 1 1 1 1 3 1 1 3 0 1 0 0 1 0 1 3 1
> 
> 
> 
> cleanEx()
> nameEx("rdpp")
> ### * rdpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rdpp
> ### Title: Simulation of a Determinantal Point Process
> ### Aliases: rdpp
> ### Keywords: datagen spatial models
> 
> ### ** Examples
> 
> index <- expand.grid(-2:2,-2:2)
> eig <- exp(-rowSums(index^2))
> X <- rdpp(eig, index)
> X
Planar point pattern: 6 points
window: rectangle = [0, 1] x [0, 1] units
> ## To simulate a det. projection p. p. with the given indices set eig=1:
> XX <- rdpp(1, index)
> XX
Planar point pattern: 25 points
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("reach")
> ### * reach
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reach
> ### Title: Interaction Distance of a Point Process
> ### Aliases: reach reach.ppm reach.interact reach.fii reach.rmhmodel
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     reach(Poisson())
[1] 0
>     # returns 0
> 
>     reach(Strauss(r=7))
[1] 7
>     # returns 7
>     fit <- ppm(swedishpines ~ 1, Strauss(r=7))
>     reach(fit)
[1] 7
>     # returns 7
> 
>     reach(OrdThresh(42))
[1] Inf
>     # returns Inf
>     
>     reach(MultiStrauss(matrix(c(1,3,3,1),2,2)))
[1] 3
>     # returns 3
> 
> 
> 
> cleanEx()
> nameEx("reach.dppm")
> ### * reach.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reach.dppm
> ### Title: Range of Interaction for a Determinantal Point Process Model
> ### Aliases: reach.dppm reach.detpointprocfamily
> ### Keywords: spatial models
> 
> ### ** Examples
> 
> reach(dppMatern(lambda=100, alpha=.01, nu=1, d=2))
[1] 0.02828427
> 
> 
> 
> cleanEx()
> nameEx("reach.kppm")
> ### * reach.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reach.kppm
> ### Title: Range of Interaction for a Cox or Cluster Point Process Model
> ### Aliases: reach.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- kppm(redwood ~ 1)
>   reach(fit)
[1] 0.3763688
> 
> 
> 
> cleanEx()
> nameEx("rectcontact")
> ### * rectcontact
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rectcontact
> ### Title: Contact Distribution Function using Rectangular Structuring
> ###   Element
> ### Aliases: rectcontact
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>   ## make an image which is TRUE/FALSE inside/outside the letter R
>   V <- letterR
>   Frame(V) <- grow.rectangle(Frame(V), 0.5)
>   Z <- as.im(V, value=TRUE, na.replace=FALSE)
>   ## analyse
>   plot(rectcontact(Z))
> 
> 
> 
> cleanEx()
> nameEx("rectdistmap")
> ### * rectdistmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rectdistmap
> ### Title: Distance Map Using Rectangular Distance Metric
> ### Aliases: rectdistmap
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   V <- letterR
>   Frame(V) <- grow.rectangle(Frame(V), 0.5)
>   plot(rectdistmap(V))
> 
> 
> 
> cleanEx()
> nameEx("reflect")
> ### * reflect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reflect
> ### Title: Reflect In Origin
> ### Aliases: reflect reflect.im reflect.default
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   plot(reflect(as.im(letterR)))
>   plot(reflect(letterR), add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("regularpolygon")
> ### * regularpolygon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: regularpolygon
> ### Title: Create A Regular Polygon
> ### Aliases: regularpolygon hexagon
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   plot(hexagon())
>   plot(regularpolygon(7))
>   plot(regularpolygon(7, align="left"))
> 
> 
> 
> cleanEx()
> nameEx("relevel.im")
> ### * relevel.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relevel.im
> ### Title: Reorder Levels of a Factor-Valued Image or Pattern
> ### Aliases: relevel.im relevel.ppp relevel.ppx
> ### Keywords: manip spatial
> 
> ### ** Examples
> 
>   amacrine
Marked planar point pattern: 294 points
Multitype, with levels = off, on 
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
>   relevel(amacrine, "on")
Marked planar point pattern: 294 points
Multitype, with levels = on, off 
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
> 
> 
> 
> cleanEx()
> nameEx("reload.or.compute")
> ### * reload.or.compute
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reload.or.compute
> ### Title: Compute Unless Previously Saved
> ### Aliases: reload.or.compute
> ### Keywords: utilities
> 
> ### ** Examples
> 
>    ## Not run: 
> ##D     if(FALSE) {
> ##D      reload.or.compute("mydata.rda", {
> ##D         x <- very.long.computation()
> ##D         y <- 42
> ##D       })
> ##D    }
> ##D    
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("relrisk.lpp")
> ### * relrisk.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relrisk.lpp
> ### Title: Nonparametric Estimate of Spatially-Varying Relative Risk on a
> ###   Network
> ### Aliases: relrisk.lpp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    ## case-control data: 2 types of points
>    set.seed(2020)
>    X <- superimpose(A=runiflpp(20, simplenet),
+                     B=runifpointOnLines(20, as.psp(simplenet)[1]))
>    plot(X)
>    plot(relrisk(X, 0.2))
>    plot(relrisk(X, 0.2, case="B"))
>    head(relrisk(X, 0.2, at="points"))
[1] 0.00938563 0.17263203 0.03074979 0.44332234 0.71989714 0.88051337
>    ## cross-validated bandwidth selection
>    plot(relrisk(X, bw.relrisklpp, hmax=0.3))
> 
>    ## more than 2 types
>    if(interactive()) {
+      U <- chicago
+      sig <- 170
+    } else {
+      U <- do.call(superimpose,
+                   split(chicago)[c("theft", "cartheft", "burglary")])
+      sig <- 50
+    }
>    plot(relrisk(U, sig))
>    head(relrisk(U, sig, at="points"))
         theft     cartheft     burglary
[1,] 0.9379407 3.853405e-05 6.202075e-02
[2,] 0.9973916 8.324656e-04 1.775910e-03
[3,] 0.9986423 4.202711e-04 9.374608e-04
[4,] 0.0000000 1.000000e+00 3.431691e-19
[5,] 0.9592679 1.248433e-36 4.073206e-02
[6,] 0.9876792 3.413544e-23 1.232078e-02
>    plot(relrisk(U, sig, relative=TRUE, control="theft"))
> 
> 
> 
> cleanEx()
> nameEx("relrisk.ppm")
> ### * relrisk.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relrisk.ppm
> ### Title: Parametric Estimate of Spatially-Varying Relative Risk
> ### Aliases: relrisk.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- ppm(chorley ~ marks * (x+y))
>   rr <- relrisk(fit, relative=TRUE, control="lung", se=TRUE)
>   plot(rr$estimate)
>   plot(rr$SE)
>   rrX <- relrisk(fit, at="points", relative=TRUE, control="lung")
> 
> 
> 
> cleanEx()
> nameEx("relrisk.ppp")
> ### * relrisk.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relrisk.ppp
> ### Title: Nonparametric Estimate of Spatially-Varying Relative Risk
> ### Aliases: relrisk.ppp
> ### Keywords: spatial methods smooth
> 
> ### ** Examples
> 
>    p.oak <- relrisk(urkiola, 20)
>    if(interactive()) {
+       plot(p.oak, main="proportion of oak")
+       plot(eval.im(p.oak > 0.3), main="More than 30 percent oak")
+       plot(split(lansing), main="Lansing Woods")
+       p.lan <- relrisk(lansing, 0.05, se=TRUE)
+       plot(p.lan$estimate, main="Lansing Woods species probability")
+       plot(p.lan$SE, main="Lansing Woods standard error")
+       wh <- im.apply(p.lan$estimate, which.max)
+       types <- levels(marks(lansing))
+       wh <- eval.im(types[wh])
+       plot(wh, main="Most common species")
+    }
> 
> 
> 
> cleanEx()
> nameEx("repul")
> ### * repul
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: repul.dppm
> ### Title: Repulsiveness Index of a Determinantal Point Process Model
> ### Aliases: repul repul.dppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   jpines <- residualspaper$Fig1
>   ## Don't show: 
>      # smaller dataset for testing
>     jpines <- jpines[c(TRUE,FALSE)]
>   
> ## End(Don't show)
>   fit <- dppm(jpines ~ 1, dppGauss)
>   repul(fit)
[1] 0.05221107
> 
> 
> 
> cleanEx()
> nameEx("requireversion")
> ### * requireversion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: requireversion
> ### Title: Require a Specific Version of a Package
> ### Aliases: requireversion
> ### Keywords: environment
> 
> ### ** Examples
> 
>   requireversion(spatstat, "1.42-0")
>   requireversion(spatstat, "999.999-999", fatal=FALSE)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("rescale.im")
> ### * rescale.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale.im
> ### Title: Convert Pixel Image to Another Unit of Length
> ### Aliases: rescale.im
> ### Keywords: spatial math
> 
> ### ** Examples
> 
> # Bramble Canes data: 1 unit = 9 metres
>   data(bramblecanes)
> # distance transform
>   Z <- distmap(bramblecanes)
> # convert to metres
> # first alter the pixel values
>   Zm <- eval.im(9 * Z)
> # now rescale the pixel coordinates
>   Z <- rescale(Zm, 1/9)
> # or equivalently
>   Z <- rescale(Zm)
> 
> 
> 
> cleanEx()
> nameEx("rescale.owin")
> ### * rescale.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale.owin
> ### Title: Convert Window to Another Unit of Length
> ### Aliases: rescale.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(swedishpines)
>   W <- Window(swedishpines)
>   W
window: rectangle = [0, 96] x [0, 100] units (one unit = 0.1 metres)
> # coordinates are in decimetres (0.1 metre)
> # convert to metres:
>   rescale(W, 10)
window: rectangle = [0, 9.6] x [0, 10] metres
> # or equivalently
>   rescale(W)
window: rectangle = [0, 9.6] x [0, 10] metres
> 
> 
> 
> cleanEx()
> nameEx("rescale.ppp")
> ### * rescale.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale.ppp
> ### Title: Convert Point Pattern to Another Unit of Length
> ### Aliases: rescale.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
> # Bramble Canes data: 1 unit = 9 metres
>   data(bramblecanes)
> # convert to metres
>   bram <- rescale(bramblecanes, 1/9)
> # or equivalently
>   bram <- rescale(bramblecanes)
> 
> 
> 
> cleanEx()
> nameEx("rescale.psp")
> ### * rescale.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale.psp
> ### Title: Convert Line Segment Pattern to Another Unit of Length
> ### Aliases: rescale.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    data(copper)
>    X <- copper$Lines
>    X
planar line segment pattern: 146 line segments
window: rectangle = [-0.335, 70.11] x [0.19, 158.233] km
>    # data are in km
>    # convert to metres
>    rescale(X, 1/1000)
planar line segment pattern: 146 line segments
window: rectangle = [-335, 70110] x [190, 158233] units (one unit = 0.001 km)
> 
>    # convert data and rename unit
>    rescale(X, 1/1000, c("metre", "metres"))
planar line segment pattern: 146 line segments
window: rectangle = [-335, 70110] x [190, 158233] metres
> 
> 
> 
> cleanEx()
> nameEx("rescue.rectangle")
> ### * rescue.rectangle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescue.rectangle
> ### Title: Convert Window Back To Rectangle
> ### Aliases: rescue.rectangle
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   w <- owin(poly=list(x=c(0,1,1,0),y=c(0,0,1,1)))
>   rw <- rescue.rectangle(w)
> 
>   w <- as.mask(unit.square())
>   rw <- rescue.rectangle(w)
> 
> 
> 
> cleanEx()
> nameEx("residuals.dppm")
> ### * residuals.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: residuals.dppm
> ### Title: Residuals for Fitted Determinantal Point Process Model
> ### Aliases: residuals.dppm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>    fit <- dppm(swedishpines ~ x, dppGauss())
>    rr <- residuals(fit)
> 
> 
> 
> cleanEx()
> nameEx("residuals.kppm")
> ### * residuals.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: residuals.kppm
> ### Title: Residuals for Fitted Cox or Cluster Point Process Model
> ### Aliases: residuals.kppm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>    fit <- kppm(redwood ~ x, "Thomas")
>    rr <- residuals(fit)
> 
> 
> 
> cleanEx()
> nameEx("residuals.mppm")
> ### * residuals.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: residuals.mppm
> ### Title: Residuals for Point Process Model Fitted to Multiple Point
> ###   Patterns
> ### Aliases: residuals.mppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     fit <- mppm(Bugs ~ x, hyperframe(Bugs=waterstriders))
>     r <- residuals(fit)
>     # compute total residual for each point pattern
>     rtot <- sapply(r, integral.msr)
>     # standardise the total residuals
>     areas <- sapply(windows.mppm(fit), area.owin)
>     rtot/sqrt(areas)
          1           2           3 
 0.01799996 -0.04409610  0.02771749 
> 
> 
> 
> cleanEx()
> nameEx("residuals.ppm")
> ### * residuals.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: residuals.ppm
> ### Title: Residuals for Fitted Point Process Model
> ### Aliases: residuals.ppm
> ### Keywords: spatial models methods
> 
> ### ** Examples
> 
>    fit <- ppm(cells, ~x, Strauss(r=0.15))
> 
>    # Pearson residuals
>    rp <- residuals(fit, type="pe")
>    rp
Scalar-valued measure
Approximated by 1070 quadrature points
window: rectangle = [0, 1] x [0, 1] units
42 atoms
Total mass:
discrete = 4.3048   continuous = -10.287   total = -5.9823
> 
>    # simulated data
>    X <- rStrauss(100,0.7,0.05)
>    # fit Strauss model 
>    fit <- ppm(X, ~1, Strauss(0.05))
>    res.fit <- residuals(fit)
> 
>    # check that total residual is 0 
>    integral.msr(residuals(fit, drop=TRUE))
[1] -5.590955e-12
> 
>    # true model parameters
>    truecoef <- c(log(100), log(0.7))
>    res.true <- residuals(fit, new.coef=truecoef)  
> 
> 
> 
> cleanEx()
> nameEx("rex")
> ### * rex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rex
> ### Title: Richardson Extrapolation
> ### Aliases: rex
> ### Keywords: math optimize
> 
> ### ** Examples
> 
>    # integrals of sin(x) and cos(x) from 0 to pi
>    # correct answers: 2, 0
>    est <- function(nsteps) {
+      xx <- seq(0, pi, length=nsteps)
+      ans <- pi * c(mean(sin(xx)), mean(cos(xx)))
+      names(ans) <- c("sin", "cos")
+      ans
+    }
>    X <- cbind(est(10), est(20), est(40))
>    X
            [,1]         [,2]         [,3]
sin 1.781686e+00 1.895669e+00 1.948945e+00
cos 2.093402e-16 2.025791e-16 2.897758e-16
>    rex(X)
            [,1]         [,2]
sin 2.009653e+00 2.002222e+00
cos 1.958179e-16 3.769725e-16
>    rex(X, recursive=TRUE)
            [,1]
sin 1.999745e+00
cos 4.373574e-16
> 
>    # fitted Gibbs point process model
>    fit0 <- ppm(cells ~ 1, Strauss(0.07), nd=16)
>    fit1 <- update(fit0, nd=32)
>    fit2 <- update(fit0, nd=64)
>    co <- cbind(coef(fit0), coef(fit1), coef(fit2))
>    co 
                  [,1]       [,2]       [,3]
(Intercept)   4.628887   4.794977   4.854495
Interaction -19.255887 -19.289520 -18.318185
>    rex(co, k=2, recursive=TRUE)
                  [,1]
(Intercept)   4.877763
Interaction -17.807789
> 
> 
> 
> cleanEx()
> nameEx("rgbim")
> ### * rgbim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rgbim
> ### Title: Create Colour-Valued Pixel Image
> ### Aliases: rgbim hsvim
> ### Keywords: spatial manip datagen
> 
> ### ** Examples
> 
>   ## Don't show: 
>     op <- spatstat.options(npixel=32)
>   
> ## End(Don't show)
>   # create three images with values in [0,1]
>   X <- setcov(owin())
>   X <- eval.im(pmin(1,X))
>   M <- Window(X)
>   Y <- as.im(function(x,y){(x+1)/2}, W=M)
>   Z <- as.im(function(x,y){(y+1)/2}, W=M)
>   # convert 
>   RGB <- rgbim(X, Y, Z, maxColorValue=1)
>   HSV <- hsvim(X, Y, Z)
>   opa <- par(mfrow=c(1,2))
>   plot(RGB, valuesAreColours=TRUE)
>   plot(HSV, valuesAreColours=TRUE)
>   par(opa)
>   ## Don't show: 
>     spatstat.options(op)
>   
> ## End(Don't show)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("rho2hat")
> ### * rho2hat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rho2hat
> ### Title: Smoothed Relative Density of Pairs of Covariate Values
> ### Aliases: rho2hat
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   data(bei)
>   attach(bei.extra)
>   plot(rho2hat(bei, elev, grad))
>   fit <- ppm(bei, ~elev, covariates=bei.extra)
>   ## Not run: 
> ##D   plot(rho2hat(fit, elev, grad))
> ##D   
> ## End(Not run)
>   plot(rho2hat(fit, elev, grad, method="reweight"))
> 
> 
> 
> cleanEx()

detaching 'bei.extra'

> nameEx("rhohat")
> ### * rhohat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rhohat
> ### Title: Nonparametric Estimate of Intensity as Function of a Covariate
> ### Aliases: rhohat rhohat.ppp rhohat.quad rhohat.ppm rhohat.lpp
> ###   rhohat.lppm
> ### Keywords: spatial models nonparametric
> 
> ### ** Examples
> 
>   X <-  rpoispp(function(x,y){exp(3+3*x)})
>   rho <- rhohat(X, "x")
>   rho <- rhohat(X, function(x,y){x})
>   plot(rho)
Warning in sprintf(legdesc, ylab) : argument not used by format
>   curve(exp(3+3*x), lty=3, col=2, add=TRUE)
> 
>   rhoB <- rhohat(X, "x", method="reweight")
>   rhoC <- rhohat(X, "x", method="transform")
> 
>   rhoM <- rhohat(X, "x", smoother="increasing")
>   plot(rhoM, add=TRUE, col=5)
> 
>   ## Don't show: 
> rh <- rhohat(X, "x", dimyx=32)
> ## End(Don't show)
> 
>   fit <- ppm(X, ~x)
>   rr <- rhohat(fit, "y")
> 
> # linear network
>   Y <- runiflpp(30, simplenet)
>   rhoY <- rhohat(Y, "y")
> 
> 
> 
> cleanEx()
> nameEx("ripras")
> ### * ripras
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ripras
> ### Title: Estimate window from points alone
> ### Aliases: ripras
> ### Keywords: spatial utilities
> 
> ### ** Examples
> 
>   x <- runif(30)
>   y <- runif(30)
>   w <- ripras(x,y)
>   plot(owin(), main="ripras(x,y)")
>   plot(w, add=TRUE)
>   points(x,y)
> 
>   X <- rpoispp(15)
>   plot(X, main="ripras(X)")
>   plot(ripras(X), add=TRUE)
> 
>   # two points insufficient
>   ripras(c(0,1),c(0,0))
NULL
>   # triangle
>   ripras(c(0,1,0.5), c(0,0,1))
window: polygonal boundary
enclosing rectangle: [-0.5, 1.5] x [-0.3333333, 1.6666667] units
>   # three collinear points
>   ripras(c(0,0,0), c(0,1,2))
NULL
> 
> 
> 
> cleanEx()
> nameEx("rjitter")
> ### * rjitter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rjitter
> ### Title: Random Perturbation of a Point Pattern
> ### Aliases: rjitter
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rsyst(owin(), 10, 10)
>    Y <- rjitter(X, 0.02)
>    plot(Y)
>    Z <- rjitter(X)
> 
> 
> 
> cleanEx()
> nameEx("rknn")
> ### * rknn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rknn
> ### Title: Theoretical Distribution of Nearest Neighbour Distance
> ### Aliases: dknn pknn qknn rknn
> ### Keywords: spatial distribution
> 
> ### ** Examples
> 
>   x <- seq(0, 5, length=20)
>   densities <- dknn(x, k=3, d=2)
>   cdfvalues <- pknn(x, k=3, d=2)
>   randomvalues <- rknn(100, k=3, d=2)
>   deciles <- qknn((1:9)/10, k=3, d=2)
> 
> 
> 
> cleanEx()
> nameEx("rlabel")
> ### * rlabel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rlabel
> ### Title: Random Re-Labelling of Point Pattern
> ### Aliases: rlabel
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    amacrine
Marked planar point pattern: 294 points
Multitype, with levels = off, on 
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
> 
>    # Randomly permute the marks "on" and "off"
>    # Result always has 142 "off" and 152 "on"
>    Y <- rlabel(amacrine)
> 
>    # randomly allocate marks "on" and "off"
>    # with probabilities p(off) = 0.48, p(on) = 0.52
>    Y <- rlabel(amacrine, permute=FALSE)
> 
>    # randomly allocate marks "A" and "B" with equal probability
>    data(cells)
>    Y <- rlabel(cells, labels=factor(c("A", "B")), permute=FALSE)
> 
> 
> 
> cleanEx()
> nameEx("rlinegrid")
> ### * rlinegrid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rlinegrid
> ### Title: Generate grid of parallel lines with random displacement
> ### Aliases: rlinegrid
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   plot(rlinegrid(30, 0.05))
> 
> 
> 
> cleanEx()
> nameEx("rlpp")
> ### * rlpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rlpp
> ### Title: Random Points on a Linear Network
> ### Aliases: rlpp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   g <- function(x, y, seg, tp) { exp(x + 3*y) }
>   f <- linfun(g, simplenet)
> 
>   rlpp(20, f)
Point pattern on linear network
20 points
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
> 
>   plot(rlpp(20, f, nsim=3))
> 
> 
> 
> cleanEx()
> nameEx("rmh")
> ### * rmh
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmh
> ### Title: Simulate point patterns using the Metropolis-Hastings algorithm.
> ### Aliases: rmh
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>     # See examples in rmh.default and rmh.ppm
> 
> 
> 
> cleanEx()
> nameEx("rmh.default")
> ### * rmh.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmh.default
> ### Title: Simulate Point Process Models using the Metropolis-Hastings
> ###   Algorithm.
> ### Aliases: rmh.default
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    if(interactive()) {
+      nr   <- 1e5
+      nv  <- 5000
+      ns <- 200
+    } else {
+      nr  <- 20
+      nv <- 5
+      ns <- 20
+      oldopt <- spatstat.options()
+      spatstat.options(expand=1.05)
+    }
>    set.seed(961018)
>    
>    # Strauss process.
>    mod01 <- list(cif="strauss",par=list(beta=2,gamma=0.2,r=0.7),
+                  w=c(0,10,0,10))
>    X1.strauss <- rmh(model=mod01,start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
> 
>    if(interactive()) plot(X1.strauss)
>    
>    # Strauss process, conditioning on n = 42:
>    X2.strauss <- rmh(model=mod01,start=list(n.start=42),
+                      control=list(p=1,nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
> 
>    # Tracking algorithm progress:
>    # (a) saving intermediate states:
>    X <- rmh(model=mod01,start=list(n.start=ns),
+             control=list(nrep=nr, nsave=nr/5, nburn=nr/2))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
Generating proposal points...Running Metropolis-Hastings.
Generating proposal points...Running Metropolis-Hastings.
Generating proposal points...Running Metropolis-Hastings.
>    Saved <- attr(X, "saved")
>    plot(Saved)
> 
>    # (b) inspecting transition history:
>    X <- rmh(model=mod01,start=list(n.start=ns),
+             control=list(nrep=nr, track=TRUE))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
>    History <- attr(X, "history")
>    head(History)
  proposaltype accepted numerator denominator
1        Shift     TRUE         1           1
2        Shift     TRUE         1           1
3        Shift     TRUE         1           1
4        Shift     TRUE         1           1
5        Shift     TRUE         1           1
6        Shift     TRUE         1           1
> 
>    # Hard core process:
>    mod02 <- list(cif="hardcore",par=list(beta=2,hc=0.7),w=c(0,10,0,10))
>    X3.hardcore <- rmh(model=mod02,start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    if(interactive()) plot(X3.hardcore)
> 
>    # Strauss process equal to pure hardcore:
>    mod02s <- list(cif="strauss",par=list(beta=2,gamma=0,r=0.7),w=c(0,10,0,10))
>    X3.strauss <- rmh(model=mod02s,start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Strauss process in a polygonal window.
>    x     <- c(0.55,0.68,0.75,0.58,0.39,0.37,0.19,0.26,0.42)
>    y     <- c(0.20,0.27,0.68,0.99,0.80,0.61,0.45,0.28,0.33)
>    mod03 <- list(cif="strauss",par=list(beta=2000,gamma=0.6,r=0.07),
+                 w=owin(poly=list(x=x,y=y)))
>    X4.strauss <- rmh(model=mod03,start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X4.strauss)
>    
>    # Strauss process in a polygonal window, conditioning on n = 80.
>    X5.strauss <- rmh(model=mod03,start=list(n.start=ns),
+                      control=list(p=1,nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Strauss process, starting off from X4.strauss, but with the
>    # polygonal window replace by a rectangular one.  At the end,
>    # the generated pattern is clipped to the original polygonal window.
>    xxx <- X4.strauss
>    Window(xxx) <- as.owin(c(0,1,0,1))
>    X6.strauss <- rmh(model=mod03,start=list(x.start=xxx),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Strauss with hardcore:
>    mod04 <- list(cif="straush",par=list(beta=2,gamma=0.2,r=0.7,hc=0.3),
+                 w=c(0,10,0,10))
>    X1.straush <- rmh(model=mod04,start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Another Strauss with hardcore (with a perhaps surprising result):
>    mod05 <- list(cif="straush",par=list(beta=80,gamma=0.36,r=45,hc=2.5),
+                 w=c(0,250,0,250))
>    X2.straush <- rmh(model=mod05,start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Pure hardcore (identical to X3.strauss).
>    mod06 <- list(cif="straush",par=list(beta=2,gamma=1,r=1,hc=0.7),
+                 w=c(0,10,0,10))
>    X3.straush <- rmh(model=mod06,start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Soft core:
>    w    <- c(0,10,0,10)
>    mod07 <- list(cif="sftcr",par=list(beta=0.8,sigma=0.1,kappa=0.5),
+                 w=c(0,10,0,10))
>    X.sftcr <- rmh(model=mod07,start=list(n.start=ns),
+                   control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X.sftcr)
> 
>    # Area-interaction process:
>    mod42 <- rmhmodel(cif="areaint",par=list(beta=2,eta=1.6,r=0.7),
+                  w=c(0,10,0,10))
>    X.area <- rmh(model=mod42,start=list(n.start=ns),
+                   control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X.area)
> 
>    # Triplets process
>    modtrip <- list(cif="triplets",par=list(beta=2,gamma=0.2,r=0.7),
+                    w=c(0,10,0,10))
>    X.triplets <- rmh(model=modtrip,
+                      start=list(n.start=ns),
+                      control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X.triplets)
>    
>    # Multitype Strauss:
>    beta <- c(0.027,0.008)
>    gmma <- matrix(c(0.43,0.98,0.98,0.36),2,2)
>    r    <- matrix(c(45,45,45,45),2,2)
>    mod08 <- list(cif="straussm",par=list(beta=beta,gamma=gmma,radii=r),
+                 w=c(0,250,0,250))
>    X1.straussm <- rmh(model=mod08,start=list(n.start=ns),
+                       control=list(ptypes=c(0.75,0.25),nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X1.straussm)
>    
>    # Multitype Strauss conditioning upon the total number
>    # of points being 80:
>    X2.straussm <- rmh(model=mod08,start=list(n.start=ns),
+                       control=list(p=1,ptypes=c(0.75,0.25),nrep=nr,
+                                    nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Conditioning upon the number of points of type 1 being 60
>    # and the number of points of type 2 being 20:
>    X3.straussm <- rmh(model=mod08,start=list(n.start=c(60,20)),
+                       control=list(fixall=TRUE,p=1,ptypes=c(0.75,0.25),
+                                    nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Multitype Strauss hardcore:
>    rhc  <- matrix(c(9.1,5.0,5.0,2.5),2,2)
>    mod09 <- list(cif="straushm",par=list(beta=beta,gamma=gmma,
+                 iradii=r,hradii=rhc),w=c(0,250,0,250))
>    X.straushm <- rmh(model=mod09,start=list(n.start=ns),
+                      control=list(ptypes=c(0.75,0.25),nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Multitype Strauss hardcore with trends for each type:
>    beta  <- c(0.27,0.08)
>    tr3   <- function(x,y){x <- x/250; y <- y/250;
+    			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
+                          }
>                          # log quadratic trend
>    tr4   <- function(x,y){x <- x/250; y <- y/250;
+                          exp(-0.6*x+0.5*y)}
>                         # log linear trend
>    mod10 <- list(cif="straushm",par=list(beta=beta,gamma=gmma,
+                  iradii=r,hradii=rhc),w=c(0,250,0,250),
+                  trend=list(tr3,tr4))
>    X1.straushm.trend <- rmh(model=mod10,start=list(n.start=ns),
+                             control=list(ptypes=c(0.75,0.25),
+                             nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Evaluating trend integral...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X1.straushm.trend)
>    
>    # Multitype Strauss hardcore with trends for each type, given as images:
>    bigwin <- square(250)
>    i1 <- as.im(tr3, bigwin)
>    i2 <- as.im(tr4, bigwin)   
>    mod11 <- list(cif="straushm",par=list(beta=beta,gamma=gmma,
+                  iradii=r,hradii=rhc),w=bigwin,
+                  trend=list(i1,i2))
>    X2.straushm.trend <- rmh(model=mod11,start=list(n.start=ns),
+                             control=list(ptypes=c(0.75,0.25),expand=1,
+                             nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Evaluating trend integral...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Diggle, Gates, and Stibbard:
>    mod12 <- list(cif="dgs",par=list(beta=3600,rho=0.08),w=c(0,1,0,1))
>    X.dgs <- rmh(model=mod12,start=list(n.start=ns),
+                 control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X.dgs)
>    
>    # Diggle-Gratton:
>    mod13 <- list(cif="diggra",
+                  par=list(beta=1800,kappa=3,delta=0.02,rho=0.04),
+                  w=square(1))
>    X.diggra <- rmh(model=mod13,start=list(n.start=ns),
+                    control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X.diggra)
>    
>    # Fiksel:
>    modFik <- list(cif="fiksel",
+                  par=list(beta=180,r=0.15,hc=0.07,kappa=2,a= -1.0),
+                  w=square(1))
>    X.fiksel <- rmh(model=modFik,start=list(n.start=ns),
+                    control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X.fiksel)
>    
>    # Geyer:
>    mod14 <- list(cif="geyer",par=list(beta=1.25,gamma=1.6,r=0.2,sat=4.5),
+                  w=c(0,10,0,10))
>    X1.geyer <- rmh(model=mod14,start=list(n.start=ns),
+                    control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    if(interactive()) plot(X1.geyer)
>    
>    # Geyer; same as a Strauss process with parameters
>    # (beta=2.25,gamma=0.16,r=0.7):
>    
>    mod15 <- list(cif="geyer",par=list(beta=2.25,gamma=0.4,r=0.7,sat=10000),
+                  w=c(0,10,0,10))
>    X2.geyer <- rmh(model=mod15,start=list(n.start=ns),
+                    control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    mod16 <- list(cif="geyer",par=list(beta=8.1,gamma=2.2,r=0.08,sat=3))
>    data(redwood)
>    X3.geyer <- rmh(model=mod16,start=list(x.start=redwood),
+                    control=list(periodic=TRUE,nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    
>    # Geyer, starting from the redwood data set, simulating
>    # on a torus, and conditioning on n:
>    X4.geyer <- rmh(model=mod16,start=list(x.start=redwood),
+                    control=list(p=1,periodic=TRUE,nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
> 
>    # Lookup (interaction function h_2 from page 76, Diggle (2003)):
>       r <- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
>       h <- 20*(r-0.05)
>       h[r<0.05] <- 0
>       h[r>0.10] <- 1
>       mod17 <- list(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))
>       X.lookup <- rmh(model=mod17,start=list(n.start=ns),
+                       control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>       if(interactive()) plot(X.lookup)
>                    
>    # Strauss with trend
>    tr <- function(x,y){x <- x/250; y <- y/250;
+    			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
+                          }
>    beta <- 0.3
>    gmma <- 0.5
>    r    <- 45
>    modStr <- list(cif="strauss",par=list(beta=beta,gamma=gmma,r=r),
+                  w=square(250), trend=tr)
>    X1.strauss.trend <- rmh(model=modStr,start=list(n.start=ns),
+                            control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Evaluating trend integral...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    # Baddeley-Geyer
>    r <- seq(0,0.2,length=8)[-1]
>    gmma <- c(0.5,0.6,0.7,0.8,0.7,0.6,0.5)
>    mod18 <- list(cif="badgey",par=list(beta=4000, gamma=gmma,r=r,sat=5),
+                  w=square(1))
>    X1.badgey <- rmh(model=mod18,start=list(n.start=ns),
+                     control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    mod19 <- list(cif="badgey",
+                  par=list(beta=4000, gamma=gmma,r=r,sat=1e4),
+                  w=square(1))
>    set.seed(1329)
>    X2.badgey <- rmh(model=mod18,start=list(n.start=ns),
+                     control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
> 
>    # Check:
>    h <- ((prod(gmma)/cumprod(c(1,gmma)))[-8])^2
>    hs <- stepfun(r,c(h,1))
>    mod20 <- list(cif="lookup",par=list(beta=4000,h=hs),w=square(1))
>    set.seed(1329)
>    X.check <- rmh(model=mod20,start=list(n.start=ns),
+                       control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    # X2.badgey and X.check will be identical.
> 
>    mod21 <- list(cif="badgey",par=list(beta=300,gamma=c(1,0.4,1),
+                  r=c(0.035,0.07,0.14),sat=5), w=square(1))
>    X3.badgey <- rmh(model=mod21,start=list(n.start=ns),
+                     control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    # Same result as Geyer model with beta=300, gamma=0.4, r=0.07,
>    # sat = 5 (if seeds and control parameters are the same)
> 
>    # Or more simply:
>    mod22 <- list(cif="badgey",
+                  par=list(beta=300,gamma=0.4,r=0.07, sat=5),
+                  w=square(1))
>    X4.badgey <- rmh(model=mod22,start=list(n.start=ns),
+                     control=list(nrep=nr,nverb=nv))
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
iteration 5
iteration 10
iteration 15
iteration 20
>    # Same again --- i.e. the BadGey model includes the Geyer model.
> 
> 
>    # Illustrating scalability.
>    ## Not run: 
> ##D     M1 <- rmhmodel(cif="strauss",par=list(beta=60,gamma=0.5,r=0.04),w=owin())
> ##D     set.seed(496)
> ##D     X1 <- rmh(model=M1,start=list(n.start=300))
> ##D     M2 <- rmhmodel(cif="strauss",par=list(beta=0.6,gamma=0.5,r=0.4),
> ##D               w=owin(c(0,10),c(0,10)))
> ##D     set.seed(496)
> ##D     X2  <- rmh(model=M2,start=list(n.start=300))
> ##D     chk <- affine(X1,mat=diag(c(10,10)))
> ##D     all.equal(chk,X2,check.attributes=FALSE)
> ##D     # Under the default spatstat options the foregoing all.equal()
> ##D     # will yield TRUE.  Setting spatstat.options(scalable=FALSE) and
> ##D     # re-running the code will reveal differences between X1 and X2.
> ##D    
> ## End(Not run)
> 
>    if(!interactive()) spatstat.options(oldopt)
> 
> 
> 
> cleanEx()
> nameEx("rmh.ppm")
> ### * rmh.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmh.ppm
> ### Title: Simulate from a Fitted Point Process Model
> ### Aliases: rmh.ppm
> ### Keywords: spatial models datagen
> 
> ### ** Examples
> 
>    live <- interactive()
>    op <- spatstat.options()
>    spatstat.options(rmh.nrep=1e5)
>    Nrep <- 1e5
> 
>    X <- swedishpines
>    if(live) plot(X, main="Swedish Pines data")
> 
>    # Poisson process
>    fit <- ppm(X, ~1, Poisson())
>    Xsim <- rmh(fit)
Extracting model information...Evaluating trend...done.
Checking arguments..determining simulation windows...
>    if(live) plot(Xsim, main="simulation from fitted Poisson model")
> 
>    # Strauss process   
>    fit <- ppm(X, ~1, Strauss(r=7))
>    Xsim <- rmh(fit)
Extracting model information...Evaluating trend...done.
Checking arguments..determining simulation windows...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
>    if(live) plot(Xsim, main="simulation from fitted Strauss model")
> 
>    ## Not run: 
> ##D      # Strauss process simulated on a larger window
> ##D      # then clipped to original window
> ##D      Xsim <- rmh(fit, control=list(nrep=Nrep, expand=1.1, periodic=TRUE))
> ##D      Xsim <- rmh(fit, nrep=Nrep, expand=2, periodic=TRUE)
> ##D    
> ## End(Not run)
> 
>    ## Not run: 
> ##D      X <- rSSI(0.05, 100)
> ##D      # piecewise-constant pairwise interaction function
> ##D      fit <- ppm(X, ~1, PairPiece(seq(0.02, 0.1, by=0.01)))
> ##D      Xsim <- rmh(fit)
> ##D    
> ## End(Not run)
> 
>     # marked point pattern
>     Y <- amacrine
> 
>    ## Not run: 
> ##D      # marked Poisson models
> ##D      fit <- ppm(Y)
> ##D      fit <- ppm(Y,~marks)
> ##D      fit <- ppm(Y,~polynom(x,2))
> ##D      fit <- ppm(Y,~marks+polynom(x,2))
> ##D      fit <- ppm(Y,~marks*polynom(x,y,2))
> ##D      Ysim <- rmh(fit)
> ##D    
> ## End(Not run)
> 
>    # multitype Strauss models
>    MS <- MultiStrauss(radii=matrix(0.07, ncol=2, nrow=2),
+                       types = levels(Y$marks))
>    ## Not run: 
> ##D     fit <- ppm(Y ~marks, MS)
> ##D     Ysim <- rmh(fit)
> ##D    
> ## End(Not run)
> 
>    fit <- ppm(Y ~ marks*polynom(x,y,2), MS)
>    Ysim <- rmh(fit)
Extracting model information...Evaluating trend...done.
Checking arguments..determining simulation windows...Evaluating trend integral...Starting simulation.
Initial state...Ready to simulate. Generating proposal points...Running Metropolis-Hastings.
>    if(live) plot(Ysim, main="simulation from fitted inhomogeneous Multitype Strauss")
> 
>    spatstat.options(op)
> 
>   ## Not run: 
> ##D     # Hybrid model
> ##D     fit <- ppm(redwood, ~1, Hybrid(A=Strauss(0.02), B=Geyer(0.1, 2)))
> ##D     Y <- rmh(fit)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rmhcontrol")
> ### * rmhcontrol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmhcontrol
> ### Title: Set Control Parameters for Metropolis-Hastings Algorithm.
> ### Aliases: rmhcontrol rmhcontrol.default
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    # parameters given as named arguments
>    c1 <- rmhcontrol(p=0.3,periodic=TRUE,nrep=1e6,nverb=1e5)
> 
>    # parameters given as a list
>    liz <- list(p=0.9, nrep=1e4)
>    c2 <- rmhcontrol(liz)
> 
>    # parameters given in rmhcontrol object
>    c3 <- rmhcontrol(c1)
> 
> 
> 
> cleanEx()
> nameEx("rmhexpand")
> ### * rmhexpand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmhexpand
> ### Title: Specify Simulation Window or Expansion Rule
> ### Aliases: rmhexpand
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   rmhexpand()
Expand the simulation window? Not determined. Default is:
	 Area expansion factor 2 
>   rmhexpand(2)
Expand the simulation window? Yes:
	 Area expansion factor 2 
>   rmhexpand(1)
Expand the simulation window? No.
>   rmhexpand(length=1.5)
Expand the simulation window? Yes:
	 Length expansion factor 1.5 
>   rmhexpand(distance=0.1)
Expand the simulation window? Yes:
	 Expansion buffer distance 0.1 
>   rmhexpand(letterR)
Expand the simulation window? Yes:
window: polygonal boundary
enclosing rectangle: [2.017, 3.93] x [0.645, 3.278] units
> 
> 
> 
> cleanEx()
> nameEx("rmhmodel.default")
> ### * rmhmodel.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmhmodel.default
> ### Title: Build Point Process Model for Metropolis-Hastings Simulation.
> ### Aliases: rmhmodel.default
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    # Strauss process:
>    mod01 <- rmhmodel(cif="strauss",par=list(beta=2,gamma=0.2,r=0.7),
+                  w=c(0,10,0,10))
>    mod01
Metropolis-Hastings algorithm, model parameters
Conditional intensity: cif= 'strauss'

Numerical parameters: par =
$beta
[1] 2

$gamma
[1] 0.2

$r
[1] 0.7

window: rectangle = [0, 10] x [0, 10] units

Trend: none.
>    # The above could also be simulated using 'rStrauss'
> 
>    # Strauss with hardcore:
>    mod04 <- rmhmodel(cif="straush",par=list(beta=2,gamma=0.2,r=0.7,hc=0.3),
+                 w=owin(c(0,10),c(0,5)))
> 
>    # Hard core:
>    mod05 <- rmhmodel(cif="hardcore",par=list(beta=2,hc=0.3),
+               w=square(5))
> 
>    # Soft core:
>    w    <- square(10)
>    mod07 <- rmhmodel(cif="sftcr",
+                      par=list(beta=0.8,sigma=0.1,kappa=0.5),
+                      w=w)
>    
>    # Penttinen process:
>    modpen <- rmhmodel(cif="penttinen",par=list(beta=2,gamma=0.6,r=1),
+                  w=c(0,10,0,10))
> 
>    # Area-interaction process:
>    mod42 <- rmhmodel(cif="areaint",par=list(beta=2,eta=1.6,r=0.7),
+                  w=c(0,10,0,10))
> 
>    # Baddeley-Geyer process:
>    mod99 <- rmhmodel(cif="badgey",par=list(beta=0.3,
+                      gamma=c(0.2,1.8,2.4),r=c(0.035,0.07,0.14),sat=5),
+                      w=unit.square())
> 
>    # Multitype Strauss:
>    beta <- c(0.027,0.008)
>    gmma <- matrix(c(0.43,0.98,0.98,0.36),2,2)
>    r    <- matrix(c(45,45,45,45),2,2)
>    mod08 <- rmhmodel(cif="straussm",
+                      par=list(beta=beta,gamma=gmma,radii=r),
+                      w=square(250))
>    # specify types
>    mod09 <- rmhmodel(cif="straussm",
+                      par=list(beta=beta,gamma=gmma,radii=r),
+                      w=square(250),
+                      types=c("A", "B"))
> 
>    # Multitype Hardcore:
>    rhc  <- matrix(c(9.1,5.0,5.0,2.5),2,2)
>    mod08hard <- rmhmodel(cif="multihard",
+                      par=list(beta=beta,hradii=rhc),
+                      w=square(250),
+                      types=c("A", "B"))
> 
>    
>    # Multitype Strauss hardcore with trends for each type:
>    beta  <- c(0.27,0.08)
>    ri    <- matrix(c(45,45,45,45),2,2)
>    rhc  <- matrix(c(9.1,5.0,5.0,2.5),2,2)
>    tr3   <- function(x,y){x <- x/250; y <- y/250;
+    			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
+                          }
>                          # log quadratic trend
>    tr4   <- function(x,y){x <- x/250; y <- y/250;
+                          exp(-0.6*x+0.5*y)}
>                         # log linear trend
>    mod10 <- rmhmodel(cif="straushm",par=list(beta=beta,gamma=gmma,
+                  iradii=ri,hradii=rhc),w=c(0,250,0,250),
+                  trend=list(tr3,tr4))
> 
>    # Triplets process:
>    mod11 <- rmhmodel(cif="triplets",par=list(beta=2,gamma=0.2,r=0.7),
+                  w=c(0,10,0,10))
> 
>    # Lookup (interaction function h_2 from page 76, Diggle (2003)):
>       r <- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
>       h <- 20*(r-0.05)
>       h[r<0.05] <- 0
>       h[r>0.10] <- 1
>       mod17 <- rmhmodel(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))
> 
>   # hybrid model
>   modhy <- rmhmodel(cif=c('strauss', 'geyer'),
+                     par=list(list(beta=100,gamma=0.5,r=0.05),
+                              list(beta=1, gamma=0.7,r=0.1, sat=2)),
+                     w=square(1))
>   modhy
Metropolis-Hastings algorithm, model parameters
Conditional intensity: hybrid of cifs 'strauss' and 'geyer'

Numerical parameters: par =
[[1]]
[[1]]$beta
[1] 100

[[1]]$gamma
[1] 0.5

[[1]]$r
[1] 0.05


[[2]]
[[2]]$beta
[1] 1

[[2]]$gamma
[1] 0.7

[[2]]$r
[1] 0.1

[[2]]$sat
[1] 2


window: rectangle = [0, 1] x [0, 1] units

Trend: none.
> 
> 
> 
> cleanEx()
> nameEx("rmhmodel.list")
> ### * rmhmodel.list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmhmodel.list
> ### Title: Define Point Process Model for Metropolis-Hastings Simulation.
> ### Aliases: rmhmodel.list
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    # Strauss process:
>    mod01 <- list(cif="strauss",par=list(beta=2,gamma=0.2,r=0.7),
+                  w=c(0,10,0,10))
>    mod01 <- rmhmodel(mod01)
> 
>    # Strauss with hardcore:
>    mod04 <- list(cif="straush",par=list(beta=2,gamma=0.2,r=0.7,hc=0.3),
+                 w=owin(c(0,10),c(0,5)))
>    mod04 <- rmhmodel(mod04)
> 
>    # Soft core:
>    w    <- square(10)
>    mod07 <- list(cif="sftcr",
+                      par=list(beta=0.8,sigma=0.1,kappa=0.5),
+                      w=w)
>    mod07 <- rmhmodel(mod07)
>    
>    # Multitype Strauss:
>    beta <- c(0.027,0.008)
>    gmma <- matrix(c(0.43,0.98,0.98,0.36),2,2)
>    r    <- matrix(c(45,45,45,45),2,2)
>    mod08 <- list(cif="straussm",
+                      par=list(beta=beta,gamma=gmma,radii=r),
+                      w=square(250))
>    mod08 <- rmhmodel(mod08)
> 
>    # specify types
>    mod09 <- rmhmodel(list(cif="straussm",
+                      par=list(beta=beta,gamma=gmma,radii=r),
+                      w=square(250),
+                      types=c("A", "B")))
> 
>    # Multitype Strauss hardcore with trends for each type:
>    beta  <- c(0.27,0.08)
>    ri    <- matrix(c(45,45,45,45),2,2)
>    rhc  <- matrix(c(9.1,5.0,5.0,2.5),2,2)
>    tr3   <- function(x,y){x <- x/250; y <- y/250;
+    			   exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
+                          }
>                          # log quadratic trend
>    tr4   <- function(x,y){x <- x/250; y <- y/250;
+                          exp(-0.6*x+0.5*y)}
>                         # log linear trend
>    mod10 <- list(cif="straushm",par=list(beta=beta,gamma=gmma,
+                  iradii=ri,hradii=rhc),w=c(0,250,0,250),
+                  trend=list(tr3,tr4))
>    mod10 <- rmhmodel(mod10)
> 
>    # Lookup (interaction function h_2 from page 76, Diggle (2003)):
>    r <- seq(from=0,to=0.2,length=101)[-1] # Drop 0.
>    h <- 20*(r-0.05)
>    h[r<0.05] <- 0
>    h[r>0.10] <- 1
>    mod17 <- list(cif="lookup",par=list(beta=4000,h=h,r=r),w=c(0,1,0,1))
>    mod17 <- rmhmodel(mod17)
> 
> 
> 
> cleanEx()
> nameEx("rmhmodel.ppm")
> ### * rmhmodel.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmhmodel.ppm
> ### Title: Interpret Fitted Model for Metropolis-Hastings Simulation.
> ### Aliases: rmhmodel.ppm
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   fit1 <- ppm(cells ~1, Strauss(0.07))
>   mod1 <- rmhmodel(fit1)
Extracting model information...Evaluating trend...done.
> 
>   fit2 <- ppm(cells ~x, Geyer(0.07, 2))
>   mod2 <- rmhmodel(fit2)
Extracting model information...Evaluating trend...done.
> 
>   fit3 <- ppm(cells ~x, Hardcore(0.07))
>   mod3 <- rmhmodel(fit3)
Extracting model information...Evaluating trend...done.
> 
>   # Then rmh(mod1), etc
> 
> 
> 
> cleanEx()
> nameEx("rmhstart")
> ### * rmhstart
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmhstart
> ### Title: Determine Initial State for Metropolis-Hastings Simulation.
> ### Aliases: rmhstart rmhstart.default
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    # 30 random points
>    a <- rmhstart(n.start=30)
>    a
Metropolis-Hastings algorithm starting parameters
Initial state: number fixed at n.start = 30 
> 
>    # a particular point pattern
>    b <- rmhstart(x.start=cells)
> 
> 
> 
> cleanEx()
> nameEx("rmpoint")
> ### * rmpoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmpoint
> ### Title: Generate N Random Multitype Points
> ### Aliases: rmpoint
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
> 
> abc <- c("a","b","c")
> 
> ##### Model I
> 
> rmpoint(25, types=abc)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> rmpoint(25, 1, types=abc)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # 25 points, equal probability for each type, uniformly distributed locations
> 
> rmpoint(25, function(x,y,m) {rep(1, length(x))}, types=abc)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # same as above
> rmpoint(25, list(function(x,y){rep(1, length(x))},
+                  function(x,y){rep(1, length(x))},
+                  function(x,y){rep(1, length(x))}),
+              types=abc)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # same as above
> 
> rmpoint(25, function(x,y,m) { x }, types=abc)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # 25 points, equal probability for each type,
> # locations nonuniform with density proportional to x
> 
> rmpoint(25, function(x,y,m) { ifelse(m == "a", 1, x) }, types=abc)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> rmpoint(25, list(function(x,y) { rep(1, length(x)) },
+                 function(x,y) { x },
+                 function(x,y) { x }),
+                 types=abc)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # 25 points, UNEQUAL probabilities for each type,
> # type "a" points uniformly distributed,
> # type "b" and "c" points nonuniformly distributed.
> 
> ##### Model II
> 
> rmpoint(25, 1, types=abc, ptypes=rep(1,3)/3)
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> rmpoint(25, 1, types=abc, ptypes=rep(1,3))
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # 25 points, equal probability for each type,
> # uniformly distributed locations
> 
> rmpoint(25, function(x,y,m) {rep(1, length(x))}, types=abc, ptypes=rep(1,3))
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # same as above
> rmpoint(25, list(function(x,y){rep(1, length(x))},
+                  function(x,y){rep(1, length(x))},
+                  function(x,y){rep(1, length(x))}),
+              types=abc, ptypes=rep(1,3))
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # same as above
> 
> rmpoint(25, function(x,y,m) { x }, types=abc, ptypes=rep(1,3))
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # 25 points, equal probability for each type,
> # locations nonuniform with density proportional to x
> 
> rmpoint(25, function(x,y,m) { ifelse(m == "a", 1, x) }, types=abc, ptypes=rep(1,3))
Marked planar point pattern: 25 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # 25 points, EQUAL probabilities for each type,
> # type "a" points uniformly distributed,
> # type "b" and "c" points nonuniformly distributed.
> 
> ###### Model III
> 
> rmpoint(c(12, 8, 4), 1, types=abc)
Marked planar point pattern: 24 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> # 12 points of type "a",
> # 8 points of type "b",
> # 4 points of type "c",
> # each uniformly distributed
> 
> rmpoint(c(12, 8, 4), function(x,y,m) { ifelse(m=="a", 1, x)}, types=abc)
Marked planar point pattern: 24 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> rmpoint(c(12, 8, 4), list(function(x,y) { rep(1, length(x)) },
+                                function(x,y) { x },
+                                function(x,y) { x }),
+              types=abc)
Marked planar point pattern: 24 points
Multitype, with levels = a, b, c 
window: rectangle = [0, 1] x [0, 1] units
> 
> # 12 points of type "a", uniformly distributed
> # 8 points of type "b", nonuniform
> # 4 points of type "c", nonuniform
> 
> 
> #########
> 
> ## Randomising an existing point pattern:
> # same numbers of points of each type, uniform random locations (Model III)
> rmpoint(table(marks(demopat)), 1, win=Window(demopat))
Marked planar point pattern: 112 points
Multitype, with levels = A, B 
window: polygonal boundary
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
> 
> # same total number of points, distribution of types estimated from X,
> # uniform random locations (Model II)
> rmpoint(npoints(demopat), 1, types=levels(marks(demopat)), win=Window(demopat),
+        ptypes=table(marks(demopat)))
Marked planar point pattern: 112 points
Multitype, with levels = A, B 
window: polygonal boundary
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
> 
> 
> 
> 
> cleanEx()
> nameEx("rmpoispp")
> ### * rmpoispp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmpoispp
> ### Title: Generate Multitype Poisson Point Pattern
> ### Aliases: rmpoispp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # uniform bivariate Poisson process with total intensity 100 in unit square
>  pp <- rmpoispp(50, types=c("a","b"))
>  
>  # stationary bivariate Poisson process with intensity A = 30, B = 70
>  pp <- rmpoispp(c(30,70), types=c("A","B"))
>  pp <- rmpoispp(c(30,70))
> 
>  # works in any window
>  data(letterR)
>  pp <- rmpoispp(c(30,70), win=letterR, types=c("A","B"))
> 
>  # inhomogeneous lambda(x,y,m)
>  # note argument 'm' is a factor 
>  lam <- function(x,y,m) { 50 * (x^2 + y^3) * ifelse(m=="A", 2, 1)}
>  pp <- rmpoispp(lam, win=letterR, types=c("A","B"))
>  # extra arguments
>  lam <- function(x,y,m,scal) { scal * (x^2 + y^3) * ifelse(m=="A", 2, 1)}
>  pp <- rmpoispp(lam, win=letterR, types=c("A","B"), scal=50)
> 
>  # list of functions lambda[[i]](x,y)
>  lams <- list(function(x,y){50 * x^2}, function(x,y){20 * abs(y)})
>  pp <- rmpoispp(lams, win=letterR, types=c("A","B"))
>  pp <- rmpoispp(lams, win=letterR)
>  # functions with extra arguments
>  lams <- list(function(x,y,scal){5 * scal * x^2},
+               function(x,y, scal){2 * scal * abs(y)})
>  pp <- rmpoispp(lams, win=letterR, types=c("A","B"), scal=10)
>  pp <- rmpoispp(lams, win=letterR, scal=10)
> 
>  # florid example
>  lams <- list(function(x,y){
+    			   100*exp((6*x + 5*y - 18*x^2 + 12*x*y - 9*y^2)/6)
+                          }
+                          # log quadratic trend
+               ,
+               function(x,y){
+                          	   100*exp(-0.6*x+0.5*y)
+                          }
+                         # log linear trend
+               )
>   X <- rmpoispp(lams, win=unit.square(), types=c("on", "off"))   
> 
>  # pixel image
>  Z <- as.im(function(x,y){30 * (x^2 + y^3)}, letterR)
>  pp <- rmpoispp(Z, types=c("A","B"))
> 
>  # list of pixel images
>  ZZ <- list(
+           as.im(function(x,y){20 * (x^2 + y^3)}, letterR),
+           as.im(function(x,y){40 * (x^3 + y^2)}, letterR))
>  pp <- rmpoispp(ZZ, types=c("A","B"))
>  pp <- rmpoispp(ZZ)
> 
>  # randomising an existing point pattern
>  rmpoispp(intensity(amacrine), win=Window(amacrine))
Marked planar point pattern: 283 points
Multitype, with levels = off, on 
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
> 
> 
> 
> cleanEx()
> nameEx("rnoise")
> ### * rnoise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rnoise
> ### Title: Random Pixel Noise
> ### Aliases: rnoise
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   plot(rnoise(), main="Uniform noise")
>   plot(rnoise(rnorm, dimyx=32, mean=2, sd=1),
+        main="White noise")
> 
> 
> 
> cleanEx()
> nameEx("roc")
> ### * roc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roc
> ### Title: Receiver Operating Characteristic
> ### Aliases: roc roc.ppp roc.lpp roc.ppm roc.kppm roc.lppm
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   plot(roc(swedishpines, "x"))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>   fit <- ppm(swedishpines ~ x+y)
>   plot(roc(fit))
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("rose")
> ### * rose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rose
> ### Title: Rose Diagram
> ### Aliases: rose rose.default rose.histogram rose.density rose.fv
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   ang <- runif(1000, max=360)
>   rose(ang, col="grey")
>   rose(ang, col="grey", start="N", clockwise=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("rotate.im")
> ### * rotate.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rotate.im
> ### Title: Rotate a Pixel Image
> ### Aliases: rotate.im
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   Z <- distmap(letterR)
>   X <- rotate(Z)
>   ## Not run: 
> ##D   plot(X)
> ##D   
> ## End(Not run)
>   Y <- rotate(X, centre="midpoint")
> 
> 
> 
> cleanEx()
> nameEx("rotate.infline")
> ### * rotate.infline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rotate.infline
> ### Title: Rotate or Shift Infinite Lines
> ### Aliases: rotate.infline shift.infline reflect.infline flipxy.infline
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   L <- infline(v=0.5)
> 
>   plot(square(c(-1,1)), main="rotate lines", type="n")
>   points(0, 0, pch=3)
>   plot(L, col="green")
>   plot(rotate(L, pi/12), col="red")
>   plot(rotate(L, pi/6), col="red")
>   plot(rotate(L, pi/4), col="red")
> 
>   L <- infline(p=c(0.4, 0.9), theta=pi* c(0.2, 0.6))
> 
>   plot(square(c(-1,1)), main="shift lines", type="n")
>   L <- infline(p=c(0.7, 0.8), theta=pi* c(0.2, 0.6))
>   plot(L, col="green")
>   plot(shift(L, c(-0.5, -0.4)), col="red")
> 
>   plot(square(c(-1,1)), main="reflect lines", type="n")
>   points(0, 0, pch=3)
>   L <- infline(p=c(0.7, 0.8), theta=pi* c(0.2, 0.6))
>   plot(L, col="green")
>   plot(reflect(L), col="red")
> 
> 
> 
> 
> cleanEx()
> nameEx("rotate.owin")
> ### * rotate.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rotate.owin
> ### Title: Rotate a Window
> ### Aliases: rotate.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   w <- owin(c(0,1),c(0,1))
>   v <- rotate(w, pi/3)
>   e <- rotate(w, pi/2, centre="midpoint")
>   ## Not run: 
> ##D   plot(v)
> ##D   
> ## End(Not run)
>   w <- as.mask(letterR)
>   v <- rotate(w, pi/5)
> 
> 
> 
> cleanEx()
> nameEx("rotate.ppp")
> ### * rotate.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rotate.ppp
> ### Title: Rotate a Point Pattern
> ### Aliases: rotate.ppp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(cells)
>   X <- rotate(cells, pi/3)
>   ## Not run: 
> ##D   plot(X)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rotate.psp")
> ### * rotate.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rotate.psp
> ### Title: Rotate a Line Segment Pattern
> ### Aliases: rotate.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   oldpar <- par(mfrow=c(2,1))
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(X, main="original")
>   Y <- rotate(X, pi/4)
>   plot(Y, main="rotated")
>   par(oldpar)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("rotmean")
> ### * rotmean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rotmean
> ### Title: Rotational Average of a Pixel Image
> ### Aliases: rotmean
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   if(interactive()) {
+     Z <- setcov(square(1))
+     plot(rotmean(Z))
+     plot(rotmean(Z, result="im"))
+   } else {
+     Z <- setcov(square(1), dimyx=32)
+     f <- rotmean(Z)
+   }
> 
> 
> 
> cleanEx()
> nameEx("round.ppp")
> ### * round.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: round.ppp
> ### Title: Apply Numerical Rounding to Spatial Coordinates
> ### Aliases: round.ppp round.pp3 round.ppx
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   round(cells, 1)
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("rounding")
> ### * rounding
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rounding
> ### Title: Detect Numerical Rounding
> ### Aliases: rounding rounding.default rounding.ppp rounding.pp3
> ###   rounding.ppx
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    rounding(c(0.1, 0.3, 1.2))
[1] 1
>    rounding(c(1940, 1880, 2010))
[1] -1
>    rounding(0)
NULL
>    rounding(cells)
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("rpoint")
> ### * rpoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoint
> ### Title: Generate N Random Points
> ### Aliases: rpoint
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # 100 uniform random points in the unit square
>  X <- rpoint(100)
> 
>  # 100 random points with probability density proportional to x^2 + y^2
>  X <- rpoint(100, function(x,y) { x^2 + y^2}, 1)
> 
>  # `fmax' may be omitted
>  X <- rpoint(100, function(x,y) { x^2 + y^2})
> 
>  # irregular window
>  data(letterR)
>  X <- rpoint(100, function(x,y) { x^2 + y^2}, win=letterR)
> 
>  # make a pixel image 
>  Z <- setcov(letterR)
>  # 100 points with density proportional to pixel values
>  X <- rpoint(100, Z)
> 
> 
> 
> cleanEx()
> nameEx("rpoisline")
> ### * rpoisline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoisline
> ### Title: Generate Poisson Random Line Process
> ### Aliases: rpoisline
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # uniform Poisson line process with intensity 10,
>  # clipped to the unit square
>  rpoisline(10)
planar line segment pattern: 40 line segments
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("rpoislinetess")
> ### * rpoislinetess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoislinetess
> ### Title: Poisson Line Tessellation
> ### Aliases: rpoislinetess
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  X <- rpoislinetess(3)
>  plot(as.im(X), main="rpoislinetess(3)")
>  plot(X, add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("rpoislpp")
> ### * rpoislpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoislpp
> ### Title: Poisson Point Process on a Linear Network
> ### Aliases: rpoislpp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rpoislpp(5, simplenet)
>    plot(X)
>    # multitype
>    X <- rpoislpp(c(a=5, b=5), simplenet)
> 
> 
> 
> cleanEx()
> nameEx("rpoispp")
> ### * rpoispp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoispp
> ### Title: Generate Poisson Point Pattern
> ### Aliases: rpoispp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # uniform Poisson process with intensity 100 in the unit square
>  pp <- rpoispp(100)
>  
>  # uniform Poisson process with intensity 1 in a 10 x 10 square
>  pp <- rpoispp(1, win=owin(c(0,10),c(0,10)))
>  # plots should look similar !
>  
>  # inhomogeneous Poisson process in unit square
>  # with intensity lambda(x,y) = 100 * exp(-3*x)
>  # Intensity is bounded by 100
>  pp <- rpoispp(function(x,y) {100 * exp(-3*x)}, 100)
> 
>  # How to tune the coefficient of x
>  lamb <- function(x,y,a) { 100 * exp( - a * x)}
>  pp <- rpoispp(lamb, 100, a=3)
> 
>  # pixel image
>  Z <- as.im(function(x,y){100 * sqrt(x+y)}, unit.square())
>  pp <- rpoispp(Z)
> 
>  # randomising an existing point pattern
>  rpoispp(intensity(cells), win=Window(cells))
Planar point pattern: 45 points
window: rectangle = [0, 1] x [0, 1] units
>  rpoispp(ex=cells)
Planar point pattern: 46 points
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("rpoispp3")
> ### * rpoispp3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoispp3
> ### Title: Generate Poisson Point Pattern in Three Dimensions
> ### Aliases: rpoispp3
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- rpoispp3(50)
> 
> 
> 
> cleanEx()
> nameEx("rpoisppOnLines")
> ### * rpoisppOnLines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoisppOnLines
> ### Title: Generate Poisson Point Pattern on Line Segments
> ### Aliases: rpoisppOnLines
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   live <- interactive()
>   L <- psp(runif(10), runif(10), runif(10), runif(10),  window=owin())
>   if(live) plot(L, main="")
> 
>   # uniform intensity
>   Y <- rpoisppOnLines(4, L)
>   if(live) plot(Y, add=TRUE, pch="+")
> 
>   # uniform MARKED process with types 'a' and 'b'
>   Y <- rpoisppOnLines(c(a=4, b=5), L)
>   if(live) {
+     plot(L, main="")
+     plot(Y, add=TRUE, pch="+")
+   }
> 
>   # intensity is a function
>   Y <- rpoisppOnLines(function(x,y){ 10 * x^2}, L, 10)
>   if(live) { 
+     plot(L, main="")
+     plot(Y, add=TRUE, pch="+")
+   }
> 
>   # intensity is an image
>   Z <- as.im(function(x,y){10 * sqrt(x+y)}, unit.square())
>   Y <- rpoisppOnLines(Z, L, 15)
>   if(live) {
+    plot(L, main="")
+    plot(Y, add=TRUE, pch="+")
+   }
> 
> 
> 
> cleanEx()
> nameEx("rpoisppx")
> ### * rpoisppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rpoisppx
> ### Title: Generate Poisson Point Pattern in Any Dimensions
> ### Aliases: rpoisppx
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    w <- boxx(x=c(0,1), y=c(0,1), z=c(0,1), t=c(0,3))
>    X <- rpoisppx(10, w)
> 
> 
> 
> cleanEx()
> nameEx("rppm")
> ### * rppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rppm
> ### Title: Recursively Partitioned Point Process Model
> ### Aliases: rppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     # New Zealand trees data: trees planted along border
>     # Use covariates 'x', 'y'
>     nzfit <- rppm(nztrees ~ x + y)
>     nzfit
Point process model with recursive partitioning
Data: 'nztrees'
Covariates: 'x' and 'y'
Regression tree:
n= 1114 

node), split, n, deviance, yval
      * denotes terminal node

1) root 1114 550.152300 0.0059167530  
  2) x< 146.4141 1070 500.557200 0.0054089750  
    4) x>=6.585938 1029 463.562500 0.0050845540  
      8) x< 12.97656 64   1.677785 0.0009532339 *
      9) x>=12.97656 965 454.329100 0.0054317730 *
    5) x< 6.585938 41  31.613820 0.0125505000 *
  3) x>=146.4141 44  38.163650 0.0172569400  
    6) x>=150.3047 34   1.403263 0.0017653710 *
    7) x< 150.3047 10   8.965755 0.0458365200 *
>     prune(nzfit, cp=0.035)
Point process model with recursive partitioning
Data: 'nztrees'
Covariates: 'x' and 'y'
Regression tree:
n= 1114 

node), split, n, deviance, yval
      * denotes terminal node

1) root 1114 550.152300 0.005916753  
  2) x< 146.4141 1070 500.557200 0.005408975 *
  3) x>=146.4141 44  38.163650 0.017256940  
    6) x>=150.3047 34   1.403263 0.001765371 *
    7) x< 150.3047 10   8.965755 0.045836520 *
>     # Murchison gold data: numeric and logical covariates
>     mur <- solapply(murchison, rescale, s=1000, unitname="km")
>     mur$dfault <- distfun(mur$faults)
>     # 
>     mfit <- rppm(gold ~ dfault + greenstone, data=mur)
>     mfit
Point process model with recursive partitioning
Data: 'gold'
Covariates: 'dfault' and 'greenstone'
Regression tree:
n= 1859 

node), split, n, deviance, yval
      * denotes terminal node

1) root 1859 1643.178000 1.924569e-03  
  2) greenstone< 0.5 1490  373.333200 3.096288e-04  
    4) dfault>=6.291182 1209  114.392900 9.063533e-05  
      8) dfault>=16.78887 842    1.985145 1.429462e-05 *
      9) dfault< 16.78887 367   94.949200 3.013843e-04 *
    5) dfault< 6.291182 281  194.885500 1.399714e-03 *
  3) greenstone>=0.5 369  470.246600 1.567124e-02 *
>     # Gorillas data: factor covariates
>     #          (symbol '.' indicates 'all variables')
>     gfit <- rppm(unmark(gorillas) ~ . , data=gorillas.extra)
>     gfit
Point process model with recursive partitioning
Data: 'unmark(gorillas)'
Covariates: 'aspect', 'elevation', 'heat', 'slopeangle', 'slopetype', 
'vegetation' and 'waterdist'
Regression tree:
n= 3971 

node), split, n, deviance, yval
      * denotes terminal node

 1) root 3971 3566.9780 3.259441e-05  
   2) vegetation=Disturbed,Grassland,Secondary 2423 1030.7290 9.602489e-06  
     4) elevation< 1954.5 2338  856.0005 7.987095e-06  
       8) aspect=E,SE,S,SW 1110  151.9455 2.451562e-06 *
       9) aspect=N,NE,W,NW 1228  647.4577 1.343047e-05 *
     5) elevation>=1954.5 85  116.1135 6.474615e-05 *
   3) vegetation=Colonising,Primary,Transition 1548 1890.5100 8.262760e-05  
     6) elevation< 1908.5 1105 1218.7330 5.873376e-05  
      12) aspect=NE,E,SE,S 374  312.4463 3.149647e-05 *
      13) aspect=N,SW,W,NW 731  862.9750 7.567993e-05 *
     7) elevation>=1908.5 443  534.8989 1.709100e-04 *
> 
> 
> 
> cleanEx()
> nameEx("rshift.ppp")
> ### * rshift.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rshift.ppp
> ### Title: Randomly Shift a Point Pattern
> ### Aliases: rshift.ppp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    # random toroidal shift
>    # shift "on" and "off" points separately
>    X <- rshift(amacrine)
> 
>    # shift "on" points and leave "off" points fixed
>    X <- rshift(amacrine, which="on")
> 
>    # shift all points simultaneously
>    X <- rshift(amacrine, group=NULL)
> 
>    # maximum displacement distance 0.1 units
>    X <- rshift(amacrine, radius=0.1, nsim=2)
> 
>    # shift with erosion
>    X <- rshift(amacrine, radius=0.1, edge="erode")
> 
> 
> 
> cleanEx()
> nameEx("rshift.psp")
> ### * rshift.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rshift.psp
> ### Title: Randomly Shift a Line Segment Pattern
> ### Aliases: rshift.psp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   X <- psp(runif(20), runif(20), runif(20), runif(20),  window=owin())
>   Y <- rshift(X, radius=0.1)
> 
> 
> 
> cleanEx()
> nameEx("rshift.splitppp")
> ### * rshift.splitppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rshift.splitppp
> ### Title: Randomly Shift a List of Point Patterns
> ### Aliases: rshift.splitppp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    data(amacrine)
>    Y <- split(amacrine)
> 
>    # random toroidal shift
>    # shift "on" and "off" points separately
>    X <- rshift(Y)
> 
>    # shift "on" points and leave "off" points fixed
>    X <- rshift(Y, which="on")
> 
>    # maximum displacement distance 0.1 units
>    X <- rshift(Y, radius=0.1)
> 
>    # shift with erosion
>    X <- rshift(Y, radius=0.1, edge="erode")
> 
> 
> 
> cleanEx()
> nameEx("rstrat")
> ### * rstrat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rstrat
> ### Title: Simulate Stratified Random Point Pattern
> ### Aliases: rstrat
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   X <- rstrat(nx=10)
>   plot(X)
> 
>   # polygonal boundary
>   data(letterR)
>   X <- rstrat(letterR, 5, 10, k=3)
>   plot(X)
> 
> 
> 
> cleanEx()
> nameEx("rsyst")
> ### * rsyst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rsyst
> ### Title: Simulate systematic random point pattern
> ### Aliases: rsyst
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   X <- rsyst(nx=10)
>   plot(X)
> 
>   # polygonal boundary
>   data(letterR)
>   X <- rsyst(letterR, 5, 10)
>   plot(X)
> 
> 
> 
> cleanEx()
> nameEx("rtemper")
> ### * rtemper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rtemper
> ### Title: Simulated Annealing or Simulated Tempering for Gibbs Point
> ###   Processes
> ### Aliases: rtemper
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    stra <- rmhmodel(cif="strauss",
+                     par=list(beta=2,gamma=0.2,r=0.7),
+                     w=square(10))
>    nr <- if(interactive()) 1e5 else 1e4
>    Y <- rtemper(stra, c(1, 2, 4, 8), nr * (1:4), verbose=TRUE, track=TRUE)
Step 1 of 4: Running 10000 iterations at inverse temperature 1 ... Step 2 of 4: Running 20000 iterations at inverse temperature 2 ... Step 3 of 4: Running 30000 iterations at inverse temperature 4 ... Step 4 of 4: Running 40000 iterations at inverse temperature 8 ... Done.
> 
> 
> 
> cleanEx()
> nameEx("rthin")
> ### * rthin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rthin
> ### Title: Random Thinning
> ### Aliases: rthin
> ### Keywords: spatial datagen manip
> 
> ### ** Examples
> 
>   plot(redwood, main="thinning")
>   
>   # delete 20% of points
>   Y <- rthin(redwood, 0.8)
>   points(Y, col="green", cex=1.4)
> 
>   # function
>   f <- function(x,y) { ifelse(x < 0.4, 1, 0.5) }
>   Y <- rthin(redwood, f)
> 
>   # pixel image
>   Z <- as.im(f, Window(redwood))
>   Y <- rthin(redwood, Z)
> 
>   # pattern on a linear network
>   A <- runiflpp(30, simplenet)
>   B <- rthin(A, 0.2)
>   g <- function(x,y,seg,tp) { ifelse(y < 0.4, 1, 0.5) }
>   B <- rthin(A, linfun(g, simplenet))
> 
>   # thin other kinds of patterns
>   E <- rthin(osteo$pts[[1]], 0.6)
>   L <- rthin(copper$Lines, 0.5)
> 
> 
> 
> cleanEx()
> nameEx("rthinclumps")
> ### * rthinclumps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rthinclumps
> ### Title: Random Thinning of Clumps
> ### Aliases: rthinclumps
> ### Keywords: spatial datagen manip
> 
> ### ** Examples
> 
>   A <- (distmap(cells) < 0.06)
>   opa <- par(mfrow=c(1,2))
>   plot(A)
>   plot(rthinclumps(A, 0.5))
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("run.simplepanel")
> ### * run.simplepanel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: run.simplepanel
> ### Title: Run Point-and-Click Interface
> ### Aliases: clear.simplepanel redraw.simplepanel run.simplepanel
> ### Keywords: iplot utilities
> 
> ### ** Examples
> 
>   if(interactive()) {
+     # make boxes (alternatively use layout.boxes())
+     Bminus <- square(1)
+     Bvalue <- shift(Bminus, c(1.2, 0))
+     Bplus <- shift(Bvalue, c(1.2, 0))
+     Bdone <- shift(Bplus, c(1.2, 0))
+     myboxes <- list(Bminus, Bvalue, Bplus, Bdone)
+     myB <- do.call(boundingbox,myboxes)
+ 
+     # make environment containing an integer count
+     myenv <- new.env()
+     assign("answer", 0, envir=myenv)
+ 
+     # what to do when finished: return the count.
+     myexit <- function(e) { return(get("answer", envir=e)) }
+ 
+     # button clicks
+     # decrement the count
+     Cminus <- function(e, xy) {
+      ans <- get("answer", envir=e)
+      assign("answer", ans - 1, envir=e)
+      return(TRUE)
+    }
+    # display the count (clicking does nothing)
+    Cvalue <- function(...) { TRUE }
+    # increment the count
+    Cplus <- function(e, xy) {
+     ans <- get("answer", envir=e)
+     assign("answer", ans + 1, envir=e)
+     return(TRUE)
+    }
+    # quit button
+    Cdone <- function(e, xy) { return(FALSE) }
+ 
+    myclicks <- list("-"=Cminus,
+                     value=Cvalue,
+                     "+"=Cplus,
+                     done=Cdone)
+ 
+    # redraw the button that displays the current value of the count
+    Rvalue <- function(button, nam, e) {
+      plot(button, add=TRUE)
+      ans <- get("answer", envir=e)
+      text(centroid.owin(button), labels=ans)
+      return(TRUE)
+   }
+ 
+   # make the panel
+   P <- simplepanel("Counter",
+                    B=myB, boxes=myboxes,
+                    clicks=myclicks,
+                    redraws = list(NULL, Rvalue, NULL, NULL),
+                    exit=myexit, env=myenv)
+   P
+ 
+   run.simplepanel(P)
+   }
> 
> 
> 
> cleanEx()
> nameEx("runifdisc")
> ### * runifdisc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runifdisc
> ### Title: Generate N Uniform Random Points in a Disc
> ### Aliases: runifdisc
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # 100 random points in the unit disc
>  plot(runifdisc(100))
>  # 42 random points in the ellipse with major axis 3 and minor axis 1
>  X <- runifdisc(42)
>  Y <- affine(X, mat=diag(c(3,1)))
>  plot(Y)
> 
> 
> 
> cleanEx()
> nameEx("runiflpp")
> ### * runiflpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runiflpp
> ### Title: Uniform Random Points on a Linear Network
> ### Aliases: runiflpp
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    data(simplenet)
>    X <- runiflpp(10, simplenet)
>    plot(X)
>   # marked
>    Z <- runiflpp(c(a=10, b=3), simplenet)
> 
> 
> 
> cleanEx()
> nameEx("runifpoint")
> ### * runifpoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runifpoint
> ### Title: Generate N Uniform Random Points
> ### Aliases: runifpoint
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  # 100 random points in the unit square
>  pp <- runifpoint(100)
>  # irregular window
>  data(letterR)
>  # polygonal
>  pp <- runifpoint(100, letterR)
>  # binary image mask
>  pp <- runifpoint(100, as.mask(letterR))
>  ##
>  # randomising an existing point pattern
>  runifpoint(npoints(cells), win=Window(cells))
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
>  runifpoint(ex=cells)
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("runifpoint3")
> ### * runifpoint3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runifpoint3
> ### Title: Generate N Uniform Random Points in Three Dimensions
> ### Aliases: runifpoint3
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    X <- runifpoint3(50)
> 
> 
> 
> cleanEx()
> nameEx("runifpointOnLines")
> ### * runifpointOnLines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runifpointOnLines
> ### Title: Generate N Uniform Random Points On Line Segments
> ### Aliases: runifpointOnLines
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   X <- psp(runif(10), runif(10), runif(10), runif(10),  window=owin())
>   Y <- runifpointOnLines(20, X)
>   plot(X, main="")
>   plot(Y, add=TRUE)
>   Z <- runifpointOnLines(c(5,5), X)
> 
> 
> 
> cleanEx()
> nameEx("runifpointx")
> ### * runifpointx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runifpointx
> ### Title: Generate N Uniform Random Points in Any Dimensions
> ### Aliases: runifpointx
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>    w <- boxx(x=c(0,1), y=c(0,1), z=c(0,1), t=c(0,3))
>    X <- runifpointx(50, w)
> 
> 
> 
> cleanEx()
> nameEx("scalardilate")
> ### * scalardilate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scalardilate
> ### Title: Apply Scalar Dilation
> ### Aliases: scalardilate scalardilate.im scalardilate.owin
> ###   scalardilate.ppp scalardilate.psp scalardilate.default
> ### Keywords: spatial math
> 
> ### ** Examples
> 
> plot(letterR)
> plot(scalardilate(letterR, 0.7, origin="left"), col="red", add=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("scaletointerval")
> ### * scaletointerval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scaletointerval
> ### Title: Rescale Data to Lie Between Specified Limits
> ### Aliases: scaletointerval scaletointerval.default scaletointerval.im
> ### Keywords: spatial methods univar
> 
> ### ** Examples
> 
>   X <- as.im(function(x,y) {x+y+3}, unit.square())
>   summary(X)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
dimensions of each pixel: 0.00781 x 0.0078125 units
Image is defined on the full rectangular grid
Frame area = 1 square units
Pixel values
	range = [3.007812, 4.992188]
	integral = 4
	mean = 4
>   Y <- scaletointerval(X)
>   summary(Y)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
dimensions of each pixel: 0.00781 x 0.0078125 units
Image is defined on the full rectangular grid
Frame area = 1 square units
Pixel values
	range = [0, 1]
	integral = 0.5
	mean = 0.5
> 
> 
> 
> cleanEx()
> nameEx("scan.test")
> ### * scan.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scan.test
> ### Title: Spatial Scan Test
> ### Aliases: scan.test
> ### Keywords: htest spatial
> 
> ### ** Examples
> 
>    nsim <- if(interactive()) 19 else 2
>    rr <- if(interactive()) seq(0.5, 1, by=0.1) else c(0.5, 1)
>    scan.test(redwood, 0.1 * rr, method="poisson", nsim=nsim)
Simulating...1,  2.

	Spatial scan test
	Null hypothesis: Complete Spatial Randomness (CSR)
	Candidate cluster regions: circles of radius between 0.05 and 0.1
	Likelihood: Poisson
	Monte Carlo p-value based on 2 simulations

data:  redwood
maxLRTS = 17.464, p-value = 0.3333
alternative hypothesis: Excess of points inside cluster region

>    scan.test(chorley, rr, method="binomial", case="larynx", nsim=nsim)
Simulating...1,  2.

	Spatial scan test
	Null hypothesis: constant relative risk
	Candidate cluster regions: circles of radius between 0.5 and 1
	Likelihood: binomial
	Monte Carlo p-value based on 2 simulations

data:  chorley
maxLRTS = 15.905, p-value = 0.3333
alternative hypothesis: Excess of points with mark 'larynx' inside cluster region

> 
> 
> 
> cleanEx()
> nameEx("scanLRTS")
> ### * scanLRTS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scanLRTS
> ### Title: Likelihood Ratio Test Statistic for Scan Test
> ### Aliases: scanLRTS
> ### Keywords: htest spatial
> 
> ### ** Examples
> 
>    plot(scanLRTS(redwood, 0.1, method="poisson"))
>    sc <- scanLRTS(chorley, 1, method="binomial", case="larynx") 
>    plot(sc)
>    scanstatchorley <- max(sc)
> 
> 
> 
> cleanEx()
> nameEx("scanpp")
> ### * scanpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scanpp
> ### Title: Read Point Pattern From Data File
> ### Aliases: scanpp
> ### Keywords: spatial IO
> 
> ### ** Examples
> 
>   ##  files installed with spatstat, for demonstration
>   d <- system.file("rawdata", "finpines", package="spatstat.data")
>   if(nzchar(d)) {
+     W <- owin(c(-5,5), c(-8,2))
+     X <- scanpp("finpines.txt", dir=d, window=W)
+     print(X)
+   }
Marked planar point pattern: 126 points
Mark variables: diameter, height 
window: rectangle = [-5, 5] x [-8, 2] units
>   d <- system.file("rawdata", "amacrine", package="spatstat.data")
>   if(nzchar(d)) {
+     W <- owin(c(0, 1060/662), c(0, 1))
+     Y <- scanpp("amacrine.txt", dir=d, window=W, factor.marks=TRUE)
+     print(Y)
+   }
Marked planar point pattern: 294 points
Multitype, with levels = 0, 1 
window: rectangle = [0, 1.6012085] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("sdr")
> ### * sdr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sdr
> ### Title: Sufficient Dimension Reduction
> ### Aliases: sdr sdr.ppp
> ### Keywords: spatial multivariate
> 
> ### ** Examples
> 
>    A <- sdr(bei, bei.extra, predict=TRUE)
>    A
$B
             B1
elev -0.1287916
grad -2.1304562

$M
            Z1          Z2
Z1 0.066872522 0.004717838
Z2 0.004717838 0.026465945

$Y
List of pixel images

B1:
real-valued pixel image
101 x 201 pixel array (ny, nx)
enclosing rectangle: [-2.5, 1002.5] x [-2.5, 502.5] units

>    Y1 <- A$Y[[1]]
>    plot(Y1)
>    points(bei, pch=".", cex=2)
>    # investigate likely form of dependence
>    plot(rhohat(bei, Y1))
Warning in sprintf(legdesc, ylab) : argument not used by format
> 
> 
> 
> cleanEx()
> nameEx("sdrPredict")
> ### * sdrPredict
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sdrPredict
> ### Title: Compute Predictors from Sufficient Dimension Reduction
> ### Aliases: sdrPredict
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    A <- sdr(bei, bei.extra)
>    Y <- sdrPredict(bei.extra, A)
>    Y
List of pixel images

B1:
real-valued pixel image
101 x 201 pixel array (ny, nx)
enclosing rectangle: [-2.5, 1002.5] x [-2.5, 502.5] units
> 
> 
> 
> cleanEx()
> nameEx("segregation.test")
> ### * segregation.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: segregation.test
> ### Title: Test of Spatial Segregation of Types
> ### Aliases: segregation.test segregation.test.ppp
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   segregation.test(hyytiala, 5)
Computing observed value... Done.
Computing simulated values... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,  19.

	Monte Carlo test of spatial segregation of types

data:  hyytiala
T = 0.001111, p-value = 0.2

> 
>   if(interactive()) segregation.test(hyytiala, hmin=0.05) 
> 
> 
> 
> cleanEx()
> nameEx("selfcrossing.psp")
> ### * selfcrossing.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: selfcrossing.psp
> ### Title: Crossing Points in a Line Segment Pattern
> ### Aliases: selfcrossing.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(a, col="green", main="selfcrossing.psp")
>   P <- selfcrossing.psp(a)
>   plot(P, add=TRUE, col="red")
> 
> 
> 
> cleanEx()
> nameEx("selfcut.psp")
> ### * selfcut.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: selfcut.psp
> ### Title: Cut Line Segments Where They Intersect
> ### Aliases: selfcut.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   Y <- selfcut.psp(X)
>   n <- nsegments(Y)
>   plot(Y %mark% factor(sample(seq_len(n), n, replace=TRUE)))
> 
> 
> 
> cleanEx()
> nameEx("sessionLibs")
> ### * sessionLibs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sessionLibs
> ### Title: Print Names and Version Numbers of Libraries Loaded
> ### Aliases: sessionLibs
> ### Keywords: data
> 
> ### ** Examples
> 
>   sessionLibs()
Libraries loaded:
	 spatstat 1.64-1 
	 rpart 4.1-15 
	 nlme 3.1-149 
	 spatstat.data 1.4-3 
> 
> 
> 
> cleanEx()
> nameEx("setcov")
> ### * setcov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setcov
> ### Title: Set Covariance of a Window
> ### Aliases: setcov
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   w <- owin(c(0,1),c(0,1))
>   v <- setcov(w)
>   plot(v)
> 
> 
> 
> cleanEx()
> nameEx("sharpen")
> ### * sharpen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sharpen
> ### Title: Data Sharpening of Point Pattern
> ### Aliases: sharpen sharpen.ppp
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    data(shapley)
>    X <- unmark(shapley)
>    ## Don't show: 
>    if(!(interactive())) X <- rthin(X, 0.05)
>    
> ## End(Don't show)
>    Y <- sharpen(X, sigma=0.5)
>    Z <- sharpen(X, sigma=0.5, edgecorrect=TRUE)
>    opa <- par(mar=rep(0.2, 4))
>    plot(solist(X, Y, Z), main= " ",
+         main.panel=c("data", "sharpen", "sharpen, correct"),
+         pch=".", equal.scales=TRUE, mar.panel=0.2)
>    par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("shift.im")
> ### * shift.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shift.im
> ### Title: Apply Vector Translation To Pixel Image
> ### Aliases: shift.im
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  # make up an image
>  X <- setcov(unit.square())
>  plot(X)
> 
>  Y <- shift(X, c(10,10))
>  plot(Y)
>  # no discernible difference except coordinates are different
> 
>  shift(X, origin="c")
real-valued pixel image
257 x 257 pixel array (ny, nx)
enclosing rectangle: [-1, 1] x [-1, 1] units
> 
> 
> 
> cleanEx()
> nameEx("shift.owin")
> ### * shift.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shift.owin
> ### Title: Apply Vector Translation To Window
> ### Aliases: shift.owin
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   W <- owin(c(0,1),c(0,1))
>   X <- shift(W, c(2,3))
>   ## Not run: 
> ##D   plot(W)
> ##D   # no discernible difference except coordinates are different
> ##D   
> ## End(Not run)
>   shift(W, origin="top")
window: rectangle = [-0.5, 0.5] x [-1, 0] units
> 
> 
> 
> cleanEx()
> nameEx("shift.ppp")
> ### * shift.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shift.ppp
> ### Title: Apply Vector Translation To Point Pattern
> ### Aliases: shift.ppp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(cells)
>   X <- shift(cells, c(2,3))
>   ## Not run: 
> ##D   plot(X)
> ##D   # no discernible difference except coordinates are different
> ##D   
> ## End(Not run)
>   plot(cells, pch=16)
>   plot(shift(cells, c(0.03,0.03)), add=TRUE)
> 
>   shift(cells, origin="mid")
Planar point pattern: 42 points
window: rectangle = [-0.5, 0.5] x [-0.5, 0.5] units
> 
> 
> 
> cleanEx()
> nameEx("shift.psp")
> ### * shift.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shift.psp
> ### Title: Apply Vector Translation To Line Segment Pattern
> ### Aliases: shift.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   plot(X, col="red")
>   Y <- shift(X, c(0.05,0.05))
>   plot(Y, add=TRUE, col="blue")
> 
>   shift(Y, origin="mid")
planar line segment pattern: 10 line segments
window: rectangle = [-0.5, 0.5] x [-0.5, 0.5] units
> 
> 
> 
> cleanEx()
> nameEx("sidelengths.owin")
> ### * sidelengths.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sidelengths.owin
> ### Title: Side Lengths of Enclosing Rectangle of a Window
> ### Aliases: sidelengths.owin shortside.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   w <- owin(c(0,2),c(-1,3))
>   sidelengths(w)
[1] 2 4
>   shortside(as.rectangle(letterR))
[1] 1.913
> 
> 
> 
> cleanEx()
> nameEx("simplepanel")
> ### * simplepanel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simplepanel
> ### Title: Simple Point-and-Click Interface Panels
> ### Aliases: simplepanel grow.simplepanel
> ### Keywords: iplot utilities
> 
> ### ** Examples
> 
>   # make boxes (alternatively use layout.boxes())
>   Bminus <- square(1)
>   Bvalue <- shift(Bminus, c(1.2, 0))
>   Bplus <- shift(Bvalue, c(1.2, 0))
>   Bdone <- shift(Bplus, c(1.2, 0))
>   myboxes <- list(Bminus, Bvalue, Bplus, Bdone)
>   myB <- do.call(boundingbox,myboxes)
> 
>   # make environment containing an integer count
>   myenv <- new.env()
>   assign("answer", 0, envir=myenv)
> 
>   # what to do when finished: return the count.
>   myexit <- function(e) { return(get("answer", envir=e)) }
> 
>   # button clicks
>   # decrement the count
>   Cminus <- function(e, xy) {
+     ans <- get("answer", envir=e)
+     assign("answer", ans - 1, envir=e)
+     return(TRUE)
+   }
>   # display the count (clicking does nothing)
>   Cvalue <- function(...) { TRUE }
>   # increment the count
>   Cplus <- function(e, xy) {
+     ans <- get("answer", envir=e)
+     assign("answer", ans + 1, envir=e)
+     return(TRUE)
+   }
>   # 'Clear' button
>   Cclear <- function(e, xy) {
+     assign("answer", 0, envir=e)
+     return(TRUE)
+   }
>   # quit button
>   Cdone <- function(e, xy) { return(FALSE) }
> 
>   myclicks <- list("-"=Cminus,
+                    value=Cvalue,
+                    "+"=Cplus,
+                    done=Cdone)
> 
>   # redraw the button that displays the current value of the count
>   Rvalue <- function(button, nam, e) {
+      plot(button, add=TRUE)
+      ans <- get("answer", envir=e)
+      text(centroid.owin(button), labels=ans)
+      return(TRUE)
+   }
> 
>   # make the panel
>   P <- simplepanel("Counter",
+                    B=myB, boxes=myboxes,
+                    clicks=myclicks,
+                    redraws = list(NULL, Rvalue, NULL, NULL),
+                    exit=myexit, env=myenv)
>   # print it
>   P
simplepanel object
	Title: 'Counter' 
	Panel names:
	'-'  'value'  '+'  'done'  
>   # show what it looks like
>   redraw.simplepanel(P)
> 
>   # ( type run.simplepanel(P) to run the panel interactively )
> 
>   # add another button to right
>   Pplus <- grow.simplepanel(P, "right", new.clicks=list(clear=Cclear))
> 
> 
> 
> cleanEx()
> nameEx("simplify.owin")
> ### * simplify.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simplify.owin
> ### Title: Approximate a Polygon by a Simpler Polygon
> ### Aliases: simplify.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   plot(letterR, col="red")
>   plot(simplify.owin(letterR, 0.3), col="blue", add=TRUE)
> 
>   W <- Window(chorley)
>   plot(W)
>   WS <- simplify.owin(W, 2)
>   plot(WS, add=TRUE, border="green")
>   points(vertices(WS))
> 
> 
> 
> cleanEx()
> nameEx("simulate.dppm")
> ### * simulate.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.dppm
> ### Title: Simulation of Determinantal Point Process Model
> ### Aliases: simulate.dppm simulate.detpointprocfamily
> ### Keywords: datagen spatial models
> 
> ### ** Examples
> 
> model <- dppGauss(lambda=100, alpha=.05, d=2)
> simulate(model, 2)
List of point patterns

Simulation 1:
Planar point pattern: 104 points
window: rectangle = [0, 1] x [0, 1] units

Simulation 2:
Planar point pattern: 108 points
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("simulate.kppm")
> ### * simulate.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.kppm
> ### Title: Simulate a Fitted Cluster Point Process Model
> ### Aliases: simulate.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- kppm(redwood ~1, "Thomas")
>   simulate(fit, 2)
Generating 2 simulations... 1,  2.
Done.
List of point patterns

Simulation 1:
Planar point pattern: 73 points
window: rectangle = [0, 1] x [-1, 0] units

Simulation 2:
Planar point pattern: 69 points
window: rectangle = [0, 1] x [-1, 0] units

Time taken: 0 sec 
>   fitx <- kppm(redwood ~x, "Thomas")
>   simulate(fitx, 2)
Generating 2 simulations... 1,  2.
Done.
List of point patterns

Simulation 1:
Planar point pattern: 69 points
window: rectangle = [0, 1] x [-1, 0] units

Simulation 2:
Planar point pattern: 44 points
window: rectangle = [0, 1] x [-1, 0] units

Time taken: 0 sec 
> 
> 
> 
> cleanEx()
> nameEx("simulate.lppm")
> ### * simulate.lppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.lppm
> ### Title: Simulate a Fitted Point Process Model on a Linear Network
> ### Aliases: simulate.lppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   fit <- lppm(unmark(chicago) ~ y)
>   simulate(fit)[[1]]
Point pattern on linear network
111 points
Linear network with 338 vertices and 503 lines
Enclosing window: rectangle = [0.3894, 1281.9863] x [153.1035, 1276.5602] feet
> 
> 
> 
> cleanEx()
> nameEx("simulate.mppm")
> ### * simulate.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.mppm
> ### Title: Simulate a Point Process Model Fitted to Several Point Patterns
> ### Aliases: simulate.mppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   H <- hyperframe(Bugs=waterstriders)
>   fit <- mppm(Bugs ~ id, H)
>   y <- simulate(fit, nsim=2)
Generating simulated realisations of 3 models..
1, 2,  3.
>   y
Hyperframe:
    Sim1  Sim2
X1 (ppp) (ppp)
X2 (ppp) (ppp)
X3 (ppp) (ppp)
>   plot(y[1,,drop=TRUE], main="Simulations for Waterstriders pattern 1")
>   plot(y[,1,drop=TRUE], main="Simulation 1 for each Waterstriders pattern")
> 
> 
> 
> cleanEx()
> nameEx("simulate.ppm")
> ### * simulate.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.ppm
> ### Title: Simulate a Fitted Gibbs Point Process Model
> ### Aliases: simulate.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   ## Don't show: 
> op <- spatstat.options(rmh.nrep=10)
> ## End(Don't show)
>   fit <- ppm(japanesepines, ~1, Strauss(0.1))
>   simulate(fit, 2)
Generating 2 simulated patterns ...1,  2.
List of point patterns

Simulation 1:
Planar point pattern: 57 points
window: rectangle = [0, 1] x [0, 1] units (one unit = 5.7 metres)

Simulation 2:
Planar point pattern: 40 points
window: rectangle = [0, 1] x [0, 1] units (one unit = 5.7 metres)

Time taken: 0.02 sec 
>   simulate(fit, 2, singlerun=TRUE, nsave=1e4, nburn=1e4)
Generating 2 simulated patterns in a single run ... Done.
List of point patterns

Iteration_10000:
Planar point pattern: 59 points
window: rectangle = [0, 1] x [0, 1] units (one unit = 5.7 metres)

Iteration_20000:
Planar point pattern: 51 points
window: rectangle = [0, 1] x [0, 1] units (one unit = 5.7 metres)

Time taken: 0.04 sec 
>   ## Don't show: 
> spatstat.options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("simulate.slrm")
> ### * simulate.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.slrm
> ### Title: Simulate a Fitted Spatial Logistic Regression Model
> ### Aliases: simulate.slrm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   X <- copper$SouthPoints
>   fit <- slrm(X ~ 1)
>   simulate(fit, 2)
Generating 2 simulations... 1,  2.
List of point patterns

Simulation 1:
Planar point pattern: 52 points
window: rectangle = [-0.335, 35] x [0.19, 158.233] km

Simulation 2:
Planar point pattern: 47 points
window: rectangle = [-0.335, 35] x [0.19, 158.233] km

Time taken: 0 sec 
>   fitxy <- slrm(X ~ x+y)
>   simulate(fitxy, 2, window=square(2))
Generating 2 simulations... 1,  2.
List of point patterns

Simulation 1:
Planar point pattern: 0 points
window: rectangle = [0, 2] x [0, 2] km

Simulation 2:
Planar point pattern: 0 points
window: rectangle = [0, 2] x [0, 2] km

Time taken: 0.02 sec 
> 
> 
> 
> cleanEx()
> nameEx("slrm")
> ### * slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: slrm
> ### Title: Spatial Logistic Regression
> ### Aliases: slrm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>      X <- copper$SouthPoints
>      slrm(X ~ 1)
Fitted spatial logistic regression model
Formula:	X ~ 1
Fitted coefficients:
(Intercept) 
  -4.581205 
>      slrm(X ~ x+y)
Fitted spatial logistic regression model
Formula:	X ~ x + y
Fitted coefficients:
 (Intercept)            x            y 
-5.203904256  0.018556076  0.003424553 
> 
>      slrm(X ~ x+y, link="cloglog")
Fitted spatial regression model (complementary log-log)
Formula:	X ~ x + y
Fitted coefficients:
 (Intercept)            x            y 
-5.204094033  0.018508818  0.003415603 
>      # specify a grid of 2-km-square pixels
>      slrm(X ~ 1, eps=2)
Fitted spatial logistic regression model
Formula:	X ~ 1
Fitted coefficients:
(Intercept) 
  -4.639718 
> 
>      Y <- copper$SouthLines
>      Z <- distmap(Y)
>      slrm(X ~ Z)
Fitted spatial logistic regression model
Formula:	X ~ Z
Fitted coefficients:
(Intercept)           Z 
-4.72337865  0.07811134 
>      slrm(X ~ Z, dataAtPoints=list(Z=nncross(X,Y,what="dist")))
Fitted spatial logistic regression model
Formula:	X ~ Z
Fitted coefficients:
(Intercept)           Z 
-4.70379451  0.06776426 
> 
>      mur <- murchison
>      mur$dfault <- distfun(mur$faults)
>      slrm(gold ~ dfault, data=mur)
Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred
Fitted spatial logistic regression model
Formula:	gold ~ dfault
Fitted coefficients:
  (Intercept)        dfault 
-1.817815e+01 -2.705822e-04 
>      slrm(gold ~ dfault + greenstone, data=mur)
Fitted spatial logistic regression model
Formula:	gold ~ dfault + greenstone
Fitted coefficients:
   (Intercept)         dfault greenstoneTRUE 
 -1.986220e+01  -1.431173e-04   2.294411e+00 
>      slrm(gold ~ dfault, data=mur, splitby="greenstone")
Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred
Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred
Fitted spatial logistic regression model
Formula:	gold ~ dfault
Fitted coefficients:
  (Intercept)        dfault 
-1.818200e+01 -2.701868e-04 
> 
> 
> 
> cleanEx()
> nameEx("solapply")
> ### * solapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: solapply
> ### Title: Apply a Function Over a List and Obtain a List of Objects
> ### Aliases: solapply anylapply
> ### Keywords: spatial list manip
> 
> ### ** Examples
> 
>   solapply(waterstriders, density)
List of pixel images

Component 1:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 48.1] x [0, 48.1] cm

Component 2:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 48.8] x [0, 48.8] cm

Component 3:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 46.4] x [0, 46.4] cm
> 
> 
> 
> cleanEx()
> nameEx("solist")
> ### * solist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: solist
> ### Title: List of Two-Dimensional Spatial Objects
> ### Aliases: solist
> ### Keywords: spatial list manip
> 
> ### ** Examples
> 
>   solist(cells, density(cells))
List of spatial objects

Component 1:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units

Component 2:
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   solist(cells, japanesepines, redwood, .NameBase="Pattern")
List of point patterns

Pattern 1:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units

Pattern 2:
Planar point pattern: 65 points
window: rectangle = [0, 1] x [0, 1] units (one unit = 5.7 metres)

Pattern 3:
Planar point pattern: 62 points
window: rectangle = [0, 1] x [-1, 0] units
> 
> 
> 
> cleanEx()
> nameEx("solutionset")
> ### * solutionset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: solutionset
> ### Title: Evaluate Logical Expression Involving Pixel Images and Return
> ###   Region Where Expression is True
> ### Aliases: solutionset
> ### Keywords: spatial programming manip
> 
> ### ** Examples
> 
>   # test images
>   X <- as.im(function(x,y) { x^2 - y^2 }, unit.square())
>   Y <- as.im(function(x,y) { 3 * x + y  - 1}, unit.square())
> 
>   W <- solutionset(abs(X) > 0.1)
>   W <- solutionset(X > Y)
>   W <- solutionset(X + Y >= 1)
> 
>   area(solutionset(X < Y))
[1] 0.8726807
> 
>   solutionset(density(cells) > 20)
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("spatdim")
> ### * spatdim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spatdim
> ### Title: Spatial Dimension of a Dataset
> ### Aliases: spatdim
> 
> ### ** Examples
> 
>   spatdim(lansing)
[1] 2
>   A <- osteo$pts[[1]]
>   spatdim(A)
[1] 3
>   spatdim(domain(A))
[1] 3
>   spatdim(chicago)
[1] 2
>   spatdim(chicago, intrinsic=TRUE)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("spatialcdf")
> ### * spatialcdf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spatialcdf
> ### Title: Spatial Cumulative Distribution Function
> ### Aliases: spatialcdf
> ### Keywords: spatial nonparametric
> 
> ### ** Examples
> 
>    with(bei.extra, {
+      plot(spatialcdf(grad))
+      fit <- ppm(bei ~ elev)
+      plot(spatialcdf(grad, predict(fit)))
+      plot(A <- spatialcdf(grad, fit))
+      A(0.1)
+   })
[1] 2558.203
>   plot(spatialcdf("x", W=letterR))
> 
> 
> 
> cleanEx()
> nameEx("spatstat.options")
> ### * spatstat.options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spatstat.options
> ### Title: Internal Options in Spatstat Package
> ### Aliases: spatstat.options reset.spatstat.options
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   # save current values whatever they are
>   oldopt <- spatstat.options()
> 
>   spatstat.options("npixel")
[1] 128
>   spatstat.options(npixel=150)
>   spatstat.options(npixel=c(100,200))
> 
>   spatstat.options(par.binary=list(col=grey(c(0.5,1))))
> 
>   spatstat.options(par.persp=list(theta=-30,phi=40,d=4))
>   # see help(persp.default) for other options
> 
>   # revert to the state at the beginning of these examples
>   spatstat.options(oldopt)
> 
>   # revert to 'factory defaults'
>   reset.spatstat.options()
> 
> 
> 
> cleanEx()
> nameEx("split.hyperframe")
> ### * split.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split.hyperframe
> ### Title: Divide Hyperframe Into Subsets and Reassemble
> ### Aliases: split.hyperframe split<-.hyperframe
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    split(pyramidal, pyramidal$group)
$control
Hyperframe:
   Neurons   group
1    (ppp) control
2    (ppp) control
3    (ppp) control
4    (ppp) control
5    (ppp) control
6    (ppp) control
7    (ppp) control
8    (ppp) control
9    (ppp) control
10   (ppp) control
11   (ppp) control
12   (ppp) control

$schizoaffective
Hyperframe:
   Neurons           group
13   (ppp) schizoaffective
14   (ppp) schizoaffective
15   (ppp) schizoaffective
16   (ppp) schizoaffective
17   (ppp) schizoaffective
18   (ppp) schizoaffective
19   (ppp) schizoaffective
20   (ppp) schizoaffective
21   (ppp) schizoaffective

$schizophrenic
Hyperframe:
   Neurons         group
22   (ppp) schizophrenic
23   (ppp) schizophrenic
24   (ppp) schizophrenic
25   (ppp) schizophrenic
26   (ppp) schizophrenic
27   (ppp) schizophrenic
28   (ppp) schizophrenic
29   (ppp) schizophrenic
30   (ppp) schizophrenic
31   (ppp) schizophrenic

> 
> 
> 
> cleanEx()
> nameEx("split.im")
> ### * split.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split.im
> ### Title: Divide Image Into Sub-images
> ### Aliases: split.im
> ### Keywords: spatial methods manip
> 
> ### ** Examples
> 
>   W <- square(1)
>   X <- as.im(function(x,y){sqrt(x^2+y^2)}, W)
>   Y <- dirichlet(runifpoint(12, W))
>   plot(split(X,Y))
> 
> 
> 
> cleanEx()
> nameEx("split.msr")
> ### * split.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split.msr
> ### Title: Divide a Measure into Parts
> ### Aliases: split.msr
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   ## split by tessellation
>   a <- residuals(ppm(cells ~ x))
>   aa <- split(a, dirichlet(runifpoint(4)))
>   aa
List of spatial objects

1:
Scalar-valued measure
Approximated by 415 quadrature points
window: polygonal boundary
enclosing rectangle: [0, 0.894917] x [0, 0.598823] units
15 atoms
Total mass:
discrete = 15   continuous = -15.809   total = -0.80927

2:
Scalar-valued measure
Approximated by 240 quadrature points
window: polygonal boundary
enclosing rectangle: [0, 0.551401] x [0.518564, 1] units
10 atoms
Total mass:
discrete = 10   continuous = -8.8601   total = 1.1399

3:
Scalar-valued measure
Approximated by 100 quadrature points
window: polygonal boundary
enclosing rectangle: [0.454395, 0.907514] x [0.579311, 1] units
3 atoms
Total mass:
discrete = 3   continuous = -4.1008   total = -1.1008

4:
Scalar-valued measure
Approximated by 315 quadrature points
window: polygonal boundary
enclosing rectangle: [0.524478, 1] x [0, 1] units
14 atoms
Total mass:
discrete = 14   continuous = -13.23   total = 0.77023
>   sapply(aa, integral)
         1          2          3          4 
-0.8092675  1.1398550 -1.1008196  0.7702321 
> 
>   ## split by type of point
>   b <- residuals(ppm(amacrine ~ marks + x))
>   bb <- split(b)
>   bb
List of spatial objects

off:
Scalar-valued measure
Approximated by 1898 quadrature points
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
142 atoms
Total mass:
discrete = 142   continuous = -142   total = -1.0549e-07

on:
Scalar-valued measure
Approximated by 1898 quadrature points
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
152 atoms
Total mass:
discrete = 152   continuous = -152   total = -4.4968e-08
> 
> 
> 
> cleanEx()
> nameEx("split.ppp")
> ### * split.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split.ppp
> ### Title: Divide Point Pattern into Sub-patterns
> ### Aliases: split.ppp split<-.ppp
> ### Keywords: spatial methods manip
> 
> ### ** Examples
> 
> 
> # (1) Splitting by marks
> 
> # Multitype point pattern: separate into types
>  u <- split(amacrine)
> 
> # plot them
>  plot(split(amacrine))
> 
> # the following are equivalent:
>  amon <- split(amacrine)$on
>  amon <- unmark(amacrine[amacrine$marks == "on"])
>  amon <- subset(amacrine, marks == "on", -marks)
>    
> # the following are equivalent:
>  amon <- split(amacrine, un=FALSE)$on
>  amon <- amacrine[amacrine$marks == "on"]
>    
> # Scramble the locations of the 'on' cells
>  X <- amacrine
>  u <- split(X)
>  u$on <- runifpoint(ex=amon)
>  split(X) <- u
> 
> # Point pattern with continuous marks
>  trees <- longleaf
>  ## Don't show: 
> 	# smaller dataset
> 	trees <- trees[seq(1, npoints(trees), by=80)]
>  
> ## End(Don't show)
>  # cut the range of tree diameters into three intervals
>  # using cut.ppp
>  long3 <- cut(trees, breaks=3)
>  # now split them
>  long3split <- split(long3)
> 
> # (2) Splitting by a factor
> 
> # Unmarked point pattern
>   swedishpines
Planar point pattern: 71 points
window: rectangle = [0, 96] x [0, 100] units (one unit = 0.1 metres)
> # cut & split according to nearest neighbour distance
>   f <- cut(nndist(swedishpines), 3)
>   u <- split(swedishpines, f)
> 
> # (3) Splitting over a tessellation
>    tes <- tess(xgrid=seq(0,96,length=5),ygrid=seq(0,100,length=5))
>    v <- split(swedishpines, tes)
> 
> 
> # (4) how to apply an operation to selected points:
> #  split into components, transform desired component, then un-split
> #  e.g. apply random jitter to 'on' points only
>   X <- amacrine
>   Y <- split(X)
>   Y$on <- rjitter(Y$on, 0.1)
>   split(X) <- Y
> 
> 
> 
> cleanEx()
> nameEx("split.ppx")
> ### * split.ppx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split.ppx
> ### Title: Divide Multidimensional Point Pattern into Sub-patterns
> ### Aliases: split.ppx
> ### Keywords: spatial methods manip
> 
> ### ** Examples
> 
>    df <- data.frame(x=runif(4),y=runif(4),t=runif(4),
+                     age=factor(rep(c("old", "new"), 2)),
+                     size=runif(4))
>    X <- ppx(data=df, coord.type=c("s","s","t","m","m"))
>    X
Multidimensional point pattern
4 points 
2-dimensional space coordinates (x,y)
1-dimensional time coordinates (t)
2 columns of marks: 'age' and 'size' 
>    split(X)
Multidimensional point pattern split by factor 

new:
Multidimensional point pattern
2 points 
2-dimensional space coordinates (x,y)
1-dimensional time coordinates (t)
2 columns of marks: 'age' and 'size' 

old:
Multidimensional point pattern
2 points 
2-dimensional space coordinates (x,y)
1-dimensional time coordinates (t)
2 columns of marks: 'age' and 'size' 
> 
> 
> 
> cleanEx()
> nameEx("spokes")
> ### * spokes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spokes
> ### Title: Spokes pattern of dummy points
> ### Aliases: spokes
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   dat <- runifrect(10)
>   dum <- spokes(dat$x, dat$y, 5, 3, 0.7)
>   plot(dum)
>   Q <- quadscheme(dat, dum, method="dirichlet")
>   plot(Q, tiles=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("square")
> ### * square
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: square
> ### Title: Square Window
> ### Aliases: square unit.square
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>  W <- square(10)
>  W <- square(c(-1,1))
> 
> 
> 
> cleanEx()
> nameEx("ssf")
> ### * ssf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ssf
> ### Title: Spatially Sampled Function
> ### Aliases: ssf
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   ssf(cells, nndist(cells, k=1:3))
Spatially sampled function
Locations:
	Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
3-vector valued function
Component names: 'dist.1', 'dist.2' and 'dist.3'
> 
> 
> 
> cleanEx()
> nameEx("stieltjes")
> ### * stieltjes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stieltjes
> ### Title: Compute Integral of Function Against Cumulative Distribution
> ### Aliases: stieltjes
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # estimate cdf of nearest neighbour distance in redwood data
>   G <- Gest(redwood)
>   # compute estimate of mean nearest neighbour distance
>   stieltjes(function(x){x}, G)
$theo
[1] 0.06326011

$han
[1] 0.03397568

$rs
[1] 0.03634661

$km
[1] 0.03705788

$hazard
[1] -2.663955

$theohaz
[1] 11.49044

>   # estimated probability of a distance in the interval [0.1,0.2]
>   stieltjes(function(x,a,b){ (x >= a) & (x <= b)}, G, a=0.1, b=0.2)
$theo
[1] 0.1411226

$han
[1] 0.024748

$rs
[1] 0.05555556

$km
[1] 0.06967213

$hazard
[1] 0

$theohaz
[1] 39.03068

> 
>   # stepfun example
>   H <- spatialcdf(bei.extra$elev, normalise=TRUE)
>   stieltjes(function(x){x}, H)
[[1]]
[1] 144.2534

> 
> 
> 
> cleanEx()
> nameEx("stienen")
> ### * stienen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stienen
> ### Title: Stienen Diagram
> ### Aliases: stienen stienenSet
> ### Keywords: spatial math manip
> 
> ### ** Examples
> 
>   Y <- stienenSet(cells)
>   stienen(redwood)
>   stienen(redwood, border=list(bg=NULL, lwd=2, cols="red"))
> 
> 
> 
> cleanEx()
> nameEx("stratrand")
> ### * stratrand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stratrand
> ### Title: Stratified random point pattern
> ### Aliases: stratrand
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   w <- unit.square()
>   xy <- stratrand(w, 10, 10)
>   ## Not run: 
> ##D   plot(w)
> ##D   points(xy)
> ##D   
> ## End(Not run)
> 
>   # polygonal boundary
>   bdry <- list(x=c(0.1,0.3,0.7,0.4,0.2),
+                y=c(0.1,0.1,0.5,0.7,0.3))
>   w <- owin(c(0,1), c(0,1), poly=bdry)
>   xy <- stratrand(w, 10, 10, 3)
>   ## Not run: 
> ##D   plot(w)
> ##D   points(xy)
> ##D   
> ## End(Not run)
>   # determine which grid points are inside polygon
>   ok <- inside.owin(xy$x, xy$y, w)
>   ## Not run: 
> ##D   plot(w)
> ##D   points(xy$x[ok], xy$y[ok])
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("studpermu.test")
> ### * studpermu.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: studpermu.test
> ### Title: Studentised Permutation Test
> ### Aliases: studpermu.test
> ### Keywords: spatial htest
> 
> ### ** Examples
> 
>   np <- if(interactive()) 99 else 19
>   testpyramidal <- studpermu.test(pyramidal, Neurons ~ group, nperm=np)
Warning: 5 patterns have been discarded because they contained fewer than 20 points
>   testpyramidal

	Studentized permutation test for grouped point patterns
	Neurons ~ group
	3 groups: control, schizoaffective, schizophrenic
	summary function: Kest, evaluated on r in [0, 0.25]
	test statistic: T, 19 random permutations

data:  pyramidal
T = 2.3992, p-value = 0.05
alternative hypothesis: not the same K-function

> 
> 
> 
> cleanEx()
> nameEx("subfits")
> ### * subfits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subfits
> ### Title: Extract List of Individual Point Process Models
> ### Aliases: subfits subfits.new subfits.old
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   H <- hyperframe(Wat=waterstriders)
>   fit <- mppm(Wat~x, data=H)
>   subfits(fit)
X1:
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-4.000768330 -0.005581893 

                Estimate       S.E.     CI95.lo     CI95.hi Ztest        Zval
(Intercept) -4.000768330 0.31775417 -4.62355506 -3.37798160   *** -12.5907657
x           -0.005581893 0.01184178 -0.02879136  0.01762757        -0.4713727

X2:
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-4.000768330 -0.005581893 

                Estimate       S.E.     CI95.lo     CI95.hi Ztest        Zval
(Intercept) -4.000768330 0.31333866 -4.61490083 -3.38663583   *** -12.7681924
x           -0.005581893 0.01151612 -0.02815307  0.01698928        -0.4847026

X3:
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-4.000768330 -0.005581893 

                Estimate       S.E.     CI95.lo     CI95.hi Ztest        Zval
(Intercept) -4.000768330 0.32893317 -4.64546550 -3.35607116   *** -12.1628606
x           -0.005581893 0.01269381 -0.03046131  0.01929753        -0.4397333
> 
>   H$Wat[[3]] <- rthin(H$Wat[[3]], 0.1)
>   fit2 <- mppm(Wat~x, data=H, random=~1|id)
iteration 1 
iteration 2 
iteration 3 
iteration 4 
>   subfits(fit2)
X1:
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-3.995048714 -0.006813536 

                Estimate       S.E.     CI95.lo     CI95.hi Ztest        Zval
(Intercept) -3.995048714 0.31912332 -4.62051892 -3.36957850   *** -12.5188242
x           -0.006813536 0.01198591 -0.03030548  0.01667841        -0.5684623

X2:
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-4.070940722 -0.006813536 

                Estimate       S.E.     CI95.lo     CI95.hi Ztest      Zval
(Intercept) -4.070940722 0.32689178 -4.71163683 -3.43024462   *** -12.45348
x           -0.006813536 0.01210972 -0.03054816  0.01692109        -0.56265

X3:
Nonstationary Poisson process

Log intensity:  ~x

Fitted trend coefficients:
 (Intercept)            x 
-5.425867240 -0.006813536 

                Estimate       S.E.     CI95.lo     CI95.hi Ztest       Zval
(Intercept) -5.425867240 0.67555409 -6.74992892 -4.10180556   *** -8.0317288
x           -0.006813536 0.02626585 -0.05829365  0.04466658       -0.2594067
> 
>   ## Don't show: 
> a <- subfits.new(fit)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("subset.hyperframe")
> ### * subset.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subset.hyperframe
> ### Title: Subset of Hyperframe Satisfying A Condition
> ### Aliases: subset.hyperframe
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  a <- subset(flu, virustype=="wt")
> 
>  aa <- subset(flu, minnndist(pattern) > 10)
> 
>  aaa <- subset(flu, virustype=="wt", select = -pattern)
> 
> 
> 
> cleanEx()
> nameEx("subset.ppp")
> ### * subset.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subset.ppp
> ### Title: Subset of Point Pattern Satisfying A Condition
> ### Aliases: subset.ppp subset.pp3 subset.lpp subset.ppx
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  plot(subset(cells, x > 0.5))
> 
>  subset(amacrine, marks == "on")
Marked planar point pattern: 152 points
Multitype, with levels = off, on 
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
> 
>  subset(amacrine, marks == "on", drop=TRUE)
Marked planar point pattern: 152 points
Multitype, with levels = on 
window: rectangle = [0, 1.6012085] x [0, 1] units (one unit = 662 microns)
> 
>  subset(redwood, nndist(redwood) > 0.04)
Planar point pattern: 21 points
window: rectangle = [0, 1] x [-1, 0] units
> 
>  subset(finpines, select=height)
Marked planar point pattern: 126 points
marks are numeric, of storage type  'double'
window: rectangle = [-5, 5] x [-8, 2] metres
> 
>  subset(finpines, diameter > 2, height)
Marked planar point pattern: 57 points
marks are numeric, of storage type  'double'
window: rectangle = [-5, 5] x [-8, 2] metres
> 
>  subset(nbfires, year==1999 & ign.src == "campfire",
+                  select=cause:fnl.size)
Marked planar point pattern: 31 points
Mark variables: cause, ign.src, fnl.size 
window: polygonal boundary
enclosing rectangle: [0, 1000] x [0, 958.9142] units (one unit = 0.403716 km)
> 
>  v <- subset(chicago, x + y > 1100 & marks == "assault")
> 
>  vv <- subset(chicago, x + y > 1100 & marks == "assault", drop=TRUE)
> 
>  a <- subset(rpoispp3(40), z > 0.5)
> 
> 
> 
> cleanEx()
> nameEx("subset.psp")
> ### * subset.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subset.psp
> ### Title: Subset of Line Segment Satisfying A Condition
> ### Aliases: subset.psp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>  plot(nbw.seg)
>  plot(subset(nbw.seg, x0 < 500 & y0 < 800), add=TRUE, lwd=6)
>  subset(nbw.seg, type == "island")
marked planar line segment pattern: 371 line segments
Mark variables:  type, share, full
window: rectangle = [0, 1000] x [0, 958.9142] units (one unit = 0.403716 km)
>  subset(nbw.seg, type == "coast", select= -type)
marked planar line segment pattern: 376 line segments
Mark variables:  share, full
window: rectangle = [0, 1000] x [0, 958.9142] units (one unit = 0.403716 km)
>  subset(nbw.seg, type %in% c("island", "coast"), select= FALSE)
planar line segment pattern: 747 line segments
window: rectangle = [0, 1000] x [0, 958.9142] units (one unit = 0.403716 km)
> 
> 
> 
> cleanEx()
> nameEx("suffstat")
> ### * suffstat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: suffstat
> ### Title: Sufficient Statistic of Point Process Model
> ### Aliases: suffstat
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     fitS <- ppm(swedishpines~1, Strauss(7))
>     suffstat(fitS)
(Intercept) Interaction 
         56          10 
>     X <- rpoispp(intensity(swedishpines), win=Window(swedishpines))
>     suffstat(fitS, X)
(Intercept) Interaction 
         52          28 
> 
> 
> 
> cleanEx()
> nameEx("summary.anylist")
> ### * summary.anylist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.anylist
> ### Title: Summary of a List of Things
> ### Aliases: summary.anylist
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   x <- anylist(A=runif(10), B=runif(10), C=runif(10))
>   summary(x)
A:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.06179 0.29216 0.60098 0.55151 0.83899 0.94468 

B:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1766  0.3811  0.5924  0.5588  0.7568  0.9919 

C:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.01339 0.22591 0.36137 0.41832 0.58528 0.93471 
> 
> 
> 
> cleanEx()
> nameEx("summary.distfun")
> ### * summary.distfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.distfun
> ### Title: Summarizing a Function of Spatial Location
> ### Aliases: summary.distfun summary.funxy
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    f <- function(x,y) { x^2 + y^2 - 1} 
>    g <- funxy(f, square(2))
>    summary(g)
function(x,y) of class 'funxy'
defined in the rectangle [0, 2] x [0, 2] units

Original function definition:
function (x, y) 
{
    x^2 + y^2 - 1
}

Function values are real
	range = [-0.9998779, 6.937622]
	integral = 6.666504
	mean = 1.666626
> 
>    summary(distfun(cells))
Distance function for point pattern
defined in the rectangle [0, 1] x [0, 1] units

Distance function values:
	range = [0.0006200506, 0.2462214]
	mean = 0.06654729
>    summary(distfun(cells), dimyx=256)
Distance function for point pattern
defined in the rectangle [0, 1] x [0, 1] units

Distance function values:
	range = [0.0003468982, 0.2462214]
	mean = 0.06615811
> 
> 
> 
> cleanEx()
> nameEx("summary.dppm")
> ### * summary.dppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.dppm
> ### Title: Summarizing a Fitted Determinantal Point Process Model
> ### Aliases: summary.dppm print.summary.dppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>   jpines <- residualspaper$Fig1
>   ## Don't show: 
>      # smaller dataset for testing
>     jpines <- jpines[c(TRUE,FALSE)]
>   
> ## End(Don't show)
>  fit <- dppm(jpines ~ 1, dppGauss)
>  summary(fit)
Stationary determinantal point process model
Fitted to point pattern dataset 'jpines'
Fitted by minimum contrast
	Summary statistic: K-function
Minimum contrast fit (object of class "minconfit")
Model: Gaussian DPP
Fitted by matching theoretical K function to jpines

Internal parameters fitted by minimum contrast ($par):
    alpha 
0.1814277 


Converged successfully after NA function evaluations

Starting values of parameters:
    alpha 
0.4469047 
Domain of integration: [ 0 , 2.5 ]
Exponents: p= 2, q= 0.5

----------- TREND MODEL -----
Point process model
Fitting method: maximum likelihood (Berman-Turner approximation)
Model was fitted using glm()
Algorithm converged
Call:
ppm.ppp(Q = X, trend = trend, rename.intercept = FALSE, covariates = covariates, 
    covfunargs = covfunargs, use.gam = use.gam, forcefit = TRUE, 
    nd = nd, eps = eps)
Edge correction: "border"
	[border correction distance r = 0 ]
--------------------------------------------------------------------------------
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  102 points
Average intensity 1.02 points per square metre
Window: rectangle = [0, 10] x [0, 10] metres
Window area = 100 square metres
Unit of length: 1 metre

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.3125 metres

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 10.3 points per square metre
Window: rectangle = [0, 10] x [0, 10] metres
Window area = 100 square metres
Unit of length: 1 metre
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.0326, 0.0977]	total: 100
Weights on data points:
	range: [0.0326, 0.0488]	total: 4.92
Weights on dummy points:
	range: [0.0326, 0.0977]	total: 95.1
--------------------------------------------------------------------------------
FITTED MODEL:

Stationary Poisson process

---- Intensity: ----


Uniform intensity:
[1] 1.02

              Estimate       S.E.    CI95.lo  CI95.hi Ztest      Zval
(Intercept) 0.01980263 0.09901475 -0.1742627 0.213868       0.1999967

----------- gory details -----

Fitted regular parameters (theta):
(Intercept) 
 0.01980263 

Fitted exp(theta):
(Intercept) 
       1.02 

---------- DETERMINANTAL STRUCTURE -----------------
Gaussian determinantal point process model
The parameters are: lambda = 1.02, alpha = 0.1814, d = 2
The parameter lambda specifies the intensity of the process.
The parameter d specifies the dimension of the state space.

Strength of repulsion: 0.05221107
> 
> 
> 
> cleanEx()
> nameEx("summary.im")
> ### * summary.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.im
> ### Title: Summarizing a Pixel Image
> ### Aliases: summary.im print.summary.im
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   # make an image
>   X <- as.im(function(x,y) {x^2}, unit.square())
>   # summarize it
>   summary(X)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
dimensions of each pixel: 0.00781 x 0.0078125 units
Image is defined on the full rectangular grid
Frame area = 1 square units
Pixel values
	range = [1.525879e-05, 0.9922028]
	integral = 0.3333282
	mean = 0.3333282
>   # save the summary
>   s <- summary(X)
>   # print it
>   print(X)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
>   s
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
dimensions of each pixel: 0.00781 x 0.0078125 units
Image is defined on the full rectangular grid
Frame area = 1 square units
Pixel values
	range = [1.525879e-05, 0.9922028]
	integral = 0.3333282
	mean = 0.3333282
>   # extract stuff
>   X$dim
[1] 128 128
>   X$range
NULL
>   X$integral
NULL
> 
> 
> 
> cleanEx()
> nameEx("summary.kppm")
> ### * summary.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.kppm
> ### Title: Summarizing a Fitted Cox or Cluster Point Process Model
> ### Aliases: summary.kppm print.summary.kppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>  fit <- kppm(redwood ~ 1, "Thomas")
>  summary(fit)
Stationary cluster point process model
Fitted to point pattern dataset 'redwood'
Fitted by minimum contrast
	Summary statistic: K-function
Minimum contrast fit (object of class "minconfit")
Model: Thomas process
Fitted by matching theoretical K function to redwood

Internal parameters fitted by minimum contrast ($par):
       kappa       sigma2 
23.551144930  0.002213335 

Fitted cluster parameters:
     kappa      scale 
23.5511449  0.0470461 
Mean cluster size:  2.632568 points

Converged successfully after 95 function evaluations

Starting values of parameters:
       kappa       sigma2 
62.000000000  0.006173033 
Domain of integration: [ 0 , 0.25 ]
Exponents: p= 2, q= 0.25

----------- TREND MODEL -----
Point process model
Fitting method: maximum likelihood (Berman-Turner approximation)
Model was fitted using glm()
Algorithm converged
Call:
ppm.ppp(Q = X, trend = trend, rename.intercept = FALSE, covariates = covariates, 
    covfunargs = covfunargs, use.gam = use.gam, forcefit = TRUE, 
    nd = nd, eps = eps)
Edge correction: "border"
	[border correction distance r = 0 ]
--------------------------------------------------------------------------------
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  62 points
Average intensity 62 points per square unit
Window: rectangle = [0, 1] x [-1, 0] units
                    (1 x 1 units)
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [-1, 0] units
                    (1 x 1 units)
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000326, 0.000977]	total: 1
Weights on data points:
	range: [0.000326, 0.000488]	total: 0.0277
Weights on dummy points:
	range: [0.000326, 0.000977]	total: 0.972
--------------------------------------------------------------------------------
FITTED MODEL:

Stationary Poisson process

---- Intensity: ----


Uniform intensity:
[1] 62

            Estimate      S.E.  CI95.lo CI95.hi Ztest     Zval
(Intercept) 4.127134 0.1270001 3.878219 4.37605   *** 32.49709

----------- gory details -----

Fitted regular parameters (theta):
(Intercept) 
   4.127134 

Fitted exp(theta):
(Intercept) 
         62 

----------- CLUSTER MODEL -----------
Model: Thomas process

Fitted cluster parameters:
     kappa      scale 
23.5511449  0.0470461 
Mean cluster size:  2.632568 points

Final standard error and CI
(allowing for correlation of cluster process):
            Estimate      S.E.  CI95.lo  CI95.hi Ztest     Zval
(Intercept) 4.127134 0.2329259 3.670608 4.583661   *** 17.71866
>  coef(summary(fit))
            Estimate      S.E.  CI95.lo  CI95.hi Ztest     Zval
(Intercept) 4.127134 0.2329259 3.670608 4.583661   *** 17.71866
> 
> 
> 
> cleanEx()
> nameEx("summary.listof")
> ### * summary.listof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.listof
> ### Title: Summary of a List of Things
> ### Aliases: summary.listof
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   x <- list(A=runif(10), B=runif(10), C=runif(10))
>   class(x) <- c("listof", class(x))
>   summary(x)
A :
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.06179 0.29216 0.60098 0.55151 0.83899 0.94468 

B :
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1766  0.3811  0.5924  0.5588  0.7568  0.9919 

C :
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.01339 0.22591 0.36137 0.41832 0.58528 0.93471 

> 
> 
> 
> cleanEx()
> nameEx("summary.owin")
> ### * summary.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.owin
> ### Title: Summary of a Spatial Window
> ### Aliases: summary.owin
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   summary(owin())  # the unit square
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
> 
>   data(demopat)
>   W <- Window(demopat)  # weird polygonal window
>   summary(W)           # describes it
Window: polygonal boundary
2 separate polygons (1 hole)
                 vertices     area relative.area
polygon 1              32 52711900         1.110
polygon 2 (hole)       12 -5127190        -0.108
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
                     (10050 x 6675 furlongs)
Window area = 47584700 square furlongs
Unit of length: 1 furlong
Fraction of frame area: 0.709
> 
>   summary(as.mask(W))  # demonstrates current pixel resolution
binary image mask
128 x 128 pixel array (ny, nx)
pixel size: 78.5 by 52.1 furlongs
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
                     (10050 x 6675 furlongs)
Window area = 47598200 square furlongs
Unit of length: 1 furlong
Fraction of frame area: 0.71
> 
> 
> 
> cleanEx()
> nameEx("summary.ppm")
> ### * summary.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.ppm
> ### Title: Summarizing a Fitted Point Process Model
> ### Aliases: summary.ppm print.summary.ppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>   # invent some data
>   X <- rpoispp(42)
>   # fit a model to it
>   fit <- ppm(X ~ x, Strauss(r=0.1))
>   # summarize the fitted model
>   summary(fit)
Point process model
Fitting method: maximum pseudolikelihood (Berman-Turner approximation)
Model was fitted using glm()
Algorithm converged
Call:
ppm.formula(Q = X ~ x, interaction = Strauss(r = 0.1))
Edge correction: "border"
	[border correction distance r = 0.1 ]
--------------------------------------------------------------------------------
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  37 points
Average intensity 37 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000488, 0.000977]	total: 1
Weights on data points:
	range: [0.000488, 0.000488]	total: 0.0181
Weights on dummy points:
	range: [0.000488, 0.000977]	total: 0.982
--------------------------------------------------------------------------------
FITTED MODEL:

Nonstationary Strauss process

---- Trend: ----

Log trend: ~x

Fitted trend coefficients:
(Intercept)           x 
  3.7923879   0.2932107 

              Estimate      S.E.    CI95.lo   CI95.hi Ztest       Zval
(Intercept)  3.7923879 0.7075579  2.4056000 5.1791759   ***  5.3598271
x            0.2932107 0.8779864 -1.4276111 2.0140325        0.3339581
Interaction -0.1576339 0.3714055 -0.8855753 0.5703074       -0.4244255

 ---- Interaction: -----

Interaction: Strauss process
Interaction distance:	0.1
Fitted interaction parameter gamma:	 0.8541624

Relevant coefficients:
Interaction 
 -0.1576339 

----------- gory details -----

Fitted regular parameters (theta):
(Intercept)           x Interaction 
  3.7923879   0.2932107  -0.1576339 

Fitted exp(theta):
(Intercept)           x Interaction 
 44.3622078   1.3407252   0.8541624 
>   # `quick' option
>   summary(fit, quick=TRUE)
Nonstationary Strauss process
>   # coefficients with standard errors and CI
>   coef(summary(fit))
              Estimate      S.E.    CI95.lo   CI95.hi Ztest       Zval
(Intercept)  3.7923879 0.7075579  2.4056000 5.1791759   ***  5.3598271
x            0.2932107 0.8779864 -1.4276111 2.0140325        0.3339581
Interaction -0.1576339 0.3714055 -0.8855753 0.5703074       -0.4244255
>   coef(summary(fit, fine=TRUE))
              Estimate      S.E.    CI95.lo   CI95.hi Ztest       Zval
(Intercept)  3.7923879 0.5976042  2.6211053 4.9636705   ***  6.3459866
x            0.2932107 0.8953326 -1.4616089 2.0480302        0.3274880
Interaction -0.1576339 0.2743880 -0.6954246 0.3801567       -0.5744928
> 
>   # save the full summary
>   s <- summary(fit)
>   # print it
>   print(s)
Point process model
Fitting method: maximum pseudolikelihood (Berman-Turner approximation)
Model was fitted using glm()
Algorithm converged
Call:
ppm.formula(Q = X ~ x, interaction = Strauss(r = 0.1))
Edge correction: "border"
	[border correction distance r = 0.1 ]
--------------------------------------------------------------------------------
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  37 points
Average intensity 37 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000488, 0.000977]	total: 1
Weights on data points:
	range: [0.000488, 0.000488]	total: 0.0181
Weights on dummy points:
	range: [0.000488, 0.000977]	total: 0.982
--------------------------------------------------------------------------------
FITTED MODEL:

Nonstationary Strauss process

---- Trend: ----

Log trend: ~x

Fitted trend coefficients:
(Intercept)           x 
  3.7923879   0.2932107 

              Estimate      S.E.    CI95.lo   CI95.hi Ztest       Zval
(Intercept)  3.7923879 0.7075579  2.4056000 5.1791759   ***  5.3598271
x            0.2932107 0.8779864 -1.4276111 2.0140325        0.3339581
Interaction -0.1576339 0.3714055 -0.8855753 0.5703074       -0.4244255

 ---- Interaction: -----

Interaction: Strauss process
Interaction distance:	0.1
Fitted interaction parameter gamma:	 0.8541624

Relevant coefficients:
Interaction 
 -0.1576339 

----------- gory details -----

Fitted regular parameters (theta):
(Intercept)           x Interaction 
  3.7923879   0.2932107  -0.1576339 

Fitted exp(theta):
(Intercept)           x Interaction 
 44.3622078   1.3407252   0.8541624 
>   s
Point process model
Fitting method: maximum pseudolikelihood (Berman-Turner approximation)
Model was fitted using glm()
Algorithm converged
Call:
ppm.formula(Q = X ~ x, interaction = Strauss(r = 0.1))
Edge correction: "border"
	[border correction distance r = 0.1 ]
--------------------------------------------------------------------------------
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  37 points
Average intensity 37 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000488, 0.000977]	total: 1
Weights on data points:
	range: [0.000488, 0.000488]	total: 0.0181
Weights on dummy points:
	range: [0.000488, 0.000977]	total: 0.982
--------------------------------------------------------------------------------
FITTED MODEL:

Nonstationary Strauss process

---- Trend: ----

Log trend: ~x

Fitted trend coefficients:
(Intercept)           x 
  3.7923879   0.2932107 

              Estimate      S.E.    CI95.lo   CI95.hi Ztest       Zval
(Intercept)  3.7923879 0.7075579  2.4056000 5.1791759   ***  5.3598271
x            0.2932107 0.8779864 -1.4276111 2.0140325        0.3339581
Interaction -0.1576339 0.3714055 -0.8855753 0.5703074       -0.4244255

 ---- Interaction: -----

Interaction: Strauss process
Interaction distance:	0.1
Fitted interaction parameter gamma:	 0.8541624

Relevant coefficients:
Interaction 
 -0.1576339 

----------- gory details -----

Fitted regular parameters (theta):
(Intercept)           x Interaction 
  3.7923879   0.2932107  -0.1576339 

Fitted exp(theta):
(Intercept)           x Interaction 
 44.3622078   1.3407252   0.8541624 
>   # extract stuff
>   names(s)
 [1] "antiquated"    "old"           "version"       "entries"      
 [5] "no.trend"      "trendvar"      "stationary"    "poisson"      
 [9] "marked"        "multitype"     "marktype"      "name"         
[13] "method"        "problems"      "fitter"        "converged"    
[17] "projected"     "changedcoef"   "valid"         "interaction"  
[21] "has.covars"    "covnames"      "covars.used"   "uses.covars"  
[25] "covars.are.df" "expandable"    "covar.type"    "covar.descrip"
[29] "has.funcs"     "covfunargs"    "has.xargs"     "xargmap"      
[33] "args"          "data"          "quad"          "trend"        
[37] "coefs.SE.CI"  
>   coef(s)
              Estimate      S.E.    CI95.lo   CI95.hi Ztest       Zval
(Intercept)  3.7923879 0.7075579  2.4056000 5.1791759   ***  5.3598271
x            0.2932107 0.8779864 -1.4276111 2.0140325        0.3339581
Interaction -0.1576339 0.3714055 -0.8855753 0.5703074       -0.4244255
>   s$args$correction
[1] "border"
>   s$name
[1] "Nonstationary Strauss process"
>   s$trend$value
(Intercept)           x 
  3.7923879   0.2932107 
> 
>   ## Not run: 
> ##D   # multitype pattern
> ##D   data(demopat)
> ##D   fit <- ppm(demopat, ~marks, Poisson())
> ##D   summary(fit)
> ##D   
> ## End(Not run)
> 
>   # model with external covariates
>   fitX <- ppm(X, ~Z, covariates=list(Z=function(x,y){x+y}))
>   summary(fitX)
Point process model
Fitting method: maximum likelihood (Berman-Turner approximation)
Model was fitted using glm()
Algorithm converged
Call:
ppm.ppp(Q = X, trend = ~Z, covariates = list(Z = function(x, 
    y) {
    x + y
}))
Edge correction: "border"
	[border correction distance r = 0 ]
--------------------------------------------------------------------------------
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  37 points
Average intensity 37 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000488, 0.000977]	total: 1
Weights on data points:
	range: [0.000488, 0.000488]	total: 0.0181
Weights on dummy points:
	range: [0.000488, 0.000977]	total: 0.982
--------------------------------------------------------------------------------
FITTED MODEL:

Nonstationary Poisson process

---- Intensity: ----

Log intensity: ~Z
Model depends on external covariate 'Z'
Covariates provided:
	Z: function(x, y)

Fitted trend coefficients:
(Intercept)           Z 
  3.3251716   0.2792614 

             Estimate      S.E.   CI95.lo  CI95.hi Ztest      Zval
(Intercept) 3.3251716 0.4532478  2.436822 4.213521   *** 7.3363211
Z           0.2792614 0.4036413 -0.511861 1.070384       0.6918554

----------- gory details -----

Fitted regular parameters (theta):
(Intercept)           Z 
  3.3251716   0.2792614 

Fitted exp(theta):
(Intercept)           Z 
  27.803769    1.322153 
> 
> 
> 
> cleanEx()
> nameEx("summary.ppp")
> ### * summary.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.ppp
> ### Title: Summary of a Point Pattern Dataset
> ### Aliases: summary.ppp
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   summary(cells)  # plain vanilla point pattern
Planar point pattern:  42 points
Average intensity 42 points per square unit

Coordinates are given to 3 decimal places
i.e. rounded to the nearest multiple of 0.001 units

Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
> 
>   # multitype point pattern
>   woods <- lansing
>   ## Don't show: 
> woods <- woods[seq(1, npoints(woods), length=40)]
> ## End(Don't show)
>   summary(woods) # tabulates frequencies of each mark
Marked planar point pattern:  40 points
Average intensity 40 points per square unit (one unit = 924 feet)

Coordinates are given to 3 decimal places
i.e. rounded to the nearest multiple of 0.001 units (one unit = 924 feet)

Multitype:
         frequency proportion intensity
blackoak         3      0.075         3
hickory         12      0.300        12
maple            9      0.225         9
misc             2      0.050         2
redoak           6      0.150         6
whiteoak         8      0.200         8

Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Unit of length: 924 feet
>   
>   # numeric marks
>   trees <- longleaf
>   ## Don't show: 
> trees <- trees[seq(1, npoints(trees), length=40)]
> ## End(Don't show)
>   summary(trees) # prints summary.default(marks(trees))
Marked planar point pattern:  40 points
Average intensity 0.001 points per square metre

Coordinates are given to 1 decimal place
i.e. rounded to the nearest multiple of 0.1 metres

marks are numeric, of type 'double'
Summary:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    7.85   15.35   20.69   32.23   56.30 

Window: rectangle = [0, 200] x [0, 200] metres
Window area = 40000 square metres
Unit of length: 1 metre
> 
>   # weird polygonal window
>   summary(demopat)  # describes it
Marked planar point pattern:  112 points
Average intensity 2.353698e-06 points per square furlong

Coordinates are integers
i.e. rounded to the nearest furlong

Multitype:
  frequency proportion    intensity
A        45  0.4017857 9.456824e-07
B        67  0.5982143 1.408016e-06

Window: polygonal boundary
2 separate polygons (1 hole)
                 vertices     area relative.area
polygon 1              32 52711900         1.110
polygon 2 (hole)       12 -5127190        -0.108
enclosing rectangle: [525, 10575] x [450, 7125] furlongs
                     (10050 x 6675 furlongs)
Window area = 47584700 square furlongs
Unit of length: 1 furlong
Fraction of frame area: 0.709
> 
> 
> 
> cleanEx()
> nameEx("summary.psp")
> ### * summary.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.psp
> ### Title: Summary of a Line Segment Pattern Dataset
> ### Aliases: summary.psp
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   a <- psp(runif(10), runif(10), runif(10), runif(10), window=owin())
>   summary(a)  # describes it
10 line segments
Lengths:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.08721 0.42770 0.50004 0.55604 0.78644 0.93443 
Total length: 5.56036669491692 units  
Length per unit area: 5.56036669491692 
Angles (radians):
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.2477  0.7803  1.5990  1.5576  2.1553  3.0595 
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
> 
> 
> 
> cleanEx()
> nameEx("summary.quad")
> ### * summary.quad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.quad
> ### Title: Summarizing a Quadrature Scheme
> ### Aliases: summary.quad print.summary.quad
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   # make a quadrature scheme
>   Q <- quadscheme(rpoispp(42))
>   # summarize it
>   summary(Q)
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  37 points
Average intensity 37 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000488, 0.000977]	total: 1
Weights on data points:
	range: [0.000488, 0.000488]	total: 0.0181
Weights on dummy points:
	range: [0.000488, 0.000977]	total: 0.982
>   # save the summary
>   s <- summary(Q)
>   # print it
>   print(s)
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  37 points
Average intensity 37 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000488, 0.000977]	total: 1
Weights on data points:
	range: [0.000488, 0.000488]	total: 0.0181
Weights on dummy points:
	range: [0.000488, 0.000977]	total: 0.982
>   s
Quadrature scheme (Berman-Turner) = data + dummy + weights

Data pattern:
Planar point pattern:  37 points
Average intensity 37 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Dummy quadrature points:
     32 x 32 grid of dummy points, plus 4 corner points
     dummy spacing: 0.03125 units

Original dummy parameters: =
Planar point pattern:  1028 points
Average intensity 1030 points per square unit
Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Quadrature weights:
     (counting weights based on 32 x 32 array of rectangular tiles)
All weights:
	range: [0.000488, 0.000977]	total: 1
Weights on data points:
	range: [0.000488, 0.000488]	total: 0.0181
Weights on dummy points:
	range: [0.000488, 0.000977]	total: 0.982
>   # extract total quadrature weight
>   s$w$all$sum
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("summary.solist")
> ### * summary.solist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.solist
> ### Title: Summary of a List of Spatial Objects
> ### Aliases: summary.solist
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   x <- solist(cells, japanesepines, redwood)
>   summary(x)
Summary of 3 point patterns

Component 1:
Planar point pattern:  42 points
Average intensity 42 points per square unit

Coordinates are given to 3 decimal places
i.e. rounded to the nearest multiple of 0.001 units

Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit

Component 2:
Planar point pattern:  65 points
Average intensity 65 points per square unit (one unit = 5.7 metres)

Coordinates are given to 2 decimal places
i.e. rounded to the nearest multiple of 0.01 units (one unit = 5.7 metres)

Window: rectangle = [0, 1] x [0, 1] units
Window area = 1 square unit
Unit of length: 5.7 metres

Component 3:
Planar point pattern:  62 points
Average intensity 62 points per square unit

Coordinates are given to 3 decimal places
i.e. rounded to the nearest multiple of 0.001 units

Window: rectangle = [0, 1] x [-1, 0] units
                    (1 x 1 units)
Window area = 1 square unit
> 
> 
> 
> cleanEx()
> nameEx("summary.splitppp")
> ### * summary.splitppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.splitppp
> ### Title: Summary of a Split Point Pattern
> ### Aliases: summary.splitppp
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   data(amacrine)      # multitype point pattern
>   summary(split(amacrine))
off:
Planar point pattern:  142 points
Average intensity 88.68302 points per square unit (one unit = 662 microns)

Coordinates are given to 4 decimal places

Window: rectangle = [0, 1.6012085] x [0, 1] units
Window area = 1.60121 square units
Unit of length: 662 microns

on:
Planar point pattern:  152 points
Average intensity 94.9283 points per square unit (one unit = 662 microns)

Coordinates are given to 4 decimal places

Window: rectangle = [0, 1.6012085] x [0, 1] units
Window area = 1.60121 square units
Unit of length: 662 microns
> 
> 
> 
> cleanEx()
> nameEx("sumouter")
> ### * sumouter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sumouter
> ### Title: Compute Quadratic Forms
> ### Aliases: sumouter quadform bilinearform
> ### Keywords: array
> 
> ### ** Examples
> 
>   x <- matrix(1:12, 4, 3)
>   dimnames(x) <- list(c("Wilma", "Fred", "Barney", "Betty"), letters[1:3])
>   x
       a b  c
Wilma  1 5  9
Fred   2 6 10
Barney 3 7 11
Betty  4 8 12
> 
>   sumouter(x)
    a   b   c
a  30  70 110
b  70 174 278
c 110 278 446
> 
>   w <- 4:1
>   sumouter(x, w)
    a   b    c
a  50 130  210
b 130 370  610
c 210 610 1010
>   v <- matrix(1, 3, 3)
>   quadform(x, v)
 Wilma   Fred Barney  Betty 
   225    324    441    576 
> 
>   # should be the same as quadform(x, v)
>   bilinearform(x, v, x)
 Wilma   Fred Barney  Betty 
   225    324    441    576 
> 
>   # See what happens with NA's
>   x[3,2] <- NA
>   sumouter(x, w)
    a   b   c
a  32  88 144
b  88 272 456
c 144 456 768
>   quadform(x, v)
 Wilma   Fred Barney  Betty 
   225    324     NA    576 
> 
> 
> 
> cleanEx()
> nameEx("superimpose")
> ### * superimpose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: superimpose
> ### Title: Superimpose Several Geometric Patterns
> ### Aliases: superimpose superimpose.ppp superimpose.splitppp
> ###   superimpose.ppplist superimpose.psp superimpose.default
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # superimposing point patterns
>   p1  <- runifrect(30)
>   p2  <- runifrect(42)
>   s1  <- superimpose(p1,p2) # Unmarked pattern.
>   p3  <- list(x=rnorm(20),y=rnorm(20))
>   s2  <- superimpose(p3,p2,p1) # Default method gets called.
Warning: 18 points were rejected as lying outside the specified window
>   s2a <- superimpose(p1,p2,p3) # Same as s2 except for order of points.
Warning: 18 points were rejected as lying outside the specified window
>   s3  <- superimpose(clyde=p1,irving=p2) # Marked pattern; marks a factor
>                                          # with levels "clyde" and "irving";
>                                          # warning given.
>   marks(p1) <- factor(sample(LETTERS[1:3],30,TRUE))
>   marks(p2) <- factor(sample(LETTERS[1:3],42,TRUE))
>   s5  <- superimpose(clyde=p1,irving=p2) # Marked pattern with extra column
>   marks(p2) <- data.frame(a=marks(p2),b=runif(42))
>   s6  <- try(superimpose(p1,p2)) # Gives an error.
Error : Cannot append marks of different formats: 'vector' and 'dataframe'
>   marks(p1) <- data.frame(a=marks(p1),b=1:30)
>   s7  <- superimpose(p1,p2) # O.K.
> 
>   # how to make a 2-type point pattern with types "a" and "b"
>   u <- superimpose(a = rpoispp(10), b = rpoispp(20))
> 
>   # how to make a 2-type point pattern with types 1 and 2
>   u <- superimpose("1" = rpoispp(10), "2" = rpoispp(20))
>  
>   # superimposing line segment patterns
>   X <- rpoisline(10)
>   Y <- as.psp(matrix(runif(40), 10, 4), window=owin())
>   Z <- superimpose(X, Y)
> 
>   # being unreasonable
>   ## Not run: 
> ##D    if(FALSE) {
> ##D     crud <- try(superimpose(p1,p2,X,Y)) # Gives an error, of course!
> ##D    }
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("superimpose.lpp")
> ### * superimpose.lpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: superimpose.lpp
> ### Title: Superimpose Several Point Patterns on Linear Network
> ### Aliases: superimpose.lpp
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- rpoislpp(5, simplenet)
>   Y <- rpoislpp(10, simplenet)
>   superimpose(X,Y) # not marked
Point pattern on linear network
41 points
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
>   superimpose(A=X, B=Y) # multitype with types A and B
Point pattern on linear network
41 points
Multitype, with possible types: A, B 
Linear network with 10 vertices and 10 lines
Enclosing window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("symbolmap")
> ### * symbolmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: symbolmap
> ### Title: Graphics Symbol Map
> ### Aliases: symbolmap
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   g <- symbolmap(inputs=letters[1:10], pch=11:20)
> 
>   g1 <- symbolmap(range=c(0,100), size=function(x) x/50)
> 
>   g2 <- symbolmap(shape=function(x) ifelse(x > 0, "circles", "squares"),
+                     size=function(x) sqrt(ifelse(x > 0, x/pi, -x)),
+                     bg = function(x) ifelse(abs(x) < 1, "red", "black"))
> 
>   colmap <- colourmap(topo.colors(20), range=c(0,10))
>   g3 <- symbolmap(pch=21, bg=colmap, range=c(0,10))
>   plot(g3)
> 
> 
> 
> cleanEx()
> nameEx("tess")
> ### * tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tess
> ### Title: Create a Tessellation
> ### Aliases: tess
> ### Keywords: spatial datagen
> 
> ### ** Examples
> 
>   A <- tess(xgrid=0:4,ygrid=0:4)
>   A
Tessellation
Tiles are equal rectangles, of dimension 1 x 1 units 
4 by 4 grid of tiles
window: rectangle = [0, 4] x [0, 4] units
>   plot(A)
>   B <- A[c(1, 2, 5, 7, 9)]
>   B
Tessellation
Tiles are irregular polygons
5 tiles (irregular windows)
window: polygonal boundary
enclosing rectangle: [0, 3] x [1, 4] units
>   v <- as.im(function(x,y){factor(round(5 * (x^2 + y^2)))}, W=owin())
>   levels(v) <- letters[seq(length(levels(v)))]
>   E <- tess(image=v)
>   plot(E)
>   G <- tess(image=v, marks=toupper(levels(v)), unitname="km")
>   G
Tessellation
Tessellation is determined by a factor-valued image with 11 levels
Tessellation is marked
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] km
> 
> 
> 
> cleanEx()
> nameEx("test.crossing.psp")
> ### * test.crossing.psp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: test.crossing.psp
> ### Title: Check Whether Segments Cross
> ### Aliases: test.crossing.psp test.selfcrossing.psp
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   B <- edges(letterR)
>   A <- rpoisline(5, Frame(B))
>   MA <- test.selfcrossing.psp(A)
>   MAB <- test.crossing.psp(A, B)
> 
> 
> 
> cleanEx()
> nameEx("text.ppp")
> ### * text.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: text.ppp
> ### Title: Add Text Labels to Spatial Pattern
> ### Aliases: text.ppp text.lpp text.psp
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   plot(cells)
>   text(cells, pos=2)
> 
>   plot(Frame(cells))
>   text(cells, cex=1.5)
> 
>   S <- as.psp(simplenet)
>   plot(S)
>   text(S)
> 
>   X <- runiflpp(5, simplenet)
>   plot(X)
>   text(X, pos=2, col="blue")
> 
> 
> 
> cleanEx()
> nameEx("texturemap")
> ### * texturemap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: texturemap
> ### Title: Texture Map
> ### Aliases: texturemap
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>    texturemap(letters[1:4], 2:5, col=1:4, lwd=2)
Texture map
  input texture col lwd
1     a       2   1   2
2     b       3   2   2
3     c       4   3   2
4     d       5   4   2
> 
> 
> 
> cleanEx()
> nameEx("textureplot")
> ### * textureplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: textureplot
> ### Title: Plot Image or Tessellation Using Texture Fill
> ### Aliases: textureplot
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   nd <- if(interactive()) 128 else 32
>   Z <- setcov(owin(), dimyx=nd)
>   Zcut <- cut(Z, 3, labels=c("Lo", "Med", "Hi"))
>   textureplot(Zcut)
>   textureplot(dirichlet(runifpoint(6)))
> 
> 
> 
> cleanEx()
> nameEx("thinNetwork")
> ### * thinNetwork
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: thinNetwork
> ### Title: Remove Vertices or Segments from a Linear Network
> ### Aliases: thinNetwork
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    L <- simplenet
>    plot(L, main="thinNetwork(L, retainedges=c(-3, -5))")
>    text(midpoints.psp(as.psp(L)), labels=1:nsegments(L), pos=3)
>    Lsub <- thinNetwork(L, retainedges=c(-3, -5))
>    plot(Lsub, add=TRUE, col="blue", lwd=2)
> 
> 
> 
> cleanEx()
> nameEx("thomas.estK")
> ### * thomas.estK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: thomas.estK
> ### Title: Fit the Thomas Point Process by Minimum Contrast
> ### Aliases: thomas.estK
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(redwood)
>     u <- thomas.estK(redwood, c(kappa=10, scale=0.1))
>     u
Minimum contrast fit (object of class "minconfit")
Model: Thomas process
Fitted by matching theoretical K function to Kest(redwood)

Internal parameters fitted by minimum contrast ($par):
       kappa       sigma2 
23.547576422  0.002213629 

Fitted cluster parameters:
      kappa       scale 
23.54757642  0.04704921 

Converged successfully after 81 function evaluations

Starting values of parameters:
 kappa sigma2 
 10.00   0.01 
Domain of integration: [ 0 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u)
> 
> 
> 
> cleanEx()
> nameEx("thomas.estpcf")
> ### * thomas.estpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: thomas.estpcf
> ### Title: Fit the Thomas Point Process by Minimum Contrast
> ### Aliases: thomas.estpcf
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     data(redwood)
>     u <- thomas.estpcf(redwood, c(kappa=10, scale=0.1))
>     u
Minimum contrast fit (object of class "minconfit")
Model: Thomas process
Fitted by matching theoretical g function to pcf(redwood)

Internal parameters fitted by minimum contrast ($par):
       kappa       sigma2 
25.296707221  0.001574671 

Fitted cluster parameters:
      kappa       scale 
25.29670722  0.03968213 

Converged successfully after 129 function evaluations

Starting values of parameters:
 kappa sigma2 
 10.00   0.01 
Domain of integration: [ 0.0004883 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u, legendpos="topright")
>     u2 <- thomas.estpcf(redwood, c(kappa=10, scale=0.1),
+           pcfargs=list(stoyan=0.12))
> 
> 
> 
> cleanEx()
> nameEx("tile.areas")
> ### * tile.areas
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tile.areas
> ### Title: Compute Areas of Tiles in a Tessellation
> ### Aliases: tile.areas
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   A <- tess(xgrid=0:2,ygrid=0:2)
>   tile.areas(A)
Tile row 1, col 1 Tile row 1, col 2 Tile row 2, col 1 Tile row 2, col 2 
                1                 1                 1                 1 
>   v <- as.im(function(x,y){factor(round(x^2 + y^2))}, W=owin())
>   E <- tess(image=v)
>   tile.areas(E)

        0         1         2 
0.3919678 0.5700073 0.0380249 
> 
> 
> 
> cleanEx()
> nameEx("tile.lengths")
> ### * tile.lengths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tile.lengths
> ### Title: Compute Lengths of Tiles in a Tessellation on a Network
> ### Aliases: tile.lengths
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runiflpp(5, simplenet)
>   A <- lineardirichlet(X)
>   plot(A)
>   tile.lengths(A)
[1] 1.1086338 0.5184770 0.2693489 0.7304854 0.2779065
> 
> 
> 
> cleanEx()
> nameEx("tileindex")
> ### * tileindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tileindex
> ### Title: Determine Which Tile Contains Each Given Point
> ### Aliases: tileindex
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runifpoint(7)
>   V <- dirichlet(X)
>   tileindex(0.1, 0.4, V)
[1] 5
Levels: 1 2 3 4 5 6 7
>   tileindex(list(x=0.1, y=0.4), Z=V)
[1] 5
Levels: 1 2 3 4 5 6 7
>   tileindex(X, Z=V)
[1] 1 2 3 4 5 6 7
Levels: 1 2 3 4 5 6 7
> 
> 
> 
> cleanEx()
> nameEx("tilenames")
> ### * tilenames
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tilenames
> ### Title: Names of Tiles in a Tessellation
> ### Aliases: tilenames tilenames<- tilenames.tess tilenames<-.tess
> ###   tilenames.lintess tilenames<-.lintess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   D <- dirichlet(runifpoint(10))
>   tilenames(D)
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
>   tilenames(D) <- paste("Cell", 1:10)
>   tilenames(D)
 [1] "Cell 1"  "Cell 2"  "Cell 3"  "Cell 4"  "Cell 5"  "Cell 6"  "Cell 7" 
 [8] "Cell 8"  "Cell 9"  "Cell 10"
> 
>   B <- lineardirichlet(runiflpp(5, simplenet))
>   tilenames(B)
[1] "1" "2" "3" "4" "5"
>   tilenames(B) <- letters[1:5]
> 
> 
> 
> cleanEx()
> nameEx("tiles")
> ### * tiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tiles
> ### Title: Extract List of Tiles in a Tessellation
> ### Aliases: tiles
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   A <- tess(xgrid=0:2,ygrid=0:2)
>   tiles(A)
List of spatial objects

Tile row 1, col 1:
window: rectangle = [0, 1] x [1, 2] units

Tile row 1, col 2:
window: rectangle = [1, 2] x [1, 2] units

Tile row 2, col 1:
window: rectangle = [0, 1] x [0, 1] units

Tile row 2, col 2:
window: rectangle = [1, 2] x [0, 1] units
>   v <- as.im(function(x,y){factor(round(x^2 + y^2))}, W=owin())
>   E <- tess(image=v)
>   tiles(E)
List of spatial objects

0:
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units

1:
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units

2:
window: binary image mask
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("tiles.empty")
> ### * tiles.empty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tiles.empty
> ### Title: Check For Empty Tiles in a Tessellation
> ### Aliases: tiles.empty
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   A <- tess(xgrid=0:2,ygrid=0:2)
>   tiles.empty(A)
[1] FALSE FALSE FALSE FALSE
>   v <- as.im(function(x,y){factor(round(x^2 + y^2))}, W=owin())
>   E <- tess(image=v)
>   tiles.empty(E)

    0     1     2 
FALSE FALSE FALSE 
> 
> 
> 
> cleanEx()
> nameEx("timeTaken")
> ### * timeTaken
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: timeTaken
> ### Title: Extract the Total Computation Time
> ### Aliases: timeTaken
> ### Keywords: utilities
> 
> ### ** Examples
> 
>   A <- timed(Kest(cells))
>   B <- timed(Gest(cells))
>   A
Function value object (class 'fv')
for the function r -> K(r)
..............................................................
       Math.label       Description                           
r      r                distance argument r                   
theo   K[pois](r)       theoretical Poisson K(r)              
border hat(K)[bord](r)  border-corrected estimate of K(r)     
trans  hat(K)[trans](r) translation-corrected estimate of K(r)
iso    hat(K)[iso](r)   isotropic-corrected estimate of K(r)  
..............................................................
Default plot formula:  .~r
where "." stands for 'iso', 'trans', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]

Time taken: 0.01 sec 
>   B
Function value object (class 'fv')
for the function r -> G(r)
.....................................................................
        Math.label      Description                                  
r       r               distance argument r                          
theo    G[pois](r)      theoretical Poisson G(r)                     
han     hat(G)[han](r)  Hanisch estimate of G(r)                     
rs      hat(G)[bord](r) border corrected estimate of G(r)            
km      hat(G)[km](r)   Kaplan-Meier estimate of G(r)                
hazard  hat(h)[km](r)   Kaplan-Meier estimate of hazard function h(r)
theohaz h[pois](r)      theoretical Poisson hazard function h(r)     
.....................................................................
Default plot formula:  .~r
where "." stands for 'km', 'rs', 'han', 'theo'
Recommended range of argument r: [0, 0.15]
Available range of argument r: [0, 0.29539]

Time taken: 0.02 sec 
>   timeTaken(A,B)
   user  system elapsed 
   0.03    0.00    0.03 
> 
> 
> 
> cleanEx()
> nameEx("timed")
> ### * timed
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: timed
> ### Title: Record the Computation Time
> ### Aliases: timed
> ### Keywords: utilities
> 
> ### ** Examples
> 
>   timed(clarkevans(cells))
   naive Donnelly      cdf 
1.671680 1.560426 1.624456 

Time taken: 0.01 sec 
> 
>   timed(Kest(cells))
Function value object (class 'fv')
for the function r -> K(r)
..............................................................
       Math.label       Description                           
r      r                distance argument r                   
theo   K[pois](r)       theoretical Poisson K(r)              
border hat(K)[bord](r)  border-corrected estimate of K(r)     
trans  hat(K)[trans](r) translation-corrected estimate of K(r)
iso    hat(K)[iso](r)   isotropic-corrected estimate of K(r)  
..............................................................
Default plot formula:  .~r
where "." stands for 'iso', 'trans', 'border', 'theo'
Recommended range of argument r: [0, 0.25]
Available range of argument r: [0, 0.25]

Time taken: 0.02 sec 
> 
>   answer <- timed(42, timetaken=4.1e17)
>   answer
[1] 42

Time taken: 13 billion years 
> 
> 
> 
> cleanEx()
> nameEx("transect.im")
> ### * transect.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transect.im
> ### Title: Pixel Values Along a Transect
> ### Aliases: transect.im
> ### Keywords: spatial manip iplot
> 
> ### ** Examples
> 
>   Z <- density(redwood)
>   plot(transect.im(Z))
>   ## Not run: 
> ##D    if(FALSE) {
> ##D     plot(transect.im(Z, click=TRUE))
> ##D    }
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("transmat")
> ### * transmat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transmat
> ### Title: Convert Pixel Array Between Different Conventions
> ### Aliases: transmat
> ### Keywords: spatial hplot manip
> 
> ### ** Examples
> 
>   opa <- par(mfrow=c(1,2))
>   # image in spatstat format
>   Z <- bei.extra$elev
>   plot(Z, main="plot.im", ribbon=FALSE)
>   m <- as.matrix(Z)
>   # convert matrix to format suitable for display by image.default
>   Y <- transmat(m, from="spatstat", to="Cartesian")
>   image(Y, asp=0.5, main="image.default", axes=FALSE)
>   par(opa)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("treebranchlabels")
> ### * treebranchlabels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: treebranchlabels
> ### Title: Label Vertices of a Tree by Branch Membership
> ### Aliases: treebranchlabels
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   # make a simple tree
>   m <- simplenet$m
>   m[8,10] <- m[10,8] <- FALSE
>   L <- linnet(vertices(simplenet), m)
>   plot(L, main="")
>   # compute branch labels 
>   tb <- treebranchlabels(L, 1)
>   tbc <- paste0("[", tb, "]")
>   text(vertices(L), labels=tbc, cex=2)
> 
> 
> 
> cleanEx()
> nameEx("treeprune")
> ### * treeprune
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: treeprune
> ### Title: Prune Tree to Given Level
> ### Aliases: treeprune
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   # make a simple tree
>   m <- simplenet$m
>   m[8,10] <- m[10,8] <- FALSE
>   L <- linnet(vertices(simplenet), m)
>   plot(L, main="")
>   # compute branch labels 
>   tb <- treebranchlabels(L, 1)
>   tbc <- paste0("[", tb, "]")
>   text(vertices(L), labels=tbc, cex=2)
>   # prune tree 
>   tp <- treeprune(L, root=1, 1)
>   plot(tp, add=TRUE, col="blue", lwd=3)
> 
> 
> 
> cleanEx()
> nameEx("triangulate.owin")
> ### * triangulate.owin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: triangulate.owin
> ### Title: Decompose Window into Triangles
> ### Aliases: triangulate.owin
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   plot(triangulate.owin(letterR))
> 
> 
> 
> cleanEx()
> nameEx("trim.rectangle")
> ### * trim.rectangle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trim.rectangle
> ### Title: Cut margins from rectangle
> ### Aliases: trim.rectangle
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   w <- square(10)
>   # trim a margin of width 1 from all four sides
>   square9 <- trim.rectangle(w, 1)
> 
>   # trim margin of width 3 from the right side
>   # and margin of height 4 from top edge.
>   v <- trim.rectangle(w, c(0,3), c(0,4))
> 
> 
> 
> cleanEx()
> nameEx("tweak.colourmap")
> ### * tweak.colourmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tweak.colourmap
> ### Title: Change Colour Values in a Colour Map
> ### Aliases: tweak.colourmap
> ### Keywords: spatial color
> 
> ### ** Examples
> 
>   co <- colourmap(rainbow(32), range=c(0,1))
>   plot(tweak.colourmap(co, inputs=c(0.5, 0.6), "white"))
>   plot(tweak.colourmap(co, range=c(0.5,0.6), "white"))
> 
> 
> 
> cleanEx()
> nameEx("union.quad")
> ### * union.quad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: union.quad
> ### Title: Union of Data and Dummy Points
> ### Aliases: union.quad
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(simdat)
>   Q <- quadscheme(simdat, default.dummy(simdat))
>   U <- union.quad(Q)
>   ## Not run: plot(U)
>   # equivalent:
>   U <- as.ppp(Q)
> 
> 
> 
> cleanEx()
> nameEx("unique.ppp")
> ### * unique.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unique.ppp
> ### Title: Extract Unique Points from a Spatial Point Pattern
> ### Aliases: unique.ppp unique.ppx
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>    X <- ppp(c(1,1,0.5), c(2,2,1), window=square(3))
Warning: data contain duplicated points
>    unique(X)
Planar point pattern: 2 points
window: rectangle = [0, 3] x [0, 3] units
>    unique(X, rule="deldir")
Planar point pattern: 2 points
window: rectangle = [0, 3] x [0, 3] units
> 
> 
> 
> cleanEx()
> nameEx("uniquemap.default")
> ### * uniquemap.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: uniquemap.default
> ### Title: Map Duplicate Entries to Unique Entries
> ### Aliases: uniquemap.default uniquemap.data.frame uniquemap.matrix
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   x <- c(3, 5, 2, 4, 2, 3)
>   uniquemap(x)
[1] 1 2 3 4 3 1
> 
>   df <- data.frame(A=x, B=42)
>   uniquemap(df)
[1] 1 2 3 4 3 1
> 
>   z <- cbind(x, 10-x)
>   uniquemap(z)
[1] 1 2 3 4 3 1
> 
> 
> 
> cleanEx()
> nameEx("uniquemap.ppp")
> ### * uniquemap.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: uniquemap.ppp
> ### Title: Map Duplicate Entries to Unique Entries
> ### Aliases: uniquemap uniquemap.ppp uniquemap.lpp uniquemap.ppx
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
>   Y <- runifpoint(4)
>   X <- Y[c(1,2,3,4,2,1)]
>   uniquemap(X)
[1] 1 2 3 4 2 1
> 
> 
> 
> cleanEx()
> nameEx("unitname")
> ### * unitname
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unitname
> ### Title: Name for Unit of Length
> ### Aliases: unitname unitname.dppm unitname.im unitname.kppm
> ###   unitname.minconfit unitname.owin unitname.ppp unitname.ppm
> ###   unitname.psp unitname.quad unitname.slrm unitname.tess unitname<-
> ###   unitname<-.dppm unitname<-.im unitname<-.kppm unitname<-.minconfit
> ###   unitname<-.owin unitname<-.ppp unitname<-.ppm unitname<-.psp
> ###   unitname<-.quad unitname<-.slrm unitname<-.tess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   X <- runifpoint(20)
> 
>   # if the unit of length is 1 metre:
>   unitname(X) <- c("metre", "metres")
> 
>   # if the unit of length is 6 inches:
>   unitname(X) <- list("inch", "inches", 6)
> 
> 
> 
> cleanEx()
> nameEx("unmark")
> ### * unmark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unmark
> ### Title: Remove Marks
> ### Aliases: unmark unmark.ppp unmark.splitppp unmark.psp unmark.ppx
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   data(lansing)
>   hicks <- lansing[lansing$marks == "hickory", ]
>   ## Not run: 
> ##D   plot(hicks)  # still a marked point pattern, but only 1 value of marks
> ##D   plot(unmark(hicks)) # unmarked
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("unnormdensity")
> ### * unnormdensity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unnormdensity
> ### Title: Weighted kernel smoother
> ### Aliases: unnormdensity
> ### Keywords: smooth
> 
> ### ** Examples
> 
>   d <- unnormdensity(1:3, weights=c(-1,0,1))
>   if(interactive()) plot(d)
> 
> 
> 
> cleanEx()
> nameEx("unstack.msr")
> ### * unstack.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unstack.msr
> ### Title: Separate a Vector Measure into its Scalar Components
> ### Aliases: unstack.msr
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    fit <- ppm(cells ~ x)
>    m <- residuals(fit, type="score")
>    m
2-dimensional vector-valued measure
vector components: '(Intercept)' and 'x'
Approximated by 1070 quadrature points
window: rectangle = [0, 1] x [0, 1] units
42 atoms
Total mass:
(Intercept):	 discrete = 42   continuous = -42   total = -6.445e-10
x:	 discrete = 21.803   continuous = -21.803   total = -1.7633e-10
>    unstack(m)
List of spatial objects

(Intercept):
Scalar-valued measure
Approximated by 1070 quadrature points
window: rectangle = [0, 1] x [0, 1] units
42 atoms
Total mass:
discrete = 42   continuous = -42   total = -6.445e-10

x:
Scalar-valued measure
Approximated by 1070 quadrature points
window: rectangle = [0, 1] x [0, 1] units
42 atoms
Total mass:
discrete = 21.803   continuous = -21.803   total = -1.7633e-10
> 
> 
> 
> cleanEx()
> nameEx("unstack.ppp")
> ### * unstack.ppp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unstack.ppp
> ### Title: Separate Multiple Columns of Marks
> ### Aliases: unstack.ppp unstack.psp unstack.lpp unstack.tess
> ###   unstack.lintess
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    finpines
Marked planar point pattern: 126 points
Mark variables: diameter, height 
window: rectangle = [-5, 5] x [-8, 2] metres
>    unstack(finpines)
List of point patterns

diameter:
Marked planar point pattern: 126 points
marks are numeric, of storage type  'integer'
window: rectangle = [-5, 5] x [-8, 2] metres

height:
Marked planar point pattern: 126 points
marks are numeric, of storage type  'double'
window: rectangle = [-5, 5] x [-8, 2] metres
> 
> 
> 
> cleanEx()
> nameEx("unstack.solist")
> ### * unstack.solist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unstack.solist
> ### Title: Unstack Each Spatial Object in a List of Objects
> ### Aliases: unstack.solist unstack.layered
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   A <- solist(finpines=finpines, cells=cells)
>   A
List of point patterns

finpines:
Marked planar point pattern: 126 points
Mark variables: diameter, height 
window: rectangle = [-5, 5] x [-8, 2] metres

cells:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
>   unstack(A)
List of point patterns

finpines.diameter:
Marked planar point pattern: 126 points
marks are numeric, of storage type  'integer'
window: rectangle = [-5, 5] x [-8, 2] metres

finpines.height:
Marked planar point pattern: 126 points
marks are numeric, of storage type  'double'
window: rectangle = [-5, 5] x [-8, 2] metres

cells:
Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
>   B <- layered(fin=finpines, loc=unmark(finpines),
+               plotargs=list(list(), list(pch=16)))
>   B
Layered object

fin:
Marked planar point pattern: 126 points
Mark variables: diameter, height 
window: rectangle = [-5, 5] x [-8, 2] metres

loc:
Planar point pattern: 126 points
window: rectangle = [-5, 5] x [-8, 2] metres
Includes plot arguments for loc
>   plot(B)
Plotting the first column of marks
>   unstack(B)
Layered object

fin.diameter:
Marked planar point pattern: 126 points
marks are numeric, of storage type  'integer'
window: rectangle = [-5, 5] x [-8, 2] metres

fin.height:
Marked planar point pattern: 126 points
marks are numeric, of storage type  'double'
window: rectangle = [-5, 5] x [-8, 2] metres

loc:
Planar point pattern: 126 points
window: rectangle = [-5, 5] x [-8, 2] metres
Includes plot arguments for loc
>   plot(unstack(B))
> 
> 
> 
> cleanEx()
> nameEx("update.interact")
> ### * update.interact
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.interact
> ### Title: Update an Interpoint Interaction
> ### Aliases: update.interact
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   Str <- Strauss(r=1)
>   Str
Pairwise interaction family
Interaction:Strauss process
Interaction distance:	1
>   update(Str, r=2)
Pairwise interaction family
Interaction:Strauss process
Interaction distance:	2
> 
>   M <- MultiStrauss(radii=matrix(1,2,2))
>   update(M, types=c("on", "off"))
Pairwise interaction family
Interaction:Multitype Strauss process
2 types of points
Possible types:
[1] on  off
Interaction radii:
     [,1] [,2]
[1,]    1    1
[2,]    1    1
> 
> 
> 
> cleanEx()
> nameEx("update.kppm")
> ### * update.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.kppm
> ### Title: Update a Fitted Cluster Point Process Model
> ### Aliases: update.kppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>  fit <- kppm(redwood ~1, "Thomas")
>  fitx <- update(fit, ~ . + x)
>  fitM <- update(fit, clusters="MatClust")
>  fitC <- update(fit, cells)
>  fitCx <- update(fit, cells ~ x)
> 
> 
> 
> cleanEx()
> nameEx("update.ppm")
> ### * update.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.ppm
> ### Title: Update a Fitted Point Process Model
> ### Aliases: update.ppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>   data(nztrees)
>   data(cells)
> 
>   # fit the stationary Poisson process
>   fit <- ppm(nztrees, ~ 1)
> 
>   # fit a nonstationary Poisson process
>   fitP <- update(fit, trend=~x)
>   fitP <- update(fit, ~x)
> 
>   # change the trend formula: add another term to the trend
>   fitPxy <- update(fitP, ~ . + y)
>   # change the trend formula: remove the x variable
>   fitPy <- update(fitPxy, ~ . - x)
> 
>   # fit a stationary Strauss process
>   fitS <- update(fit, interaction=Strauss(13))
>   fitS <- update(fit, Strauss(13))
> 
>   # refit using a different edge correction
>   fitS <- update(fitS, correction="isotropic")
> 
>   # re-fit the model to a subset
>   # of the original point pattern
>   nzw <- owin(c(0,148),c(0,95))
>   nzsub <- nztrees[,nzw]
>   fut <- update(fitS, Q=nzsub)
>   fut <- update(fitS, nzsub)
> 
>   # WARNING: the point pattern argument is called 'Q'
> 
>   ranfit <- ppm(rpoispp(42), ~1, Poisson())
>   ranfit
Stationary Poisson process
Intensity: 37
            Estimate     S.E.  CI95.lo  CI95.hi Ztest     Zval
log(lambda) 3.610918 0.164399 3.288702 3.933134   *** 21.96436
>   # different random data!  
>   update(ranfit)
Stationary Poisson process
Intensity: 40
            Estimate      S.E.  CI95.lo  CI95.hi Ztest     Zval
log(lambda) 3.688879 0.1581139 3.378982 3.998777   *** 23.33052
>   # the original data
>   update(ranfit, use.internal=TRUE)  
Stationary Poisson process
Intensity: 37
            Estimate     S.E.  CI95.lo  CI95.hi Ztest     Zval
log(lambda) 3.610918 0.164399 3.288702 3.933134   *** 21.96436
> 
> 
> 
> 
> cleanEx()
> nameEx("update.rmhcontrol")
> ### * update.rmhcontrol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.rmhcontrol
> ### Title: Update Control Parameters of Metropolis-Hastings Algorithm
> ### Aliases: update.rmhcontrol
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>   a <- rmhcontrol(expand=1)
>   update(a, expand=2)
Metropolis-Hastings algorithm control parameters
Probability of shift proposal: p = 0.9
Conditional probability of death proposal: q = 0.9
Number of M-H iterations: nrep = 500000
Generate random proposal points: before each block of  iterations.
Track proposal type and acceptance/rejection? no 
No progress reports (nverb = 0).
Expand the simulation window? Yes:
	 Area expansion factor 2 
Periodic edge correction? Not yet determined.
> 
> 
> 
> cleanEx()
> nameEx("update.symbolmap")
> ### * update.symbolmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.symbolmap
> ### Title: Update a Graphics Symbol Map.
> ### Aliases: update.symbolmap
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   g <- symbolmap(size=function(x) x/50)
>   g
Symbol map for real numbers
size: function (x) 
x/50
shape: circles
>   update(g, range=c(0,1))
Symbol map for real numbers in [0, 1]
size: function (x) 
x/50
shape: circles
>   update(g, size=42)
Symbol map with constant values
size: 42
shape: circles
>   update(g, shape="squares", range=c(0,1))
Symbol map for real numbers in [0, 1]
shape: squares
size: function (x) 
x/50
> 
> 
> 
> cleanEx()
> nameEx("valid.detpointprocfamily")
> ### * valid.detpointprocfamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: valid.detpointprocfamily
> ### Title: Check Validity of a Determinantal Point Process Model
> ### Aliases: valid.detpointprocfamily
> ### Keywords: spatial models
> 
> ### ** Examples
> 
> model1 <- dppMatern(lambda=100, alpha=.01, nu=1, d=2)
> valid(model1)
[1] TRUE
> model2 <- dppMatern(lambda=100, alpha=1, nu=1, d=2)
> valid(model2)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("valid.ppm")
> ### * valid.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: valid.ppm
> ### Title: Check Whether Point Process Model is Valid
> ### Aliases: valid.ppm
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fit1 <- ppm(cells, ~1, Strauss(0.1))
>    valid(fit1)
[1] TRUE
>    fit2 <- ppm(redwood, ~1, Strauss(0.1))
>    valid(fit2)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("varblock")
> ### * varblock
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: varblock
> ### Title: Estimate Variance of Summary Statistic by Subdivision
> ### Aliases: varblock
> ### Keywords: nonparametric spatial
> 
> ### ** Examples
> 
>    v <- varblock(amacrine, Kest, nx=4, ny=2)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>    v <- varblock(amacrine, Kcross, nx=4, ny=2)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>    if(interactive()) plot(v, iso ~ r, shade=c("hiiso", "loiso"))
> 
> 
> 
> cleanEx()
> nameEx("varcount")
> ### * varcount
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: varcount
> ### Title: Predicted Variance of the Number of Points
> ### Aliases: varcount
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    fitT <- kppm(redwood ~ 1, "Thomas")
>    B <- owin(c(0, 0.5), c(-0.5, 0))
>    varcount(fitT, B)
[1] 48.52428
> 
>    fitS <- ppm(swedishpines ~ 1, Strauss(9))
>    BS <- square(50)
>    varcount(fitS, BS)
[1] 28.90709
> 
> 
> 
> cleanEx()
> nameEx("vargamma.estK")
> ### * vargamma.estK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vargamma.estK
> ### Title: Fit the Neyman-Scott Cluster Point Process with Variance Gamma
> ###   kernel
> ### Aliases: vargamma.estK
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>    ## Don't show: 
>      u <- vargamma.estK(redwood, startpar=c(kappa=15, eta=0.075))
>     
> ## End(Don't show)
>     if(interactive()) {
+       u <- vargamma.estK(redwood)
+       u
+       plot(u)
+     }
> 
> 
> 
> cleanEx()
> nameEx("vargamma.estpcf")
> ### * vargamma.estpcf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vargamma.estpcf
> ### Title: Fit the Neyman-Scott Cluster Point Process with Variance Gamma
> ###   kernel
> ### Aliases: vargamma.estpcf
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>     u <- vargamma.estpcf(redwood)
>     u
Minimum contrast fit (object of class "minconfit")
Model: Variance Gamma process
	 Kernel model: VarGamma
	 Kernel parameters: nu.ker = -0.25, nu.pcf = 0.5
Fitted by matching theoretical g function to pcf(redwood)

Internal parameters fitted by minimum contrast ($par):
      kappa         eta 
22.68733728  0.05128427 

Fitted cluster parameters:
      kappa       scale 
22.68733728  0.05128427 

Converged successfully after 143 function evaluations

Starting values of parameters:
kappa   eta 
    1     1 
Domain of integration: [ 0.0004883 , 0.25 ]
Exponents: p= 2, q= 0.25
>     plot(u, legendpos="topright")
> 
> 
> 
> cleanEx()
> nameEx("vcov.kppm")
> ### * vcov.kppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.kppm
> ### Title: Variance-Covariance Matrix for a Fitted Cluster Point Process
> ###   Model
> ### Aliases: vcov.kppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>    fit <- kppm(redwood ~ x + y)
>    vcov(fit)
            (Intercept)             x             y
(Intercept)   0.3700704 -0.3137127808  0.3087264902
x            -0.3137128  0.6155368039 -0.0001232051
y             0.3087265 -0.0001232051  0.6154539053
>    vcov(fit, what="corr")
            (Intercept)             x             y
(Intercept)   1.0000000 -0.6572990894  0.6468952475
x            -0.6572991  1.0000000000 -0.0002001723
y             0.6468952 -0.0002001723  1.0000000000
> 
>    # confidence interval
>    confint(fit)
                2.5 %   97.5 %
(Intercept)  2.759137 5.143762
x           -1.240010 1.835415
y           -1.583685 1.491533
>    # cross-check the confidence interval by hand:
>    sd <- sqrt(diag(vcov(fit)))
>    t(coef(fit) + 1.96 * outer(sd, c(lower=-1, upper=1)))
      (Intercept)         x         y
lower    2.759115 -1.240038 -1.583713
upper    5.143784  1.835443  1.491561
> 
> 
> 
> cleanEx()
> nameEx("vcov.mppm")
> ### * vcov.mppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.mppm
> ### Title: Calculate Variance-Covariance Matrix for Fitted Multiple Point
> ###   Process Model
> ### Aliases: vcov.mppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>    fit <- mppm(Wat ~x, data=hyperframe(Wat=waterstriders))
>    vcov(fit)
             (Intercept)             x
(Intercept)  0.034053679 -1.092867e-03
x           -0.001092867  4.784558e-05
> 
> 
> 
> cleanEx()
> nameEx("vcov.ppm")
> ### * vcov.ppm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.ppm
> ### Title: Variance-Covariance Matrix for a Fitted Point Process Model
> ### Aliases: vcov.ppm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>   X <- rpoispp(42)
>   fit <- ppm(X, ~ x + y)
>   vcov(fit)
            (Intercept)             x             y
(Intercept)   0.2054338 -1.705970e-01 -1.703849e-01
x            -0.1705970  3.258048e-01  5.617552e-05
y            -0.1703849  5.617552e-05  3.257884e-01
>   vcov(fit, what="Fish")
            (Intercept)        x        y
(Intercept)    37.00000 19.37050 19.34738
x              19.37050 13.21030 10.12835
y              19.34738 10.12835 13.18626
> 
>   # example of singular system
>   m <- ppm(demopat ~polynom(x,y,2))
>   ## Not run: 
> ##D     try(v <- vcov(m))
> ##D   
> ## End(Not run)
>   # rescale x, y coordinates to range [0,1] x [0,1] approximately
>   demopatScale <- rescale(demopat, 10000)
>   m <- ppm(demopatScale ~ polynom(x,y,2))
>   v <- vcov(m)
> 
>   # Gibbs example
>   fitS <- ppm(swedishpines ~1, Strauss(9))
>   coef(fitS)
(Intercept) Interaction 
  -2.908028   -1.330088 
>   sqrt(diag(vcov(fitS)))
(Intercept) Interaction 
  0.3195345   0.1918928 
> 
> 
> 
> cleanEx()
> nameEx("vcov.slrm")
> ### * vcov.slrm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.slrm
> ### Title: Variance-Covariance Matrix for a Fitted Spatial Logistic
> ###   Regression
> ### Aliases: vcov.slrm
> ### Keywords: spatial methods models
> 
> ### ** Examples
> 
>   X <- rpoispp(42)
>   fit <- slrm(X ~ x + y)
>   vcov(fit)
            (Intercept)             x             y
(Intercept)   0.2057397 -1.708596e-01 -1.706230e-01
x            -0.1708596  3.263832e-01  1.268557e-05
y            -0.1706230  1.268557e-05  3.263200e-01
>   vcov(fit, what="corr")
            (Intercept)             x             y
(Intercept)   1.0000000 -6.593506e-01 -6.585015e-01
x            -0.6593506  1.000000e+00  3.887087e-05
y            -0.6585015  3.887087e-05  1.000000e+00
>   vcov(fit, what="f")
            (Intercept)        x        y
(Intercept)    36.91537 19.32421 19.30120
x              19.32421 13.17960 10.10355
y              19.30120 10.10355 13.15611
> 
> 
> 
> cleanEx()
> nameEx("venn.tess")
> ### * venn.tess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: venn.tess
> ### Title: Tessellation Delimited by Several Sets
> ### Aliases: venn.tess
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    V <- venn.tess(A=square(1),
+                   B=square(c(-0.5, 0.5)),
+                   window=square(c(-1,1.5)))
>    V
Tessellation
Tiles are windows of general type
4 tiles (irregular windows)
window: rectangle = [-1, 1.5] x [-1, 1.5] units
>    plot(V, do.labels=TRUE)
> 
> 
> 
> cleanEx()
> nameEx("vertices")
> ### * vertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vertices
> ### Title: Vertices of a Window
> ### Aliases: vertices vertices.owin
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>   data(letterR)
>   vert <- vertices(letterR)
> 
>   plot(letterR, main="Polygonal vertices")
>   points(vert)
>   plot(letterR, main="Boundary pixels")
>   points(vertices(as.mask(letterR)))
> 
> 
> 
> cleanEx()
> nameEx("weighted.median")
> ### * weighted.median
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weighted.median
> ### Title: Weighted Median, Quantiles or Variance
> ### Aliases: weighted.median weighted.quantile weighted.var
> ### Keywords: math
> 
> ### ** Examples
> 
>   x <- 1:20
>   w <- runif(20)
>   weighted.median(x, w)
[1] 10.17736
>   weighted.quantile(x, w)
       0%       25%       50%       75%      100% 
 1.000000  5.506974 10.177364 16.127044 20.000000 
>   weighted.var(x, w)
         [,1]
[1,] 36.90303
> 
> 
> 
> cleanEx()
> nameEx("where.max")
> ### * where.max
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: where.max
> ### Title: Find Location of Maximum in a Pixel Image
> ### Aliases: where.max where.min
> ### Keywords: spatial math
> 
> ### ** Examples
> 
>    D <- distmap(letterR, invert=TRUE)
>    plot(D)
>    plot(where.max(D), add=TRUE, pch=16, cols="green")
> 
> 
> 
> cleanEx()
> nameEx("whichhalfplane")
> ### * whichhalfplane
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: whichhalfplane
> ### Title: Test Which Side of Infinite Line a Point Falls On
> ### Aliases: whichhalfplane
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   L <- infline(p=runif(3), theta=runif(3, max=2*pi))
>   X <- runifpoint(4)
>   whichhalfplane(L, X)
      [,1]  [,2]  [,3]  [,4]
[1,]  TRUE  TRUE FALSE FALSE
[2,] FALSE  TRUE FALSE FALSE
[3,]  TRUE FALSE FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("whist")
> ### * whist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: whist
> ### Title: Weighted Histogram
> ### Aliases: whist
> ### Keywords: arith
> 
> ### ** Examples
> 
>   x <- rnorm(100)
>   b <- seq(-1,1,length=21)
>   w <- runif(100)
>   whist(x,b,w)
 [1] 0.1693109 1.0353730 1.0224175 2.3786884 1.1438075 2.2939080 1.8099071
 [8] 0.5783539 2.6176054 2.9722970 1.7682541 1.0040830 0.4135155 2.5880552
[15] 1.4789985 1.8412192 2.4940212 1.2070346 1.8966897 1.2158296
attr(,"low")
[1] 3.882516
attr(,"high")
[1] 7.689645
> 
> 
> 
> cleanEx()
> nameEx("will.expand")
> ### * will.expand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: will.expand
> ### Title: Test Expansion Rule
> ### Aliases: will.expand
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>   x <- rmhexpand(distance=0.2)
>   y <- rmhexpand(area=1)
>   will.expand(x)
[1] TRUE
>   will.expand(y)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("with.fv")
> ### * with.fv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: with.fv
> ### Title: Evaluate an Expression in a Function Table
> ### Aliases: with.fv
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   # compute 4 estimates of the K function
>   X <- rpoispp(42)
>   K <- Kest(X)
>   plot(K)
> 
>   # derive 4 estimates of the L function L(r) = sqrt(K(r)/pi)
>   L <- with(K, sqrt(./pi))
>   plot(L)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
>   # compute 4 estimates of V(r) = L(r)/r
>   V <- with(L, ./.x)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
>   plot(V)
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
Warning in (function (fmt, ...)  : argument not used by format
> 
>   # compute the maximum absolute difference between
>   # the isotropic and translation correction estimates of K(r)
>   D <- with(K, max(abs(iso - trans)))
> 
> 
> 
> cleanEx()
> nameEx("with.hyperframe")
> ### * with.hyperframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: with.hyperframe
> ### Title: Evaluate an Expression in Each Row of a Hyperframe
> ### Aliases: with.hyperframe
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   # generate Poisson point patterns with intensities 10 to 100
>    H <- hyperframe(L=seq(10,100, by=10))
>    X <- with(H, rpoispp(L))
> 
> 
> 
> cleanEx()
> nameEx("with.msr")
> ### * with.msr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: with.msr
> ### Title: Evaluate Expression Involving Components of a Measure
> ### Aliases: with.msr
> ### Keywords: spatial manip
> 
> ### ** Examples
> 
>    X <- rpoispp(function(x,y) { exp(3+3*x) })
>    fit <- ppm(X, ~x+y)
>    rp <- residuals(fit, type="pearson")
> 
>    with(rp, atoms)
Planar point pattern: 129 points
window: rectangle = [0, 1] x [0, 1] units
>    with(rp, qlocations %mark% continuous)
Marked planar point pattern: 1157 points
marks are numeric, of storage type  'double'
window: rectangle = [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("with.ssf")
> ### * with.ssf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: with.ssf
> ### Title: Evaluate Expression in a Spatially Sampled Function
> ### Aliases: with.ssf apply.ssf
> ### Keywords: spatial manip programming
> 
> ### ** Examples
> 
>   a <- ssf(cells, data.frame(d=nndist(cells), i=1:npoints(cells)))
>   with(a, i/d)
Spatially sampled function
Locations:
	Planar point pattern: 42 points
window: rectangle = [0, 1] x [0, 1] units
Scalar valued function
> 
> 
> 
> cleanEx()
> nameEx("yardstick")
> ### * yardstick
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yardstick
> ### Title: Text, Arrow or Scale Bar in a Diagram
> ### Aliases: textstring onearrow yardstick
> ### Keywords: spatial hplot
> 
> ### ** Examples
> 
>   X <- rescale(swedishpines)
>   plot(X, pch=16, main="")
>   yd <- yardstick(0,0,1,1, "diagonal")
>   yy <- yardstick(X[1:2])
>   ys <- yardstick(as.psp(list(xmid=4, ymid=0.5, length=1, angle=0),
+                          window=Window(X)),
+                   txt="1 m")
>   ys
Yardstick
Text: 1 m
Length: 1 metres
Midpoint: (4, 0.5)
Orientation: horizontal
>   plot(ys, angle=90)
>   scalardilate(ys, 2)
Yardstick
Text: 1 m
Length: 2 metres
Midpoint: (8, 1)
Orientation: horizontal
> 
> 
> 
> cleanEx()
> nameEx("zapsmall.im")
> ### * zapsmall.im
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zapsmall.im
> ### Title: Rounding of Pixel Values
> ### Aliases: zapsmall.im
> ### Keywords: spatial methods univar
> 
> ### ** Examples
> 
>   data(cells)
>   D <- density(cells)
>   zapsmall.im(D)
real-valued pixel image
128 x 128 pixel array (ny, nx)
enclosing rectangle: [0, 1] x [0, 1] units
> 
> 
> 
> cleanEx()
> nameEx("zclustermodel")
> ### * zclustermodel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zclustermodel
> ### Title: Cluster Point Process Model
> ### Aliases: zclustermodel
> ### Keywords: spatial models
> 
> ### ** Examples
> 
>   m <- zclustermodel("Thomas", kappa=10, mu=5, scale=0.1)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  165.15 5.39 184.39 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
